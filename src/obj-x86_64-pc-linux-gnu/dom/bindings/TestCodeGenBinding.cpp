/* THIS FILE IS AUTOGENERATED FROM TestCodeGen.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "CustomEventBinding.h"
#include "GeckoProfiler.h"
#include "TestBindingHeader.h"
#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "WrapperFactory.h"
#include "XrayWrapper.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "js/shadow/Object.h"
#include "jsapi.h"
#include "jsfriendapi.h"
#include "mozilla/Atomics.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/StaticPrefs_dom.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CustomElementRegistry.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMJSProxyHandler.h"
#include "mozilla/dom/DocGroup.h"
#include "mozilla/dom/Document.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/Record.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/UnionTypes.h"
#include "mozilla/dom/WebIDLPrefs.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsGenericHTMLElement.h"
#include "nsJSUtils.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace TestEnumValues {
extern const EnumEntry strings[6] = {
  {"1", 1},
  {"a", 1},
  {"b", 1},
  {"1-2", 3},
  {"2d-array", 8},
  { nullptr, 0 }
};
} // namespace TestEnumValues

bool
ToJSValue(JSContext* aCx, TestEnum aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(TestEnumValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, TestEnumValues::strings[uint32_t(aArgument)].value,
                      TestEnumValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}



DictContainingSequence::DictContainingSequence()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
DictContainingSequence::InitIds(JSContext* cx, DictContainingSequenceAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->ourSequence9_id.init(cx, "ourSequence9") ||
      !atomsCache->ourSequence8_id.init(cx, "ourSequence8") ||
      !atomsCache->ourSequence7_id.init(cx, "ourSequence7") ||
      !atomsCache->ourSequence6_id.init(cx, "ourSequence6") ||
      !atomsCache->ourSequence5_id.init(cx, "ourSequence5") ||
      !atomsCache->ourSequence4_id.init(cx, "ourSequence4") ||
      !atomsCache->ourSequence3_id.init(cx, "ourSequence3") ||
      !atomsCache->ourSequence2_id.init(cx, "ourSequence2") ||
      !atomsCache->ourSequence10_id.init(cx, "ourSequence10") ||
      !atomsCache->ourSequence_id.init(cx, "ourSequence")) {
    return false;
  }
  return true;
}

bool
DictContainingSequence::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  DictContainingSequenceAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<DictContainingSequenceAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence' member of DictContainingSequence");
        return false;
      }
      Sequence<int32_t> &arr = (mOurSequence.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'ourSequence' member of DictContainingSequence", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence10_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence10.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence10' member of DictContainingSequence");
        return false;
      }
      Sequence<OwningFloatOrString> &arr = (mOurSequence10.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningFloatOrString* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningFloatOrString& slot = *slotPtr;
        {
          bool done = false, failed = false, tryNext;
          do {
            if (temp.isNumber()) {
              done = (failed = !slot.TrySetToFloat(cx, temp, tryNext)) || !tryNext;
              break;
            }
            done = (failed = !slot.TrySetToString(cx, temp, tryNext)) || !tryNext;
            break;
          } while (false);
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of 'ourSequence10' member of DictContainingSequence", "");
            return false;
          }
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence10' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence2.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence2' member of DictContainingSequence");
        return false;
      }
      Sequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = (mOurSequence2.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of 'ourSequence2' member of DictContainingSequence", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence2' member of DictContainingSequence");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence2' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence3_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence3.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence3' member of DictContainingSequence");
        return false;
      }
      Sequence<JS::Value> &arr = (mOurSequence3.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((passedToJSImpl) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence3' member of DictContainingSequence");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence3' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence4_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence4.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence4' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = (mOurSequence4.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence4' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence4' member of DictContainingSequence");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence4' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence5_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence5.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence5' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = (mOurSequence5.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence5' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else if (temp.isNullOrUndefined()) {
          slot = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence5' member of DictContainingSequence");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence5' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence6_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence6.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence6' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = (mOurSequence6.Value()).SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence6' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence6' member of DictContainingSequence");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mOurSequence6.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence6' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence7_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOurSequence7.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence7' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = (mOurSequence7.Value()).SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence7' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else if (temp.isNullOrUndefined()) {
          slot = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence7' member of DictContainingSequence");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mOurSequence7.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence7' member of DictContainingSequence");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence8_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence8' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = mOurSequence8.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence8' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence8' member of DictContainingSequence");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mOurSequence8.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence8' member of DictContainingSequence");
      return false;
    }
  } else {
    mOurSequence8.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ourSequence9_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence9' member of DictContainingSequence");
        return false;
      }
      Sequence<JSObject*> &arr = mOurSequence9.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'ourSequence9' member of DictContainingSequence");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else if (temp.isNullOrUndefined()) {
          slot = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'ourSequence9' member of DictContainingSequence");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mOurSequence9.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'ourSequence9' member of DictContainingSequence");
      return false;
    }
  } else {
    mOurSequence9.SetNull();
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
DictContainingSequence::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
DictContainingSequence::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DictContainingSequenceAtoms* atomsCache = GetAtomCache<DictContainingSequenceAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mOurSequence.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<int32_t> const & currentValue = mOurSequence.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(currentValue[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence10.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<OwningFloatOrString> const & currentValue = mOurSequence10.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!currentValue[sequenceIdx0].ToJSVal(cx, returnArray, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence10_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence2.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<OwningNonNull<mozilla::dom::TestInterface>> const & currentValue = mOurSequence2.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!GetOrCreateDOMReflector(cx, currentValue[sequenceIdx0], &tmp)) {
              MOZ_ASSERT(JS_IsExceptionPending(cx));
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence2_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence3.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<JS::Value> const & currentValue = mOurSequence3.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeValueToActiveJS(currentValue[sequenceIdx0]);
            tmp.set(currentValue[sequenceIdx0]);
            if (!MaybeWrapValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence3_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence4.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<JSObject*> const & currentValue = mOurSequence4.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeObjectToActiveJS(currentValue[sequenceIdx0]);
            tmp.setObject(*currentValue[sequenceIdx0]);
            if (!MaybeWrapObjectValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence4_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence5.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<JSObject*> const & currentValue = mOurSequence5.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (currentValue[sequenceIdx0]) {
                          JS::ExposeObjectToActiveJS(currentValue[sequenceIdx0]);
                        }
                        tmp.setObjectOrNull(currentValue[sequenceIdx0]);
            if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence5_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence6.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<Sequence<JSObject*>> const & currentValue = mOurSequence6.InternalValue();

      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence6_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }

      uint32_t length = currentValue.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeObjectToActiveJS(currentValue.Value()[sequenceIdx0]);
            tmp.setObject(*currentValue.Value()[sequenceIdx0]);
            if (!MaybeWrapObjectValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence6_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mOurSequence7.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<Sequence<JSObject*>> const & currentValue = mOurSequence7.InternalValue();

      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence7_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }

      uint32_t length = currentValue.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (currentValue.Value()[sequenceIdx0]) {
                          JS::ExposeObjectToActiveJS(currentValue.Value()[sequenceIdx0]);
                        }
                        tmp.setObjectOrNull(currentValue.Value()[sequenceIdx0]);
            if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence7_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Sequence<JSObject*>> const & currentValue = mOurSequence8;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence8_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    uint32_t length = currentValue.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeObjectToActiveJS(currentValue.Value()[sequenceIdx0]);
          tmp.setObject(*currentValue.Value()[sequenceIdx0]);
          if (!MaybeWrapObjectValue(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence8_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Sequence<JSObject*>> const & currentValue = mOurSequence9;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence9_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    uint32_t length = currentValue.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (currentValue.Value()[sequenceIdx0]) {
                        JS::ExposeObjectToActiveJS(currentValue.Value()[sequenceIdx0]);
                      }
                      tmp.setObjectOrNull(currentValue.Value()[sequenceIdx0]);
          if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->ourSequence9_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
DictContainingSequence::TraceDictionary(JSTracer* trc)
{
  if (mOurSequence3.WasPassed()) {
    DoTraceSequence(trc, mOurSequence3.Value());
  }

  if (mOurSequence4.WasPassed()) {
    DoTraceSequence(trc, mOurSequence4.Value());
  }

  if (mOurSequence5.WasPassed()) {
    DoTraceSequence(trc, mOurSequence5.Value());
  }

  if (mOurSequence6.WasPassed()) {
    if (!mOurSequence6.Value().IsNull()) {
      DoTraceSequence(trc, mOurSequence6.Value().Value());
    }
  }

  if (mOurSequence7.WasPassed()) {
    if (!mOurSequence7.Value().IsNull()) {
      DoTraceSequence(trc, mOurSequence7.Value().Value());
    }
  }

  if (!mOurSequence8.IsNull()) {
    DoTraceSequence(trc, mOurSequence8.Value());
  }

  if (!mOurSequence9.IsNull()) {
    DoTraceSequence(trc, mOurSequence9.Value());
  }
}



namespace binding_detail {
} // namespace binding_detail



DictWithAllowSharedMembers::DictWithAllowSharedMembers()
{
  // Safe to pass a null context if we pass a null value
  Init();
}


bool
DictWithAllowSharedMembers::InitIds(JSContext* cx, DictWithAllowSharedMembersAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->f_id.init(cx, "f") ||
      !atomsCache->e_id.init(cx, "e") ||
      !atomsCache->d_id.init(cx, "d") ||
      !atomsCache->c_id.init(cx, "c") ||
      !atomsCache->b_id.init(cx, "b") ||
      !atomsCache->a_id.init(cx, "a")) {
    return false;
  }
  return true;
}

bool
DictWithAllowSharedMembers::Init(const char* sourceDescription, bool passedToJSImpl)
{
  return true;
}

void
DictWithAllowSharedMembers::TraceDictionary(JSTracer* trc)
{
  if (mA.WasPassed()) {
    mA.Value().TraceSelf(trc);
  }

  if (mB.WasPassed()) {
    if (!mB.Value().IsNull()) {
      mB.Value().Value().TraceSelf(trc);
    }
  }

  if (mC.WasPassed()) {
    mC.Value().TraceSelf(trc);
  }

  if (mD.WasPassed()) {
    if (!mD.Value().IsNull()) {
      mD.Value().Value().TraceSelf(trc);
    }
  }

  if (mE.WasPassed()) {
    mE.Value().TraceSelf(trc);
  }

  if (mF.WasPassed()) {
    mF.Value().TraceSelf(trc);
  }
}

namespace binding_detail {
} // namespace binding_detail



DictWithConditionalMembers::DictWithConditionalMembers()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
DictWithConditionalMembers::InitIds(JSContext* cx, DictWithConditionalMembersAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->prefControlledMember_id.init(cx, "prefControlledMember") ||
      !atomsCache->funcControlledMember_id.init(cx, "funcControlledMember") ||
      !atomsCache->chromeOnlyMember_id.init(cx, "chromeOnlyMember") ||
      !atomsCache->chromeOnlyFuncControlledMember_id.init(cx, "chromeOnlyFuncControlledMember") ||
      !atomsCache->chromeOnlyFuncAndPrefControlledMember_id.init(cx, "chromeOnlyFuncAndPrefControlledMember")) {
    return false;
  }
  return true;
}

bool
DictWithConditionalMembers::Init(const char* sourceDescription, bool passedToJSImpl)
{
  return true;
}

void
DictWithConditionalMembers::TraceDictionary(JSTracer* trc)
{
}

DictWithConditionalMembers&
DictWithConditionalMembers::operator=(const DictWithConditionalMembers& aOther)
{
  DictionaryBase::operator=(aOther);
  mChromeOnlyFuncAndPrefControlledMember.Reset();
  if (aOther.mChromeOnlyFuncAndPrefControlledMember.WasPassed()) {
    mChromeOnlyFuncAndPrefControlledMember.Construct(aOther.mChromeOnlyFuncAndPrefControlledMember.Value());
  }
  mChromeOnlyFuncControlledMember.Reset();
  if (aOther.mChromeOnlyFuncControlledMember.WasPassed()) {
    mChromeOnlyFuncControlledMember.Construct(aOther.mChromeOnlyFuncControlledMember.Value());
  }
  mChromeOnlyMember.Reset();
  if (aOther.mChromeOnlyMember.WasPassed()) {
    mChromeOnlyMember.Construct(aOther.mChromeOnlyMember.Value());
  }
  mFuncControlledMember.Reset();
  if (aOther.mFuncControlledMember.WasPassed()) {
    mFuncControlledMember.Construct(aOther.mFuncControlledMember.Value());
  }
  mPrefControlledMember.Reset();
  if (aOther.mPrefControlledMember.WasPassed()) {
    mPrefControlledMember.Construct(aOther.mPrefControlledMember.Value());
  }
  return *this;
}

bool
DictWithConditionalMembers::operator==(const DictWithConditionalMembers& aOther) const
{
  if (mChromeOnlyFuncAndPrefControlledMember != aOther.mChromeOnlyFuncAndPrefControlledMember) {
      return false;
  }
  if (mChromeOnlyFuncControlledMember != aOther.mChromeOnlyFuncControlledMember) {
      return false;
  }
  if (mChromeOnlyMember != aOther.mChromeOnlyMember) {
      return false;
  }
  if (mFuncControlledMember != aOther.mFuncControlledMember) {
      return false;
  }
  if (mPrefControlledMember != aOther.mPrefControlledMember) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



ParentDict::ParentDict()
  : GrandparentDict(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
ParentDict::InitIds(JSContext* cx, ParentDictAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->someNullableInterface_id.init(cx, "someNullableInterface") ||
      !atomsCache->someInterface_id.init(cx, "someInterface") ||
      !atomsCache->someExternalInterface_id.init(cx, "someExternalInterface") ||
      !atomsCache->parentAny_id.init(cx, "parentAny") ||
      !atomsCache->c_id.init(cx, "c")) {
    return false;
  }
  return true;
}

bool
ParentDict::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  ParentDictAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ParentDictAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  // Per spec, we init the parent's members first
  if (!GrandparentDict::Init(cx, val)) {
    return false;
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->c_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'c' member of ParentDict", &mC)) {
      return false;
    }
  } else {
    mC = 5;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->parentAny_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'parentAny' member of ParentDict");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    mParentAny = temp.ref();
  } else {
    mParentAny = JS::UndefinedValue();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someExternalInterface_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSomeExternalInterface.Construct();
    if (temp.ref().isObject()) {
      static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
      RefPtr<mozilla::dom::TestExternalInterface> holder;
      JS::Rooted<JSObject*> source(cx, &temp.ref().toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(holder)))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'someExternalInterface' member of ParentDict", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(holder);
      (mSomeExternalInterface.Value()) = holder;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'someExternalInterface' member of ParentDict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someInterface_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSomeInterface.Construct();
    if (temp.ref().isObject()) {
      static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(temp.ptr(), (mSomeInterface.Value()), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'someInterface' member of ParentDict", "TestInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'someInterface' member of ParentDict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someNullableInterface_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(temp.ptr(), mSomeNullableInterface, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'someNullableInterface' member of ParentDict", "TestInterface");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mSomeNullableInterface = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'someNullableInterface' member of ParentDict");
      return false;
    }
  } else {
    mSomeNullableInterface = nullptr;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ParentDict::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
ParentDict::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ParentDictAtoms* atomsCache = GetAtomCache<ParentDictAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  // Per spec, we define the parent's members first
  if (!GrandparentDict::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mC;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->c_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JS::Value const & currentValue = mParentAny;
    JS::ExposeValueToActiveJS(currentValue);
    temp.set(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->parentAny_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mSomeExternalInterface.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      RefPtr<mozilla::dom::TestExternalInterface> const & currentValue = mSomeExternalInterface.InternalValue();
      if (!WrapObject(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someExternalInterface_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSomeInterface.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      OwningNonNull<mozilla::dom::TestInterface> const & currentValue = mSomeInterface.InternalValue();
      if (!GetOrCreateDOMReflector(cx, currentValue, &temp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someInterface_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    RefPtr<mozilla::dom::TestInterface> const & currentValue = mSomeNullableInterface;
    if (!currentValue) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someNullableInterface_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    if (!GetOrCreateDOMReflector(cx, currentValue, &temp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->someNullableInterface_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
ParentDict::TraceDictionary(JSTracer* trc)
{
  GrandparentDict::TraceDictionary(trc);
  JS::UnsafeTraceRoot(trc, &mParentAny, "ParentDict.mParentAny");
}



namespace binding_detail {
} // namespace binding_detail



TestAttributesOnDictionaryMembers::TestAttributesOnDictionaryMembers()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
TestAttributesOnDictionaryMembers::InitIds(JSContext* cx, TestAttributesOnDictionaryMembersAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->d_id.init(cx, "d") ||
      !atomsCache->c_id.init(cx, "c") ||
      !atomsCache->b_id.init(cx, "b") ||
      !atomsCache->a_id.init(cx, "a")) {
    return false;
  }
  return true;
}

bool
TestAttributesOnDictionaryMembers::Init(const char* sourceDescription, bool passedToJSImpl)
{
  return true;
}

void
TestAttributesOnDictionaryMembers::TraceDictionary(JSTracer* trc)
{
}

TestAttributesOnDictionaryMembers&
TestAttributesOnDictionaryMembers::operator=(const TestAttributesOnDictionaryMembers& aOther)
{
  DictionaryBase::operator=(aOther);
  mA.Reset();
  if (aOther.mA.WasPassed()) {
    mA.Construct(aOther.mA.Value());
  }
  mB.Reset();
  if (aOther.mB.WasPassed()) {
    mB.Construct(aOther.mB.Value());
  }
  mC = aOther.mC;
  mD.Reset();
  if (aOther.mD.WasPassed()) {
    mD.Construct(aOther.mD.Value());
  }
  return *this;
}

bool
TestAttributesOnDictionaryMembers::operator==(const TestAttributesOnDictionaryMembers& aOther) const
{
  if (mA != aOther.mA) {
      return false;
  }
  if (mB != aOther.mB) {
      return false;
  }
  if (mC != aOther.mC) {
      return false;
  }
  if (mD != aOther.mD) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



Dict::Dict()
  : ParentDict(FastDictionaryInitializer()),
    mAnotherObj(nullptr),
    mRequiredObject(nullptr)
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
Dict::InitIds(JSContext* cx, DictAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->z_id.init(cx, "z") ||
      !atomsCache->yetAnotherStr_id.init(cx, "yetAnotherStr") ||
      !atomsCache->x_id.init(cx, "x") ||
      !atomsCache->utf8StringRecord_id.init(cx, "utf8StringRecord") ||
      !atomsCache->usvStringRecord_id.init(cx, "usvStringRecord") ||
      !atomsCache->urFloat4_id.init(cx, "urFloat4") ||
      !atomsCache->urFloat3_id.init(cx, "urFloat3") ||
      !atomsCache->urFloat2_id.init(cx, "urFloat2") ||
      !atomsCache->urFloat_id.init(cx, "urFloat") ||
      !atomsCache->urDouble4_id.init(cx, "urDouble4") ||
      !atomsCache->urDouble3_id.init(cx, "urDouble3") ||
      !atomsCache->urDouble2_id.init(cx, "urDouble2") ||
      !atomsCache->urDouble_id.init(cx, "urDouble") ||
      !atomsCache->uint8Array_id.init(cx, "uint8Array") ||
      !atomsCache->template_id.init(cx, "template") ||
      !atomsCache->str_id.init(cx, "str") ||
      !atomsCache->someObj_id.init(cx, "someObj") ||
      !atomsCache->someEnum_id.init(cx, "someEnum") ||
      !atomsCache->someCallback_id.init(cx, "someCallback") ||
      !atomsCache->someAny_id.init(cx, "someAny") ||
      !atomsCache->seq5_id.init(cx, "seq5") ||
      !atomsCache->seq4_id.init(cx, "seq4") ||
      !atomsCache->seq3_id.init(cx, "seq3") ||
      !atomsCache->seq2_id.init(cx, "seq2") ||
      !atomsCache->seq1_id.init(cx, "seq1") ||
      !atomsCache->requiredUTF8Record_id.init(cx, "requiredUTF8Record") ||
      !atomsCache->requiredUSVRecord_id.init(cx, "requiredUSVRecord") ||
      !atomsCache->requiredRecord_id.init(cx, "requiredRecord") ||
      !atomsCache->requiredObject_id.init(cx, "requiredObject") ||
      !atomsCache->requiredLong_id.init(cx, "requiredLong") ||
      !atomsCache->requiredByteRecord_id.init(cx, "requiredByteRecord") ||
      !atomsCache->recordMember_id.init(cx, "recordMember") ||
      !atomsCache->prototype_id.init(cx, "prototype") ||
      !atomsCache->promiseSequence_id.init(cx, "promiseSequence") ||
      !atomsCache->promise_id.init(cx, "promise") ||
      !atomsCache->otherStr_id.init(cx, "otherStr") ||
      !atomsCache->otherEnum_id.init(cx, "otherEnum") ||
      !atomsCache->otherByteStr_id.init(cx, "otherByteStr") ||
      !atomsCache->objectOrLong_id.init(cx, "objectOrLong") ||
      !atomsCache->nullableUTF8StringRecordWithDefault_id.init(cx, "nullableUTF8StringRecordWithDefault") ||
      !atomsCache->nullableUSVStringRecordWithDefault_id.init(cx, "nullableUSVStringRecordWithDefault") ||
      !atomsCache->nullableRecordWithDefault_id.init(cx, "nullableRecordWithDefault") ||
      !atomsCache->nullableRecord_id.init(cx, "nullableRecord") ||
      !atomsCache->nullableFloatOrString_id.init(cx, "nullableFloatOrString") ||
      !atomsCache->nullableByteStringRecordWithDefault_id.init(cx, "nullableByteStringRecordWithDefault") ||
      !atomsCache->nullableArrayBuffer_id.init(cx, "nullableArrayBuffer") ||
      !atomsCache->negativeInfUrFloat_id.init(cx, "negativeInfUrFloat") ||
      !atomsCache->negativeInfUrDouble_id.init(cx, "negativeInfUrDouble") ||
      !atomsCache->nanUrFloat_id.init(cx, "nanUrFloat") ||
      !atomsCache->nanUrDouble_id.init(cx, "nanUrDouble") ||
      !atomsCache->infUrFloat_id.init(cx, "infUrFloat") ||
      !atomsCache->infUrDouble_id.init(cx, "infUrDouble") ||
      !atomsCache->floatOrString_id.init(cx, "floatOrString") ||
      !atomsCache->float64Array_id.init(cx, "float64Array") ||
      !atomsCache->enforcedUnsignedLong_id.init(cx, "enforcedUnsignedLong") ||
      !atomsCache->emptyByteStr_id.init(cx, "emptyByteStr") ||
      !atomsCache->empty_id.init(cx, "empty") ||
      !atomsCache->dictionaryTypedef_id.init(cx, "dictionaryTypedef") ||
      !atomsCache->dashed_name_id.init(cx, "dashed-name") ||
      !atomsCache->customEventInit_id.init(cx, "customEventInit") ||
      !atomsCache->clampedUnsignedLong_id.init(cx, "clampedUnsignedLong") ||
      !atomsCache->byteStringRecord_id.init(cx, "byteStringRecord") ||
      !atomsCache->byteStr_id.init(cx, "byteStr") ||
      !atomsCache->b_id.init(cx, "b") ||
      !atomsCache->arrayBuffer_id.init(cx, "arrayBuffer") ||
      !atomsCache->anotherObj_id.init(cx, "anotherObj") ||
      !atomsCache->anotherAny_id.init(cx, "anotherAny") ||
      !atomsCache->a_id.init(cx, "a")) {
    return false;
  }
  return true;
}

bool
Dict::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  DictAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<DictAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  // Per spec, we init the parent's members first
  if (!ParentDict::Init(cx, val)) {
    return false;
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->a_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mA.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'a' member of Dict", &(mA.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->anotherAny_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'anotherAny' member of Dict");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    mAnotherAny = temp.ref();
  } else {
    mAnotherAny = JS::NullValue();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->anotherObj_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'anotherObj' member of Dict");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      mAnotherObj = &temp.ref().toObject();
    } else if (temp.ref().isNullOrUndefined()) {
      mAnotherObj = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'anotherObj' member of Dict");
      return false;
    }
  } else {
    mAnotherObj = nullptr;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->arrayBuffer_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mArrayBuffer.Construct();
    if (temp.ref().isObject()) {
      if (!(mArrayBuffer.Value()).Init(&temp.ref().toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'arrayBuffer' member of Dict", "ArrayBuffer");
        return false;
      }
      if (JS::IsSharedArrayBufferObject((mArrayBuffer.Value()).Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("'arrayBuffer' member of Dict");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared((mArrayBuffer.Value()).Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("'arrayBuffer' member of Dict");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'arrayBuffer' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->b_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'b' member of Dict", &mB)) {
      return false;
    }
  } else {
    mB = 8;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->byteStr_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mByteStr.Construct();
    if (!ConvertJSValueToByteString(cx, temp.ref(), false, "'byteStr' member of Dict", (mByteStr.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->byteStringRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mByteStringRecord.Construct();
    if (temp.ref().isObject()) {
      auto& recordEntries = (mByteStringRecord.Value()).Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToByteString(cx, idVal, "key of 'byteStringRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'byteStringRecord' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'byteStringRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->clampedUnsignedLong_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mClampedUnsignedLong.Construct();
    if (!ValueToPrimitive<uint32_t, eClamp>(cx, temp.ref(), "'clampedUnsignedLong' member of Dict", &(mClampedUnsignedLong.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->customEventInit_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mCustomEventInit.Construct();
    if (!(mCustomEventInit.Value()).Init(cx, temp.ref(), "'customEventInit' member of Dict", passedToJSImpl)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->dashed_name_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mDashed_name.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'dashed-name' member of Dict", &(mDashed_name.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->dictionaryTypedef_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mDictionaryTypedef.Construct();
    if (!(mDictionaryTypedef.Value()).Init(cx, temp.ref(), "'dictionaryTypedef' member of Dict", passedToJSImpl)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->empty_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mEmpty)) {
      return false;
    }
  } else {
    mEmpty.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->emptyByteStr_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToByteString(cx, temp.ref(), false, "'emptyByteStr' member of Dict", mEmptyByteStr)) {
      return false;
    }
  } else {
    mEmptyByteStr.AssignLiteral("");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->enforcedUnsignedLong_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mEnforcedUnsignedLong.Construct();
    if (!ValueToPrimitive<uint32_t, eEnforceRange>(cx, temp.ref(), "'enforcedUnsignedLong' member of Dict", &(mEnforcedUnsignedLong.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->float64Array_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      if (!mFloat64Array.SetValue().Init(&temp.ref().toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'float64Array' member of Dict", "Float64ArrayOrNull");
        return false;
      }
      if (JS::IsArrayBufferViewShared(mFloat64Array.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("'float64Array' member of Dict");
        return false;
      }
      if (JS::IsLargeArrayBufferView(mFloat64Array.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("'float64Array' member of Dict");
        return false;
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mFloat64Array.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'float64Array' member of Dict");
      return false;
    }
  } else {
    mFloat64Array.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->floatOrString_id, temp.ptr())) {
      return false;
    }
  }
  mFloatOrString.Uninit();
  if (!(!isNull && !temp->isUndefined())) {
    mFloatOrString.SetStringLiteral(u"str");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (temp.ref().isNumber()) {
          done = (failed = !mFloatOrString.TrySetToFloat(cx, temp.ref(), tryNext)) || !tryNext;
          break;
        }
        done = (failed = !mFloatOrString.TrySetToString(cx, temp.ref(), tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'floatOrString' member of Dict", "");
        return false;
      }
    }
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->infUrDouble_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'infUrDouble' member of Dict", &mInfUrDouble)) {
      return false;
    }
  } else {
    mInfUrDouble = mozilla::PositiveInfinity<double>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->infUrFloat_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'infUrFloat' member of Dict", &mInfUrFloat)) {
      return false;
    }
  } else {
    mInfUrFloat = mozilla::PositiveInfinity<float>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nanUrDouble_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'nanUrDouble' member of Dict", &mNanUrDouble)) {
      return false;
    }
  } else {
    mNanUrDouble = mozilla::UnspecifiedNaN<double>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nanUrFloat_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'nanUrFloat' member of Dict", &mNanUrFloat)) {
      return false;
    }
  } else {
    mNanUrFloat = mozilla::UnspecifiedNaN<float>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->negativeInfUrDouble_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'negativeInfUrDouble' member of Dict", &mNegativeInfUrDouble)) {
      return false;
    }
  } else {
    mNegativeInfUrDouble = mozilla::NegativeInfinity<double>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->negativeInfUrFloat_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'negativeInfUrFloat' member of Dict", &mNegativeInfUrFloat)) {
      return false;
    }
  } else {
    mNegativeInfUrFloat = mozilla::NegativeInfinity<float>();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableArrayBuffer_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mNullableArrayBuffer.Construct();
    if (temp.ref().isObject()) {
      if (!(mNullableArrayBuffer.Value()).SetValue().Init(&temp.ref().toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'nullableArrayBuffer' member of Dict", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject((mNullableArrayBuffer.Value()).SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("'nullableArrayBuffer' member of Dict");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared((mNullableArrayBuffer.Value()).SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("'nullableArrayBuffer' member of Dict");
        return false;
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mNullableArrayBuffer.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableArrayBuffer' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableByteStringRecordWithDefault_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mNullableByteStringRecordWithDefault.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToByteString(cx, idVal, "key of 'nullableByteStringRecordWithDefault' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'nullableByteStringRecordWithDefault' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mNullableByteStringRecordWithDefault.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableByteStringRecordWithDefault' member of Dict");
      return false;
    }
  } else {
    mNullableByteStringRecordWithDefault.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableFloatOrString_id, temp.ptr())) {
      return false;
    }
  }
  if (!mNullableFloatOrString.IsNull()) {
    mNullableFloatOrString.Value().Uninit();
  }
  if ((!isNull && !temp->isUndefined()) && temp.ref().isNullOrUndefined()) {
    mNullableFloatOrString.SetNull();
  } else {
    if (!(!isNull && !temp->isUndefined())) {
      mNullableFloatOrString.SetValue().SetStringLiteral(u"str");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (temp.ref().isNumber()) {
            done = (failed = !mNullableFloatOrString.SetValue().TrySetToFloat(cx, temp.ref(), tryNext)) || !tryNext;
            break;
          }
          done = (failed = !mNullableFloatOrString.SetValue().TrySetToString(cx, temp.ref(), tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'nullableFloatOrString' member of Dict", "");
          return false;
        }
      }
    }
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mNullableRecord.Construct();
    if (temp.ref().isObject()) {
      auto& recordEntries = (mNullableRecord.Value()).SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'nullableRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'nullableRecord' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mNullableRecord.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableRecordWithDefault_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mNullableRecordWithDefault.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'nullableRecordWithDefault' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, nsString>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        nsString& slot = entry->mValue;
        if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mNullableRecordWithDefault.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableRecordWithDefault' member of Dict");
      return false;
    }
  } else {
    mNullableRecordWithDefault.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableUSVStringRecordWithDefault_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mNullableUSVStringRecordWithDefault.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToUSVString(cx, idVal, "key of 'nullableUSVStringRecordWithDefault' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'nullableUSVStringRecordWithDefault' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mNullableUSVStringRecordWithDefault.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableUSVStringRecordWithDefault' member of Dict");
      return false;
    }
  } else {
    mNullableUSVStringRecordWithDefault.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->nullableUTF8StringRecordWithDefault_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mNullableUTF8StringRecordWithDefault.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'nullableUTF8StringRecordWithDefault' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'nullableUTF8StringRecordWithDefault' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mNullableUTF8StringRecordWithDefault.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'nullableUTF8StringRecordWithDefault' member of Dict");
      return false;
    }
  } else {
    mNullableUTF8StringRecordWithDefault.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->objectOrLong_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mObjectOrLong.Construct();
    {
      bool done = false, failed = false, tryNext;
      if (temp.ref().isObject()) {
        if (!(mObjectOrLong.Value()).SetToObject(cx, &temp.ref().toObject(), passedToJSImpl)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !(mObjectOrLong.Value()).TrySetToLong(cx, temp.ref(), tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'objectOrLong' member of Dict", "object");
        return false;
      }
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->otherByteStr_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToByteString(cx, temp.ref(), false, "'otherByteStr' member of Dict", mOtherByteStr)) {
      return false;
    }
  } else {
    mOtherByteStr.AssignLiteral("def");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->otherEnum_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), TestEnumValues::strings, "TestEnum", "'otherEnum' member of Dict", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mOtherEnum = static_cast<TestEnum>(index);
    }
  } else {
    mOtherEnum = TestEnum::B;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->otherStr_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mOtherStr)) {
      return false;
    }
  } else {
    mOtherStr.AssignLiteral(u"def");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->promise_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPromise.Construct();
    { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
      // etc.

      JS::Rooted<JSObject*> globalObj(cx);
      globalObj = JS::CurrentGlobalOrNull(cx);
      JSAutoRealm ar(cx, globalObj);
      GlobalObject promiseGlobal(cx, globalObj);
      if (promiseGlobal.Failed()) {
        return false;
      }

      JS::Rooted<JS::Value> valueToResolve(cx, temp.ref());
      if (!JS_WrapValue(cx, &valueToResolve)) {
        return false;
      }
      binding_detail::FastErrorResult promiseRv;
      nsCOMPtr<nsIGlobalObject> global =
        do_QueryInterface(promiseGlobal.GetAsSupports());
      if (!global) {
        promiseRv.Throw(NS_ERROR_UNEXPECTED);
        MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
        return false;
      }
      (mPromise.Value()) = Promise::Resolve(global, cx, valueToResolve,
                                      promiseRv);
      if (promiseRv.MaybeSetPendingException(cx)) {
        return false;
      }
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->promiseSequence_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPromiseSequence.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'promiseSequence' member of Dict");
        return false;
      }
      Sequence<OwningNonNull<Promise>> &arr = (mPromiseSequence.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningNonNull<Promise>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningNonNull<Promise>& slot = *slotPtr;
        { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
          // etc.

          JS::Rooted<JSObject*> globalObj(cx);
          globalObj = JS::CurrentGlobalOrNull(cx);
          JSAutoRealm ar(cx, globalObj);
          GlobalObject promiseGlobal(cx, globalObj);
          if (promiseGlobal.Failed()) {
            return false;
          }

          JS::Rooted<JS::Value> valueToResolve(cx, temp);
          if (!JS_WrapValue(cx, &valueToResolve)) {
            return false;
          }
          binding_detail::FastErrorResult promiseRv;
          nsCOMPtr<nsIGlobalObject> global =
            do_QueryInterface(promiseGlobal.GetAsSupports());
          if (!global) {
            promiseRv.Throw(NS_ERROR_UNEXPECTED);
            MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
            return false;
          }
          slot = Promise::Resolve(global, cx, valueToResolve,
                                          promiseRv);
          if (promiseRv.MaybeSetPendingException(cx)) {
            return false;
          }
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'promiseSequence' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->prototype_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPrototype.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'prototype' member of Dict", &(mPrototype.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->recordMember_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mRecordMember.Construct();
    if (temp.ref().isObject()) {
      auto& recordEntries = (mRecordMember.Value()).Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'recordMember' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'recordMember' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'recordMember' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredByteRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mRequiredByteRecord.Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToByteString(cx, idVal, "key of 'requiredByteRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in 'requiredByteRecord' member of Dict", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in 'requiredByteRecord' member of Dict");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'requiredByteRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredByteRecord' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredLong_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'requiredLong' member of Dict", &mRequiredLong)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredLong' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredObject_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'requiredObject' member of Dict");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      mRequiredObject = &temp.ref().toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'requiredObject' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredObject' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mRequiredRecord.Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'requiredRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in 'requiredRecord' member of Dict", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in 'requiredRecord' member of Dict");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'requiredRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredRecord' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredUSVRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mRequiredUSVRecord.Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToUSVString(cx, idVal, "key of 'requiredUSVRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in 'requiredUSVRecord' member of Dict", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in 'requiredUSVRecord' member of Dict");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'requiredUSVRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredUSVRecord' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->requiredUTF8Record_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      auto& recordEntries = mRequiredUTF8Record.Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'requiredUTF8Record' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in 'requiredUTF8Record' member of Dict", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in 'requiredUTF8Record' member of Dict");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'requiredUTF8Record' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'requiredUTF8Record' member of Dict");
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq1_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq1.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq1' member of Dict");
        return false;
      }
      Sequence<int32_t> &arr = (mSeq1.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'seq1' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq1' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq2' member of Dict");
        return false;
      }
      Sequence<int32_t> &arr = mSeq2;
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'seq2' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq2' member of Dict");
      return false;
    }
  } else {
    /* mSeq2 array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq3_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq3.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq3' member of Dict");
        return false;
      }
      Sequence<int32_t> &arr = (mSeq3.Value()).SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'seq3' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mSeq3.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq3' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq4_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq4' member of Dict");
        return false;
      }
      Sequence<int32_t> &arr = mSeq4.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'seq4' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mSeq4.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq4' member of Dict");
      return false;
    }
  } else {
    mSeq4.SetNull();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq5_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq5' member of Dict");
        return false;
      }
      Sequence<int32_t> &arr = mSeq5.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of 'seq5' member of Dict", &slot)) {
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mSeq5.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq5' member of Dict");
      return false;
    }
  } else {
    mSeq5.SetValue();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someAny_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'someAny' member of Dict");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    mSomeAny = temp.ref();
  } else {
    mSomeAny = JS::UndefinedValue();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someCallback_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      if (JS::IsCallable(&temp.ref().toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &temp.ref().toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        mSomeCallback = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("'someCallback' member of Dict");
        return false;
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mSomeCallback = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'someCallback' member of Dict");
      return false;
    }
  } else {
    mSomeCallback = nullptr;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someEnum_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSomeEnum.Construct();
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), TestEnumValues::strings, "TestEnum", "'someEnum' member of Dict", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      (mSomeEnum.Value()) = static_cast<TestEnum>(index);
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->someObj_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSomeObj.Construct();
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'someObj' member of Dict");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      (mSomeObj.Value()) = &temp.ref().toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'someObj' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->str_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mStr.Construct();
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, (mStr.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->template_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mTemplate.Construct();
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, (mTemplate.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->uint8Array_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mUint8Array.Construct();
    if (temp.ref().isObject()) {
      if (!(mUint8Array.Value()).Init(&temp.ref().toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'uint8Array' member of Dict", "Uint8Array");
        return false;
      }
      if (JS::IsArrayBufferViewShared((mUint8Array.Value()).Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("'uint8Array' member of Dict");
        return false;
      }
      if (JS::IsLargeArrayBufferView((mUint8Array.Value()).Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("'uint8Array' member of Dict");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'uint8Array' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urDouble_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'urDouble' member of Dict", &mUrDouble)) {
      return false;
    }
  } else {
    mUrDouble = 0.0;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urDouble2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'urDouble2' member of Dict", &mUrDouble2)) {
      return false;
    }
  } else {
    mUrDouble2 = 1.1;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urDouble3_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'urDouble3' member of Dict", &mUrDouble3)) {
      return false;
    }
  } else {
    mUrDouble3 = -1.1;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urDouble4_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mUrDouble4.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'urDouble4' member of Dict", &mUrDouble4.SetValue())) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urFloat_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'urFloat' member of Dict", &mUrFloat)) {
      return false;
    }
  } else {
    mUrFloat = 0.0F;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urFloat2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'urFloat2' member of Dict", &mUrFloat2)) {
      return false;
    }
  } else {
    mUrFloat2 = 1.1F;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urFloat3_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'urFloat3' member of Dict", &mUrFloat3)) {
      return false;
    }
  } else {
    mUrFloat3 = -1.1F;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->urFloat4_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mUrFloat4.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, temp.ref(), "'urFloat4' member of Dict", &mUrFloat4.SetValue())) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->usvStringRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mUsvStringRecord.Construct();
    if (temp.ref().isObject()) {
      auto& recordEntries = (mUsvStringRecord.Value()).Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToUSVString(cx, idVal, "key of 'usvStringRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'usvStringRecord' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'usvStringRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->utf8StringRecord_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mUtf8StringRecord.Construct();
    if (temp.ref().isObject()) {
      auto& recordEntries = (mUtf8StringRecord.Value()).Entries();

      JS::Rooted<JSObject*> recordObj(cx, &temp.ref().toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsCStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsCString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of 'utf8StringRecord' member of Dict", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsCString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in 'utf8StringRecord' member of Dict", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'utf8StringRecord' member of Dict");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->x_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mX.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'x' member of Dict", &(mX.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->yetAnotherStr_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eNull, eNull, mYetAnotherStr)) {
      return false;
    }
  } else {
    mYetAnotherStr.SetIsVoid(true);
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->z_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), "'z' member of Dict", &mZ)) {
      return false;
    }
  } else {
    mZ = 9;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
Dict::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
Dict::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DictAtoms* atomsCache = GetAtomCache<DictAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  // Per spec, we define the parent's members first
  if (!ParentDict::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());

  if (mA.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mA.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->a_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JS::Value const & currentValue = mAnotherAny;
    JS::ExposeValueToActiveJS(currentValue);
    temp.set(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->anotherAny_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mAnotherObj;
    if (currentValue) {
                  JS::ExposeObjectToActiveJS(currentValue);
                }
                temp.setObjectOrNull(currentValue);
    if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->anotherObj_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mArrayBuffer.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      ArrayBuffer const & currentValue = mArrayBuffer.InternalValue();
      temp.setObject(*currentValue.Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->arrayBuffer_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mB;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->b_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mByteStr.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsCString const & currentValue = mByteStr.InternalValue();
      if (!NonVoidByteStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->byteStr_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mByteStringRecord.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Record<nsCString, int32_t> const & currentValue = mByteStringRecord.InternalValue();

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : currentValue.Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          NS_ConvertASCIItoUTF16 expandedKey(entry.mKey);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   expandedKey.BeginReading(),
                                   expandedKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnObj);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->byteStringRecord_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mClampedUnsignedLong.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint32_t const & currentValue = mClampedUnsignedLong.InternalValue();
      temp.setNumber(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->clampedUnsignedLong_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mCustomEventInit.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      CustomEventInit const & currentValue = mCustomEventInit.InternalValue();
      if (!currentValue.ToObjectInternal(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->customEventInit_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mDashed_name.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mDashed_name.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->dashed_name_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mDictionaryTypedef.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      CustomEventInit const & currentValue = mDictionaryTypedef.InternalValue();
      if (!currentValue.ToObjectInternal(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->dictionaryTypedef_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mEmpty;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->empty_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mEmptyByteStr;
    if (!NonVoidByteStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->emptyByteStr_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mEnforcedUnsignedLong.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint32_t const & currentValue = mEnforcedUnsignedLong.InternalValue();
      temp.setNumber(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->enforcedUnsignedLong_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Float64Array> const & currentValue = mFloat64Array;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->float64Array_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.setObject(*currentValue.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->float64Array_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    OwningFloatOrString const & currentValue = mFloatOrString;
    if (!currentValue.ToJSVal(cx, obj, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->floatOrString_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mInfUrDouble;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->infUrDouble_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mInfUrFloat;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->infUrFloat_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mNanUrDouble;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nanUrDouble_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mNanUrFloat;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nanUrFloat_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mNegativeInfUrDouble;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->negativeInfUrDouble_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mNegativeInfUrFloat;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->negativeInfUrFloat_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mNullableArrayBuffer.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<ArrayBuffer> const & currentValue = mNullableArrayBuffer.InternalValue();
      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableArrayBuffer_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }
      temp.setObject(*currentValue.Value().Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableArrayBuffer_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Record<nsCString, int32_t>> const & currentValue = mNullableByteStringRecordWithDefault;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableByteStringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        NS_ConvertASCIItoUTF16 expandedKey(entry.mKey);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 expandedKey.BeginReading(),
                                 expandedKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableByteStringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<OwningFloatOrString > const & currentValue = mNullableFloatOrString;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableFloatOrString_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    if (!currentValue.Value().ToJSVal(cx, obj, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableFloatOrString_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mNullableRecord.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<Record<nsString, int32_t>> const & currentValue = mNullableRecord.InternalValue();

      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableRecord_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : currentValue.Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnObj);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableRecord_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Record<nsString, nsString>> const & currentValue = mNullableRecordWithDefault;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!xpc::NonVoidStringToJsval(cx, recordValue0, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Record<nsString, int32_t>> const & currentValue = mNullableUSVStringRecordWithDefault;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableUSVStringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableUSVStringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Record<nsCString, int32_t>> const & currentValue = mNullableUTF8StringRecordWithDefault;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableUTF8StringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        NS_ConvertUTF8toUTF16 expandedKey(entry.mKey);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 expandedKey.BeginReading(),
                                 expandedKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nullableUTF8StringRecordWithDefault_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mObjectOrLong.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      OwningObjectOrLong const & currentValue = mObjectOrLong.InternalValue();
      if (!currentValue.ToJSVal(cx, obj, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->objectOrLong_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mOtherByteStr;
    if (!NonVoidByteStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->otherByteStr_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    TestEnum const & currentValue = mOtherEnum;
    if (!ToJSValue(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->otherEnum_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mOtherStr;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->otherStr_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mPromise.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      OwningNonNull<Promise> const & currentValue = mPromise.InternalValue();
      if (!ToJSValue(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->promise_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mPromiseSequence.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<OwningNonNull<Promise>> const & currentValue = mPromiseSequence.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!ToJSValue(cx, currentValue[sequenceIdx0], &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->promiseSequence_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mPrototype.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mPrototype.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->prototype_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mRecordMember.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Record<nsString, int32_t> const & currentValue = mRecordMember.InternalValue();

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : currentValue.Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnObj);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->recordMember_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>> const & currentValue = mRequiredByteRecord;

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          break;
        } while (false);
        NS_ConvertASCIItoUTF16 expandedKey(entry.mKey);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 expandedKey.BeginReading(),
                                 expandedKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredByteRecord_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mRequiredLong;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredLong_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mRequiredObject;
    JS::ExposeObjectToActiveJS(currentValue);
    temp.setObject(*currentValue);
    if (!MaybeWrapObjectValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredObject_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> const & currentValue = mRequiredRecord;

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredRecord_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> const & currentValue = mRequiredUSVRecord;

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredUSVRecord_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>> const & currentValue = mRequiredUTF8Record;

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : currentValue.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          break;
        } while (false);
        NS_ConvertUTF8toUTF16 expandedKey(entry.mKey);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 expandedKey.BeginReading(),
                                 expandedKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnObj);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->requiredUTF8Record_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mSeq1.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<int32_t> const & currentValue = mSeq1.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(currentValue[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq1_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<int32_t> const & currentValue = mSeq2;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(currentValue[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->seq2_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mSeq3.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<Sequence<int32_t>> const & currentValue = mSeq3.InternalValue();

      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->seq3_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }

      uint32_t length = currentValue.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(currentValue.Value()[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq3_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Sequence<int32_t>> const & currentValue = mSeq4;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq4_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    uint32_t length = currentValue.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(currentValue.Value()[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->seq4_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<Sequence<int32_t>> const & currentValue = mSeq5;

    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq5_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }

    uint32_t length = currentValue.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(currentValue.Value()[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->seq5_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JS::Value const & currentValue = mSomeAny;
    JS::ExposeValueToActiveJS(currentValue);
    temp.set(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->someAny_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    RefPtr<TestCallback> const & currentValue = mSomeCallback;
    if (currentValue) {
      temp.setObjectOrNull(GetCallbackFromCallbackObject(cx, currentValue));
      if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someCallback_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } else {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someCallback_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
  } while(false);

  if (mSomeEnum.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      TestEnum const & currentValue = mSomeEnum.InternalValue();
      if (!ToJSValue(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someEnum_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSomeObj.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      JSObject* const & currentValue = mSomeObj.InternalValue();
      JS::ExposeObjectToActiveJS(currentValue);
      temp.setObject(*currentValue);
      if (!MaybeWrapObjectValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->someObj_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mStr.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mStr.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->str_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mTemplate.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mTemplate.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->template_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mUint8Array.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Uint8Array const & currentValue = mUint8Array.InternalValue();
      temp.setObject(*currentValue.Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->uint8Array_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mUrDouble;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urDouble_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mUrDouble2;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urDouble2_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mUrDouble3;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urDouble3_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<double> const & currentValue = mUrDouble4;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->urDouble4_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.set(JS_NumberValue(double(currentValue.Value())));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urDouble4_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mUrFloat;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urFloat_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mUrFloat2;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urFloat2_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    float const & currentValue = mUrFloat3;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urFloat3_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<float> const & currentValue = mUrFloat4;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->urFloat4_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.set(JS_NumberValue(double(currentValue.Value())));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->urFloat4_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mUsvStringRecord.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Record<nsString, int32_t> const & currentValue = mUsvStringRecord.InternalValue();

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : currentValue.Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnObj);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->usvStringRecord_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mUtf8StringRecord.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Record<nsCString, int32_t> const & currentValue = mUtf8StringRecord.InternalValue();

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : currentValue.Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          NS_ConvertUTF8toUTF16 expandedKey(entry.mKey);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   expandedKey.BeginReading(),
                                   expandedKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnObj);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->utf8StringRecord_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mX.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mX.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->x_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mYetAnotherStr;
    if (!xpc::StringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->yetAnotherStr_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mZ;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->z_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
Dict::TraceDictionary(JSTracer* trc)
{
  ParentDict::TraceDictionary(trc);
  JS::UnsafeTraceRoot(trc, &mAnotherAny, "Dict.mAnotherAny");

  if (mAnotherObj) {
    JS::UnsafeTraceRoot(trc, &mAnotherObj, "Dict.mAnotherObj");
  }

  if (mArrayBuffer.WasPassed()) {
    mArrayBuffer.Value().TraceSelf(trc);
  }

  if (mCustomEventInit.WasPassed()) {
    mCustomEventInit.Value().TraceDictionary(trc);
  }

  if (mDictionaryTypedef.WasPassed()) {
    mDictionaryTypedef.Value().TraceDictionary(trc);
  }

  if (!mFloat64Array.IsNull()) {
    mFloat64Array.Value().TraceSelf(trc);
  }

  if (mNullableArrayBuffer.WasPassed()) {
    if (!mNullableArrayBuffer.Value().IsNull()) {
      mNullableArrayBuffer.Value().Value().TraceSelf(trc);
    }
  }

  if (mObjectOrLong.WasPassed()) {
    mObjectOrLong.Value().TraceUnion(trc);
  }

  JS::UnsafeTraceRoot(trc, &mRequiredObject, "Dict.mRequiredObject");

  JS::UnsafeTraceRoot(trc, &mSomeAny, "Dict.mSomeAny");

  if (mSomeObj.WasPassed()) {
    JS::UnsafeTraceRoot(trc, &mSomeObj.Value(), "Dict.mSomeObj");
  }

  if (mUint8Array.WasPassed()) {
    mUint8Array.Value().TraceSelf(trc);
  }
}

namespace binding_detail {
} // namespace binding_detail



DictContainingDict::DictContainingDict()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
DictContainingDict::InitIds(JSContext* cx, DictContainingDictAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->memberDict_id.init(cx, "memberDict")) {
    return false;
  }
  return true;
}

bool
DictContainingDict::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  DictContainingDictAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<DictContainingDictAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->memberDict_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMemberDict.Construct();
    if (!(mMemberDict.Value()).Init(cx, temp.ref(), "'memberDict' member of DictContainingDict", passedToJSImpl)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
DictContainingDict::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
DictContainingDict::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DictContainingDictAtoms* atomsCache = GetAtomCache<DictContainingDictAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mMemberDict.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Dict const & currentValue = mMemberDict.InternalValue();
      if (!currentValue.ToObjectInternal(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->memberDict_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
DictContainingDict::TraceDictionary(JSTracer* trc)
{
  if (mMemberDict.WasPassed()) {
    mMemberDict.Value().TraceDictionary(trc);
  }
}



namespace binding_detail {
} // namespace binding_detail



DictForConstructor::DictForConstructor()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
DictForConstructor::InitIds(JSContext* cx, DictForConstructorAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->seq6_id.init(cx, "seq6") ||
      !atomsCache->seq5_id.init(cx, "seq5") ||
      !atomsCache->seq4_id.init(cx, "seq4") ||
      !atomsCache->seq3_id.init(cx, "seq3") ||
      !atomsCache->seq2_id.init(cx, "seq2") ||
      !atomsCache->seq1_id.init(cx, "seq1") ||
      !atomsCache->obj2_id.init(cx, "obj2") ||
      !atomsCache->obj1_id.init(cx, "obj1") ||
      !atomsCache->dict2_id.init(cx, "dict2") ||
      !atomsCache->dict_id.init(cx, "dict") ||
      !atomsCache->any1_id.init(cx, "any1")) {
    return false;
  }
  return true;
}

bool
DictForConstructor::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  DictForConstructorAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<DictForConstructorAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->any1_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'any1' member of DictForConstructor");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    mAny1 = temp.ref();
  } else {
    mAny1 = JS::NullValue();
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->dict_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mDict.Construct();
    if (!(mDict.Value()).Init(cx, temp.ref(), "'dict' member of DictForConstructor", passedToJSImpl)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->dict2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mDict2.Construct();
    if (!(mDict2.Value()).Init(cx, temp.ref(), "'dict2' member of DictForConstructor", passedToJSImpl)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->obj1_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mObj1.Construct();
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'obj1' member of DictForConstructor");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      (mObj1.Value()) = &temp.ref().toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'obj1' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->obj2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mObj2.Construct();
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'obj2' member of DictForConstructor");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      (mObj2.Value()) = &temp.ref().toObject();
    } else if (temp.ref().isNullOrUndefined()) {
      (mObj2.Value()) = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'obj2' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq1_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq1.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq1' member of DictForConstructor");
        return false;
      }
      Sequence<Dict> &arr = (mSeq1.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Dict* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Dict& slot = *slotPtr;
        if (!slot.Init(cx, temp, "Element of 'seq1' member of DictForConstructor", passedToJSImpl)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq1' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq2_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq2.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq2' member of DictForConstructor");
        return false;
      }
      Sequence<Sequence<Dict>> &arr = (mSeq2.Value()).SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Sequence<Dict>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Sequence<Dict>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of 'seq2' member of DictForConstructor");
            return false;
          }
          Sequence<Dict> &arr1 = slot;
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            Dict* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            Dict& slot1 = *slotPtr1;
            if (!slot1.Init(cx, temp1, "Element of element of 'seq2' member of DictForConstructor", passedToJSImpl)) {
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of 'seq2' member of DictForConstructor");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      (mSeq2.Value()).SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq2' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq3_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq3.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq3' member of DictForConstructor");
        return false;
      }
      Sequence<Nullable<Sequence<Dict>>> &arr = (mSeq3.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<Dict>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<Dict>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of 'seq3' member of DictForConstructor");
            return false;
          }
          Sequence<Dict> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            Dict* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            Dict& slot1 = *slotPtr1;
            if (!slot1.Init(cx, temp1, "Element of element of 'seq3' member of DictForConstructor", passedToJSImpl)) {
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of 'seq3' member of DictForConstructor");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq3' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq4_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq4.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq4' member of DictForConstructor");
        return false;
      }
      Sequence<JS::Value> &arr = (mSeq4.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((passedToJSImpl) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'seq4' member of DictForConstructor");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq4' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq5_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq5.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq5' member of DictForConstructor");
        return false;
      }
      Sequence<JS::Value> &arr = (mSeq5.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((passedToJSImpl) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'seq5' member of DictForConstructor");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq5' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->seq6_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mSeq6.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq6' member of DictForConstructor");
        return false;
      }
      Sequence<DictContainingSequence> &arr = (mSeq6.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        DictContainingSequence* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        DictContainingSequence& slot = *slotPtr;
        if (!slot.Init(cx, temp, "Element of 'seq6' member of DictForConstructor", passedToJSImpl)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'seq6' member of DictForConstructor");
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
DictForConstructor::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
DictForConstructor::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DictForConstructorAtoms* atomsCache = GetAtomCache<DictForConstructorAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JS::Value const & currentValue = mAny1;
    JS::ExposeValueToActiveJS(currentValue);
    temp.set(currentValue);
    if (!MaybeWrapValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->any1_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mDict.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Dict const & currentValue = mDict.InternalValue();
      if (!currentValue.ToObjectInternal(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->dict_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mDict2.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      DictContainingDict const & currentValue = mDict2.InternalValue();
      if (!currentValue.ToObjectInternal(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->dict2_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mObj1.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      JSObject* const & currentValue = mObj1.InternalValue();
      JS::ExposeObjectToActiveJS(currentValue);
      temp.setObject(*currentValue);
      if (!MaybeWrapObjectValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->obj1_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mObj2.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      JSObject* const & currentValue = mObj2.InternalValue();
      if (currentValue) {
                    JS::ExposeObjectToActiveJS(currentValue);
                  }
                  temp.setObjectOrNull(currentValue);
      if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->obj2_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq1.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<Dict> const & currentValue = mSeq1.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq1_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq2.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Nullable<Sequence<Sequence<Dict>>> const & currentValue = mSeq2.InternalValue();

      if (currentValue.IsNull()) {
        temp.setNull();
        if (!JS_DefinePropertyById(cx, obj, atomsCache->seq2_id, temp, JSPROP_ENUMERATE)) {
          return false;
        }
        break;
      }

      uint32_t length = currentValue.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            uint32_t length = currentValue.Value()[sequenceIdx0].Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              return false;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  if (!currentValue.Value()[sequenceIdx0][sequenceIdx1].ToObjectInternal(cx, &tmp)) {
                    return false;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                      JSPROP_ENUMERATE)) {
                  return false;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq2_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq3.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<Nullable<Sequence<Dict>>> const & currentValue = mSeq3.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            if (currentValue[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }

            uint32_t length = currentValue[sequenceIdx0].Value().Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              return false;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  if (!currentValue[sequenceIdx0].Value()[sequenceIdx1].ToObjectInternal(cx, &tmp)) {
                    return false;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                      JSPROP_ENUMERATE)) {
                  return false;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq3_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq4.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<JS::Value> const & currentValue = mSeq4.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeValueToActiveJS(currentValue[sequenceIdx0]);
            tmp.set(currentValue[sequenceIdx0]);
            if (!MaybeWrapValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq4_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq5.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<JS::Value> const & currentValue = mSeq5.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeValueToActiveJS(currentValue[sequenceIdx0]);
            tmp.set(currentValue[sequenceIdx0]);
            if (!MaybeWrapValue(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq5_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSeq6.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<DictContainingSequence> const & currentValue = mSeq6.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->seq6_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
DictForConstructor::TraceDictionary(JSTracer* trc)
{
  JS::UnsafeTraceRoot(trc, &mAny1, "DictForConstructor.mAny1");

  if (mDict.WasPassed()) {
    mDict.Value().TraceDictionary(trc);
  }

  if (mDict2.WasPassed()) {
    mDict2.Value().TraceDictionary(trc);
  }

  if (mObj1.WasPassed()) {
    JS::UnsafeTraceRoot(trc, &mObj1.Value(), "DictForConstructor.mObj1");
  }

  if (mObj2.WasPassed()) {
    if (mObj2.Value()) {
      JS::UnsafeTraceRoot(trc, &mObj2.Value(), "DictForConstructor.mObj2");
    }
  }

  if (mSeq1.WasPassed()) {
    DoTraceSequence(trc, mSeq1.Value());
  }

  if (mSeq2.WasPassed()) {
    if (!mSeq2.Value().IsNull()) {
      DoTraceSequence(trc, mSeq2.Value().Value());
    }
  }

  if (mSeq3.WasPassed()) {
    DoTraceSequence(trc, mSeq3.Value());
  }

  if (mSeq4.WasPassed()) {
    DoTraceSequence(trc, mSeq4.Value());
  }

  if (mSeq5.WasPassed()) {
    DoTraceSequence(trc, mSeq5.Value());
  }

  if (mSeq6.WasPassed()) {
    DoTraceSequence(trc, mSeq6.Value());
  }
}



namespace binding_detail {
} // namespace binding_detail


MOZ_CAN_RUN_SCRIPT void
TestCallback::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT void
TestTreatAsNullCallback::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT int32_t
TestIntegerReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestIntegerReturn", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT Nullable<int32_t>
TestNullableIntegerReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return Nullable<int32_t>();
  }
  Nullable<int32_t> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestNullableIntegerReturn", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int32_t>();
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT bool
TestBooleanReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestBooleanReturn", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT float
TestFloatReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return float(0);
  }
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestFloatReturn", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  } else if (!mozilla::IsFinite(rvalDecl)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestFloatReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT void
TestStringReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int32_t arg, nsString& aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  binding_detail::FakeString<char16_t> rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eStringify, eStringify, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}



MOZ_CAN_RUN_SCRIPT TestEnum
TestEnumReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return TestEnum(0);
  }
  TestEnum rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, TestEnumValues::strings, "TestEnum", "return value of TestEnumReturn", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return TestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<TestEnum>(index);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface>
TestInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestInterfaceReturn", "TestInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface>
TestNullableInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestNullableInterfaceReturn", "TestInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface>
TestExternalInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestExternalInterfaceReturn", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestExternalInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface>
TestNullableExternalInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestNullableExternalInterfaceReturn", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableExternalInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface>
TestCallbackInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestCallbackInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface>
TestNullableCallbackInterfaceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableCallbackInterfaceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback>
TestCallbackReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS::IsCallable(&rval.toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Return value of TestCallbackReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestCallbackReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback>
TestNullableCallbackReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS::IsCallable(&rval.toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Return value of TestNullableCallbackReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableCallbackReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT void
TestObjectReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSObject*> rvalDecl(cx);
  if (rval.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((false) && !CallerSubsumes(rval)) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestObjectReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    rvalDecl = &rval.toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestObjectReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}



MOZ_CAN_RUN_SCRIPT void
TestNullableObjectReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSObject*> rvalDecl(cx);
  if (rval.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((false) && !CallerSubsumes(rval)) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestNullableObjectReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    rvalDecl = &rval.toObject();
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableObjectReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}



MOZ_CAN_RUN_SCRIPT void
TestTypedArrayReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestTypedArrayReturn", "ArrayBuffer");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsSharedArrayBufferObject(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestTypedArrayReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferMaybeShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestTypedArrayReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestTypedArrayReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}



MOZ_CAN_RUN_SCRIPT void
TestNullableTypedArrayReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.SetValue().Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestNullableTypedArrayReturn", "ArrayBufferOrNull");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsSharedArrayBufferObject(rvalDecl.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestNullableTypedArrayReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferMaybeShared(rvalDecl.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestNullableTypedArrayReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestNullableTypedArrayReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.IsNull() ? nullptr : rvalDecl.Value().Obj());
}



MOZ_CAN_RUN_SCRIPT void
TestSequenceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, nsTArray<bool>& aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<bool> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestSequenceReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<bool> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      bool* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      bool& slot = *slotPtr;
      if (!ValueToPrimitive<bool, eDefault>(cx, temp, "Element of return value of TestSequenceReturn", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestSequenceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}



MOZ_CAN_RUN_SCRIPT void
TestNullableSequenceReturn::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, Nullable<nsTArray<bool>>& aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<bool>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestNullableSequenceReturn");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<bool> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      bool* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      bool& slot = *slotPtr;
      if (!ValueToPrimitive<bool, eDefault>(cx, temp, "Element of return value of TestNullableSequenceReturn", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestNullableSequenceReturn");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}



MOZ_CAN_RUN_SCRIPT void
TestIntegerArguments::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(4)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 4;

  do {

    if (arg4.IsNull()) {
      argv[3].setNull();
      break;
    }

    uint32_t length = arg4.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg4.Value()[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.setInt32(int32_t(arg4.Value()[sequenceIdx0].Value()));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[3].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg3.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg3[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[2].setObject(*returnArray);
    break;
  } while (false);

  do {
    if (arg2.IsNull()) {
      argv[1].setNull();
      break;
    }
    argv[1].setInt32(int32_t(arg2.Value()));
    break;
  } while (false);

  do {
    argv[0].setInt32(int32_t(arg1));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<int32_t> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestIntegerArguments");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<int32_t> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestIntegerArguments", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestIntegerArguments");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}



MOZ_CAN_RUN_SCRIPT void
TestInterfaceArguments::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(12)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 12;

  do {

    if (arg12.IsNull()) {
      argv[11].setNull();
      break;
    }

    uint32_t length = arg12.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg12.Value()[sequenceIdx0]) {
            tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, arg12.Value()[sequenceIdx0]));
            if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } else {
            tmp.setNull();
            break;
          }
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[11].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg11.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, arg11[sequenceIdx0]));
          if (!MaybeWrapObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[10].setObject(*returnArray);
    break;
  } while (false);

  do {

    if (arg10.IsNull()) {
      argv[9].setNull();
      break;
    }

    uint32_t length = arg10.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg10.Value()[sequenceIdx0]) {
            tmp.setNull();
            break;
          }
          if (!WrapObject(cx, arg10.Value()[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[9].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg9.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapObject(cx, arg9[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[8].setObject(*returnArray);
    break;
  } while (false);

  do {

    if (arg8.IsNull()) {
      argv[7].setNull();
      break;
    }

    uint32_t length = arg8.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg8.Value()[sequenceIdx0]) {
            tmp.setNull();
            break;
          }
          if (!GetOrCreateDOMReflector(cx, arg8.Value()[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[7].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg7.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!GetOrCreateDOMReflector(cx, arg7[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[6].setObject(*returnArray);
    break;
  } while (false);

  do {
    if (arg6) {
      argv[5].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg6));
      if (!MaybeWrapObjectOrNullValue(cx, argv[5])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[5].setNull();
      break;
    }
  } while (false);

  do {
    argv[4].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg5));
    if (!MaybeWrapObjectValue(cx, argv[4])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!arg4) {
      argv[3].setNull();
      break;
    }
    if (!WrapObject(cx, arg4, argv[3])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!WrapObject(cx, arg3, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!arg2) {
      argv[1].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg2, argv[1])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!GetOrCreateDOMReflector(cx, arg1, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT void
TestStringEnumArguments::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(3)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 3;

  do {
    if (!ToJSValue(cx, myEnum, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    nsString mutableStr(nullString);
    if (!xpc::StringToJsval(cx, mutableStr, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    nsString mutableStr(myString);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT void
TestObjectArguments::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(4)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 4;

  do {
    if (buf2) {
                  JS::ExposeObjectToActiveJS(buf2);
                }
                argv[3].setObjectOrNull(buf2);
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, argv[3])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    JS::ExposeObjectToActiveJS(buf);
    argv[2].setObject(*buf);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (anotherObj) {
                  JS::ExposeObjectToActiveJS(anotherObj);
                }
                argv[1].setObjectOrNull(anotherObj);
    if (!MaybeWrapObjectOrNullValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    JS::ExposeObjectToActiveJS(anObj);
    argv[0].setObject(*anObj);
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT void
TestOptionalArguments::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(6)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 6;

  do {
    if (aLong.WasPassed()) {
      argv[5].setInt32(int32_t(aLong.Value()));
      break;
    } else if (argc == 6) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[5].setUndefined();
    }
  } while (false);

  do {
    if (anotherInterface.WasPassed()) {
      if (!GetOrCreateDOMReflector(cx, anotherInterface.Value(), argv[4])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 5) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[4].setUndefined();
    }
  } while (false);

  do {
    if (anInterface.WasPassed()) {
      if (!anInterface.Value()) {
        argv[3].setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, anInterface.Value(), argv[3])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 4) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[3].setUndefined();
    }
  } while (false);

  do {
    if (aSeq.WasPassed()) {

      uint32_t length = aSeq.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!GetOrCreateDOMReflector(cx, aSeq.Value()[sequenceIdx0], &tmp)) {
              MOZ_ASSERT(JS_IsExceptionPending(cx));
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[2].setObject(*returnArray);
      break;
    } else if (argc == 3) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[2].setUndefined();
    }
  } while (false);

  do {
    if (something.WasPassed()) {
      JS::ExposeObjectToActiveJS(something.Value());
      argv[1].setObject(*something.Value());
      if (!MaybeWrapObjectValue(cx, argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1].setUndefined();
    }
  } while (false);

  do {
    if (aString.WasPassed()) {
      nsString mutableStr(aString.Value());
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



MOZ_CAN_RUN_SCRIPT void
TestVoidConstruction::Construct(const CustomEventInit& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestVoidConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::subarray(argv, 0, argc), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  rval.setObject(*constructedObj);
}



MOZ_CAN_RUN_SCRIPT uint32_t
TestIntegerConstruction::Construct(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestIntegerConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return uint32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return uint32_t(0);
  }
  rval.setObject(*constructedObj);
  uint32_t rvalDecl;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, rval, "Return value of TestIntegerConstruction", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT bool
TestBooleanConstruction::Construct(JS::Handle<JS::Value> arg1, const Optional<JS::Handle<JS::Value>>& arg2, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestBooleanConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return bool(0);
  }
  unsigned argc = 2;

  do {
    if (arg2.WasPassed()) {
      JS::ExposeValueToActiveJS(arg2.Value());
      argv[1].set(arg2.Value());
      if (!MaybeWrapValue(cx, argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return bool(0);
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1].setUndefined();
    }
  } while (false);

  do {
    JS::ExposeValueToActiveJS(arg1);
    argv[0].set(arg1);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return bool(0);
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::subarray(argv, 0, argc), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return bool(0);
  }
  rval.setObject(*constructedObj);
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestBooleanConstruction", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT float
TestFloatConstruction::Construct(const Optional<JS::Handle<JSObject*>>& arg1, const Optional<CustomEventInit>& arg2, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestFloatConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return float(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return float(0);
  }
  unsigned argc = 2;

  do {
    if (arg2.WasPassed()) {
      if (!arg2.Value().ToObjectInternal(cx, argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return float(0);
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1].setUndefined();
    }
  } while (false);

  do {
    if (arg1.WasPassed()) {
      JS::ExposeObjectToActiveJS(arg1.Value());
      argv[0].setObject(*arg1.Value());
      if (!MaybeWrapObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return float(0);
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::subarray(argv, 0, argc), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return float(0);
  }
  rval.setObject(*constructedObj);
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestFloatConstruction", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT void
TestStringConstruction::Construct(const Nullable<int32_t>& arg, nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestStringConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::subarray(argv, 0, argc), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  rval.setObject(*constructedObj);
  binding_detail::FakeString<char16_t> rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eStringify, eStringify, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}



MOZ_CAN_RUN_SCRIPT TestEnum
TestEnumConstruction::Construct(const nsTArray<JS::Value>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestEnumConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return TestEnum(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return TestEnum(0);
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::ExposeValueToActiveJS(arg[idx]);
      argv[0 + idx].set(arg[idx]);
      if (!MaybeWrapValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return TestEnum(0);
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::subarray(argv, 0, argc), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return TestEnum(0);
  }
  rval.setObject(*constructedObj);
  TestEnum rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, TestEnumValues::strings, "TestEnum", "return value of TestEnumConstruction", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return TestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<TestEnum>(index);
  }
  return rvalDecl;
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface>
TestInterfaceConstruction::Construct(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestInterfaceConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  rval.setObject(*constructedObj);
  RefPtr<mozilla::dom::TestInterface> rvalDecl;
  static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
  {
    // Our JSContext should be in the right global to do unwrapping in.
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(rval, rvalDecl, cx);
    if (NS_FAILED(rv)) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestInterfaceConstruction", "TestInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface>
TestExternalInterfaceConstruction::Construct(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestExternalInterfaceConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  rval.setObject(*constructedObj);
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
  RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
  JS::Rooted<JSObject*> source(cx, &rval.toObject());
  if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
    cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestExternalInterfaceConstruction", "TestExternalInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  MOZ_ASSERT(rvalHolder);
  rvalDecl = rvalHolder;
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface>
TestCallbackInterfaceConstruction::Construct(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterfaceConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  rval.setObject(*constructedObj);
  RefPtr<TestCallbackInterface> rvalDecl;
  { // scope for tempRoot and tempGlobalRoot if needed
    JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
    JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
    rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback>
TestCallbackConstruction::Construct(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  rval.setObject(*constructedObj);
  RefPtr<TestCallback> rvalDecl;
  if (JS::IsCallable(&rval.toObject())) {
  { // scope for tempRoot and tempGlobalRoot if needed
    JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
    JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
    rvalDecl = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
  }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Return value of TestCallbackConstruction");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}



MOZ_CAN_RUN_SCRIPT void
TestObjectConstruction::Construct(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestObjectConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  rval.setObject(*constructedObj);
  JS::Rooted<JSObject*> rvalDecl(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((false) && !CallerSubsumes(rval)) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestObjectConstruction");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  rvalDecl = &rval.toObject();
  aRetVal.set(rvalDecl);
}



MOZ_CAN_RUN_SCRIPT void
TestTypedArrayConstruction::Construct(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestTypedArrayConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  rval.setObject(*constructedObj);
  RootedSpiderMonkeyInterface<ArrayBuffer> rvalDecl(cx);
  if (!rvalDecl.Init(&rval.toObject())) {
    cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestTypedArrayConstruction", "ArrayBuffer");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (JS::IsSharedArrayBufferObject(rvalDecl.Obj())) {
    cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestTypedArrayConstruction");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (JS::IsLargeArrayBufferMaybeShared(rvalDecl.Obj())) {
    cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestTypedArrayConstruction");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}



MOZ_CAN_RUN_SCRIPT void
TestSequenceConstruction::Construct(nsTArray<bool>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestSequenceConstruction", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> constructor(cx, JS::ObjectValue(*mCallback));
  JS::Rooted<JSObject*> constructedObj(cx);
  if (!JS::Construct(cx, constructor,
                JS::HandleValueArray::empty(), &constructedObj)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  rval.setObject(*constructedObj);
  Sequence<bool> rvalDecl;
  JS::ForOfIterator iter(cx);
  if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (!iter.valueIsIterable()) {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestSequenceConstruction");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  Sequence<bool> &arr = rvalDecl;
  JS::Rooted<JS::Value> temp(cx);
  while (true) {
    bool done;
    if (!iter.next(&temp, &done)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (done) {
      break;
    }
    bool* slotPtr = arr.AppendElement(mozilla::fallible);
    if (!slotPtr) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    bool& slot = *slotPtr;
    if (!ValueToPrimitive<bool, eDefault>(cx, temp, "Element of return value of TestSequenceConstruction", &slot)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
  aRetVal = std::move(rvalDecl);
}



namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace OnlyForUseInConstructor_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::OnlyForUseInConstructor>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::OnlyForUseInConstructor* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::OnlyForUseInConstructor>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "OnlyForUseInConstructor", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::OnlyForUseInConstructor,
  PrototypeTraits<prototypes::id::OnlyForUseInConstructor>::Depth,
  sNativePropertyHooks,
  "function OnlyForUseInConstructor() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "OnlyForUseInConstructorPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::OnlyForUseInConstructor,
  PrototypeTraits<prototypes::id::OnlyForUseInConstructor>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "OnlyForUseInConstructor",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::OnlyForUseInConstructor, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::OnlyForUseInConstructor>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::OnlyForUseInConstructor>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::OnlyForUseInConstructor>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::OnlyForUseInConstructor* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::OnlyForUseInConstructor>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::OnlyForUseInConstructor*>(aObject) ==
             reinterpret_cast<mozilla::dom::OnlyForUseInConstructor*>(aObject),
             "Multiple inheritance for mozilla::dom::OnlyForUseInConstructor is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::OnlyForUseInConstructor> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::OnlyForUseInConstructor,
  constructors::id::OnlyForUseInConstructor,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::OnlyForUseInConstructor);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::OnlyForUseInConstructor);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "OnlyForUseInConstructor", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace OnlyForUseInConstructor_Binding



namespace TestAttributesOnTypes_Binding {

MOZ_CAN_RUN_SCRIPT static bool
foo(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "foo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  if (!args.requireAtLeast(cx, "TestAttributesOnTypes.foo", 1)) {
    return false;
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eClamp>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Foo(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->Foo(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo foo_methodinfo = {
  { (JSJitGetterOp)foo },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
bar(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestAttributesOnTypes.bar");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "bar", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  if (!args.requireAtLeast(cx, "TestAttributesOnTypes.bar", 1)) {
    return false;
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Bar(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->Bar(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo bar_methodinfo = {
  { (JSJitGetterOp)bar },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
baz(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "baz", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  if (!args.requireAtLeast(cx, "TestAttributesOnTypes.baz", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eEmpty, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Baz(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Baz(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo baz_methodinfo = {
  { (JSJitGetterOp)baz },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_someAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "someAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->SomeAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_someAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "someAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eClamp>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetSomeAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetSomeAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo someAttr_getterinfo = {
  { get_someAttr },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo someAttr_setterinfo = {
  { (JSJitGetterOp)set_someAttr },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
argWithAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestAttributesOnTypes", "argWithAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestAttributesOnTypes*>(void_self);
  if (!args.requireAtLeast(cx, "TestAttributesOnTypes.argWithAttr", 1)) {
    return false;
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eClamp>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  Optional<uint8_t> arg1;
  if (args.hasDefined(1)) {
    arg1.Construct();
    if (!ValueToPrimitive<uint8_t, eClamp>(cx, args[1], "Argument 2", &arg1.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ArgWithAttr(arg0, Constify(arg1)))>, "Should be returning void here");
  MOZ_KnownLive(self)->ArgWithAttr(arg0, Constify(arg1));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo argWithAttr_methodinfo = {
  { (JSJitGetterOp)argWithAttr },
  { prototypes::id::TestAttributesOnTypes },
  { PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestAttributesOnTypes* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestAttributesOnTypes>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestAttributesOnTypes* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestAttributesOnTypes>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestAttributesOnTypes>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestAttributesOnTypes* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestAttributesOnTypes>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestAttributesOnTypes* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestAttributesOnTypes>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("foo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&foo_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("bar", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&bar_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("baz", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&baz_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("argWithAttr", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&argWithAttr_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("someAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &someAttr_getterinfo, GenericSetter<NormalThisPolicy>, &someAttr_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestAttributesOnTypes", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[6];
static PropertyInfo sNativeProperties_propertyInfos[6];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  6,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[4] }
  }
};
static_assert(6 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestAttributesOnTypes,
  PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth,
  sNativePropertyHooks,
  "function TestAttributesOnTypes() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestAttributesOnTypesPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestAttributesOnTypes,
  PrototypeTraits<prototypes::id::TestAttributesOnTypes>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestAttributesOnTypes",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestAttributesOnTypes, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestAttributesOnTypes>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestAttributesOnTypes>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestAttributesOnTypes>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestAttributesOnTypes* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestAttributesOnTypes>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestAttributesOnTypes*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestAttributesOnTypes*>(aObject),
             "Multiple inheritance for mozilla::dom::TestAttributesOnTypes is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestAttributesOnTypes> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestAttributesOnTypes,
  constructors::id::TestAttributesOnTypes,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestAttributesOnTypes);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestAttributesOnTypes);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestAttributesOnTypes", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestAttributesOnTypes_Binding



namespace TestCEReactionsInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
item(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestCEReactionsInterface", "item", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestCEReactionsInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestCEReactionsInterface.item", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t result(MOZ_KnownLive(self)->Item(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo item_methodinfo = {
  { (JSJitGetterOp)item },
  { prototypes::id::TestCEReactionsInterface },
  { PrototypeTraits<prototypes::id::TestCEReactionsInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestCEReactionsInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestCEReactionsInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestCEReactionsInterface },
  { PrototypeTraits<prototypes::id::TestCEReactionsInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("item", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&item_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestCEReactionsInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[4];
static PropertyInfo sNativeProperties_propertyInfos[4];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  4,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[2] }
  }
};
static_assert(4 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestCEReactionsInterface,
  PrototypeTraits<prototypes::id::TestCEReactionsInterface>::Depth,
  sNativePropertyHooks,
  "function TestCEReactionsInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestCEReactionsInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestCEReactionsInterface,
  PrototypeTraits<prototypes::id::TestCEReactionsInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestCEReactionsInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestCEReactionsInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestCEReactionsInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    *done = true;
    // https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
    // Step 1.1.  The no-indexed-setter case is handled by step 1.2.
    if (!desc.isDataDescriptor()) {
      return opresult.failNotDataDescriptor();
    }

    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    int32_t item;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc.value(), "Value being assigned to TestCEReactionsInterface setter", &item)) {
      return false;
    }
    Maybe<AutoCEReaction> ceReaction;
    DocGroup* docGroup = self->GetDocGroup();
    if (docGroup) {
      ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, item))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, item);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    return opresult.succeed();
  }
  JSContext* cx = cx_;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    binding_detail::FakeString<char16_t> item;
    if (!ConvertJSValueToString(cx, desc.value(), eStringify, eStringify, item)) {
      return false;
    }
    Maybe<AutoCEReaction> ceReaction;
    DocGroup* docGroup = self->GetDocGroup();
    if (docGroup) {
      ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), NonNullHelper(Constify(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), NonNullHelper(Constify(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return opresult.succeed();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
          return false;
        }
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestCEReactionsInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestCEReactionsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCEReactionsInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestCEReactionsInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
    }
    deleteSucceeded = true;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, v);
    int32_t item;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, v, "Value being assigned to TestCEReactionsInterface setter", &item)) {
      return false;
    }
    Maybe<AutoCEReaction> ceReaction;
    DocGroup* docGroup = self->GetDocGroup();
    if (docGroup) {
      ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, item))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, item);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return true;
  }

  *done = false;
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestCEReactionsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCEReactionsInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestCEReactionsInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestCEReactionsInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestCEReactionsInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestCEReactionsInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestCEReactionsInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestCEReactionsInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestCEReactionsInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestCEReactionsInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestCEReactionsInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestCEReactionsInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestCEReactionsInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

static bool
DeleteNamedProperty(JSContext* cx, JS::Handle<JSObject*> xray, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult)
{
  MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(xray));
  MOZ_ASSERT(js::IsProxy(proxy));
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy));
  JSAutoRealm ar(cx, proxy);
  bool deleteSucceeded = false;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestCEReactionsInterface* self = UnwrapProxy(proxy);
    Maybe<AutoCEReaction> ceReaction;
    DocGroup* docGroup = self->GetDocGroup();
    if (docGroup) {
      ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
  }
  deleteSucceeded = true;
  if (!found || deleteSucceeded) {
    return opresult.succeed();
  }
  return opresult.failCantDelete();
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  DeleteNamedProperty,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestCEReactionsInterface,
  constructors::id::TestCEReactionsInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestCEReactionsInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestCEReactionsInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestCEReactionsInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestCEReactionsInterface_Binding



namespace TestChildInterface_Binding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<TestParentInterface_Binding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestChildInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestChildInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestChildInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestChildInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestChildInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestChildInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestChildInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestChildInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestChildInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestChildInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestChildInterface,
  PrototypeTraits<prototypes::id::TestChildInterface>::Depth,
  sNativePropertyHooks,
  "function TestChildInterface() {\n    [native code]\n}",
  TestParentInterface_Binding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestChildInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestChildInterface,
  PrototypeTraits<prototypes::id::TestChildInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  TestParentInterface_Binding::GetProtoObject
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestChildInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestParentInterface, prototypes::id::TestChildInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestChildInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestChildInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestChildInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestChildInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestChildInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestChildInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestChildInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestChildInterface is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestParentInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestParentInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestParentInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestChildInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestChildInterface,
  constructors::id::TestChildInterface,
  TestParentInterface_Binding::sNativePropertyHooks,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(TestParentInterface_Binding::GetProtoObjectHandle(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(TestParentInterface_Binding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestChildInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestChildInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestChildInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestChildInterface_Binding



namespace TestConstructorForFuncInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestConstructorForFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForFuncInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestConstructorForFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForFuncInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestConstructorForFuncInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestConstructorForFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForFuncInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestConstructorForFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForFuncInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestConstructorForFuncInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestConstructorForFuncInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestConstructorForFuncInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestConstructorForFuncInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestConstructorForFuncInterface>(mozilla::dom::TestConstructorForFuncInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestConstructorForFuncInterface,
  PrototypeTraits<prototypes::id::TestConstructorForFuncInterface>::Depth,
  sNativePropertyHooks,
  "function TestConstructorForFuncInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestConstructorForFuncInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestConstructorForFuncInterface,
  PrototypeTraits<prototypes::id::TestConstructorForFuncInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return Document::IsWebAnimationsEnabled(aCx, aObj);
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestConstructorForFuncInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestConstructorForFuncInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestConstructorForFuncInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestConstructorForFuncInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestConstructorForFuncInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestConstructorForFuncInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestConstructorForFuncInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestConstructorForFuncInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestConstructorForFuncInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestConstructorForFuncInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestConstructorForFuncInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestConstructorForFuncInterface,
  constructors::id::TestConstructorForFuncInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestConstructorForFuncInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestConstructorForFuncInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestConstructorForFuncInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestConstructorForFuncInterface_Binding



namespace TestConstructorForPrefInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestConstructorForPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForPrefInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestConstructorForPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForPrefInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestConstructorForPrefInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestConstructorForPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForPrefInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestConstructorForPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForPrefInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestConstructorForPrefInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestConstructorForPrefInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestConstructorForPrefInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestConstructorForPrefInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestConstructorForPrefInterface>(mozilla::dom::TestConstructorForPrefInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestConstructorForPrefInterface,
  PrototypeTraits<prototypes::id::TestConstructorForPrefInterface>::Depth,
  sNativePropertyHooks,
  "function TestConstructorForPrefInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestConstructorForPrefInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestConstructorForPrefInterface,
  PrototypeTraits<prototypes::id::TestConstructorForPrefInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return StaticPrefs::dom_webidl_test1();
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestConstructorForPrefInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestConstructorForPrefInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestConstructorForPrefInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestConstructorForPrefInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestConstructorForPrefInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestConstructorForPrefInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestConstructorForPrefInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestConstructorForPrefInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestConstructorForPrefInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestConstructorForPrefInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestConstructorForPrefInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestConstructorForPrefInterface,
  constructors::id::TestConstructorForPrefInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestConstructorForPrefInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestConstructorForPrefInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestConstructorForPrefInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestConstructorForPrefInterface_Binding



namespace TestConstructorForSCInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestConstructorForSCInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForSCInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestConstructorForSCInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForSCInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestConstructorForSCInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestConstructorForSCInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForSCInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestConstructorForSCInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestConstructorForSCInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestConstructorForSCInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestConstructorForSCInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestConstructorForSCInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestConstructorForSCInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestConstructorForSCInterface>(mozilla::dom::TestConstructorForSCInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestConstructorForSCInterface,
  PrototypeTraits<prototypes::id::TestConstructorForSCInterface>::Depth,
  sNativePropertyHooks,
  "function TestConstructorForSCInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestConstructorForSCInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestConstructorForSCInterface,
  PrototypeTraits<prototypes::id::TestConstructorForSCInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return mozilla::dom::IsSecureContextOrObjectIsFromSecureContext(aCx, aObj);
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestConstructorForSCInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestConstructorForSCInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestConstructorForSCInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestConstructorForSCInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestConstructorForSCInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestConstructorForSCInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestConstructorForSCInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestConstructorForSCInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestConstructorForSCInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestConstructorForSCInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestConstructorForSCInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestConstructorForSCInterface,
  constructors::id::TestConstructorForSCInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestConstructorForSCInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestConstructorForSCInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestConstructorForSCInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestConstructorForSCInterface_Binding



namespace TestCppKeywordNamedMethodsInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
_continue_(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestCppKeywordNamedMethodsInterface", "continue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Continue());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo continue_methodinfo = {
  { (JSJitGetterOp)_continue_ },
  { prototypes::id::TestCppKeywordNamedMethodsInterface },
  { PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
_delete_(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestCppKeywordNamedMethodsInterface", "delete", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Delete());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo delete_methodinfo = {
  { (JSJitGetterOp)_delete_ },
  { prototypes::id::TestCppKeywordNamedMethodsInterface },
  { PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
_volatile_(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestCppKeywordNamedMethodsInterface", "volatile", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->Volatile());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo volatile_methodinfo = {
  { (JSJitGetterOp)_volatile_ },
  { prototypes::id::TestCppKeywordNamedMethodsInterface },
  { PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestCppKeywordNamedMethodsInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestCppKeywordNamedMethodsInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestCppKeywordNamedMethodsInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("continue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&continue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("delete", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&delete_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("volatile", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&volatile_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestCppKeywordNamedMethodsInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[4];
static PropertyInfo sNativeProperties_propertyInfos[4];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  4,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[3] }
  }
};
static_assert(4 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth,
  sNativePropertyHooks,
  "function TestCppKeywordNamedMethodsInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestCppKeywordNamedMethodsInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  PrototypeTraits<prototypes::id::TestCppKeywordNamedMethodsInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestCppKeywordNamedMethodsInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestCppKeywordNamedMethodsInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestCppKeywordNamedMethodsInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestCppKeywordNamedMethodsInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestCppKeywordNamedMethodsInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestCppKeywordNamedMethodsInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestCppKeywordNamedMethodsInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestCppKeywordNamedMethodsInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestCppKeywordNamedMethodsInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestCppKeywordNamedMethodsInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestCppKeywordNamedMethodsInterface,
  constructors::id::TestCppKeywordNamedMethodsInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestCppKeywordNamedMethodsInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestCppKeywordNamedMethodsInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestCppKeywordNamedMethodsInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestCppKeywordNamedMethodsInterface_Binding



namespace TestDeprecatedInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
alsoDeprecated(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestDeprecatedInterface", "alsoDeprecated", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestDeprecatedInterface::AlsoDeprecated(global))>, "Should be returning void here");
  mozilla::dom::TestDeprecatedInterface::AlsoDeprecated(global);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestDeprecatedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestDeprecatedInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestDeprecatedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestDeprecatedInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestDeprecatedInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestDeprecatedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestDeprecatedInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestDeprecatedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestDeprecatedInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("alsoDeprecated", alsoDeprecated, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestDeprecatedInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  false, 0,
  false, 0,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestDeprecatedInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestDeprecatedInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestDeprecatedInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestDeprecatedInterface>(mozilla::dom::TestDeprecatedInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestDeprecatedInterface,
  PrototypeTraits<prototypes::id::TestDeprecatedInterface>::Depth,
  sNativePropertyHooks,
  "function TestDeprecatedInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestDeprecatedInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestDeprecatedInterface,
  PrototypeTraits<prototypes::id::TestDeprecatedInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestDeprecatedInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestDeprecatedInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestDeprecatedInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestDeprecatedInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestDeprecatedInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestDeprecatedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestDeprecatedInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestDeprecatedInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestDeprecatedInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestDeprecatedInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestDeprecatedInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestDeprecatedInterface,
  constructors::id::TestDeprecatedInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestDeprecatedInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestDeprecatedInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestDeprecatedInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestDeprecatedInterface_Binding



namespace TestFuncConstructorForDifferentFuncInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestFuncConstructorForDifferentFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestFuncConstructorForDifferentFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestFuncConstructorForDifferentFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestFuncConstructorForDifferentFuncInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestFuncConstructorForDifferentFuncInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestFuncConstructorForDifferentFuncInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!Document::IsWebAnimationsEnabled(cx, obj)) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestFuncConstructorForDifferentFuncInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestFuncConstructorForDifferentFuncInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>(mozilla::dom::TestFuncConstructorForDifferentFuncInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestFuncConstructorForDifferentFuncInterface,
  PrototypeTraits<prototypes::id::TestFuncConstructorForDifferentFuncInterface>::Depth,
  sNativePropertyHooks,
  "function TestFuncConstructorForDifferentFuncInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestFuncConstructorForDifferentFuncInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestFuncConstructorForDifferentFuncInterface,
  PrototypeTraits<prototypes::id::TestFuncConstructorForDifferentFuncInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return Document::AreWebAnimationsTimelinesEnabled(aCx, aObj);
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestFuncConstructorForDifferentFuncInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestFuncConstructorForDifferentFuncInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestFuncConstructorForDifferentFuncInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestFuncConstructorForDifferentFuncInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestFuncConstructorForDifferentFuncInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestFuncConstructorForDifferentFuncInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestFuncConstructorForDifferentFuncInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestFuncConstructorForDifferentFuncInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestFuncConstructorForDifferentFuncInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestFuncConstructorForDifferentFuncInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestFuncConstructorForDifferentFuncInterface,
  constructors::id::TestFuncConstructorForDifferentFuncInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestFuncConstructorForDifferentFuncInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestFuncConstructorForDifferentFuncInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestFuncConstructorForDifferentFuncInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestFuncConstructorForDifferentFuncInterface_Binding



namespace TestFuncConstructorForInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestFuncConstructorForInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestFuncConstructorForInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestFuncConstructorForInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestFuncConstructorForInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!Document::IsWebAnimationsEnabled(cx, obj)) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestFuncConstructorForInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestFuncConstructorForInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestFuncConstructorForInterface>(mozilla::dom::TestFuncConstructorForInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestFuncConstructorForInterface,
  PrototypeTraits<prototypes::id::TestFuncConstructorForInterface>::Depth,
  sNativePropertyHooks,
  "function TestFuncConstructorForInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestFuncConstructorForInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestFuncConstructorForInterface,
  PrototypeTraits<prototypes::id::TestFuncConstructorForInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestFuncConstructorForInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestFuncConstructorForInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestFuncConstructorForInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestFuncConstructorForInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestFuncConstructorForInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestFuncConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestFuncConstructorForInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestFuncConstructorForInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestFuncConstructorForInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestFuncConstructorForInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestFuncConstructorForInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestFuncConstructorForInterface,
  constructors::id::TestFuncConstructorForInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestFuncConstructorForInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestFuncConstructorForInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestFuncConstructorForInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestFuncConstructorForInterface_Binding



namespace TestHTMLConstructorInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestHTMLConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestHTMLConstructorInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestHTMLConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestHTMLConstructorInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestHTMLConstructorInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestHTMLConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestHTMLConstructorInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestHTMLConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestHTMLConstructorInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestHTMLConstructorInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestHTMLConstructorInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  return HTMLConstructor(cx, argc, vp,
                         constructors::id::TestHTMLConstructorInterface,
                         prototypes::id::TestHTMLConstructorInterface,
                         CreateInterfaceObjects);
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestHTMLConstructorInterface,
  PrototypeTraits<prototypes::id::TestHTMLConstructorInterface>::Depth,
  sNativePropertyHooks,
  "function TestHTMLConstructorInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestHTMLConstructorInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestHTMLConstructorInterface,
  PrototypeTraits<prototypes::id::TestHTMLConstructorInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestHTMLConstructorInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestHTMLConstructorInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestHTMLConstructorInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestHTMLConstructorInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestHTMLConstructorInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestHTMLConstructorInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestHTMLConstructorInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestHTMLConstructorInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestHTMLConstructorInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestHTMLConstructorInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestHTMLConstructorInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestHTMLConstructorInterface,
  constructors::id::TestHTMLConstructorInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestHTMLConstructorInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestHTMLConstructorInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestHTMLConstructorInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestHTMLConstructorInterface_Binding



namespace TestIndexedAndNamedGetterAndSetterInterface_Binding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<TestIndexedSetterInterface_Binding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

MOZ_CAN_RUN_SCRIPT static bool
item(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterAndSetterInterface", "item", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedAndNamedGetterAndSetterInterface.item", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t result(MOZ_KnownLive(self)->Item(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo item_methodinfo = {
  { (JSJitGetterOp)item },
  { prototypes::id::TestIndexedAndNamedGetterAndSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
namedItem(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterAndSetterInterface", "namedItem", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedAndNamedGetterAndSetterInterface.namedItem", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedItem(NonNullHelper(Constify(arg0)), result))>, "Should be returning void here");
  MOZ_KnownLive(self)->NamedItem(NonNullHelper(Constify(arg0)), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo namedItem_methodinfo = {
  { (JSJitGetterOp)namedItem },
  { prototypes::id::TestIndexedAndNamedGetterAndSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
__stringifier(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterAndSetterInterface", "__stringifier", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Stringify(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->Stringify(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo __stringifier_methodinfo = {
  { (JSJitGetterOp)__stringifier },
  { prototypes::id::TestIndexedAndNamedGetterAndSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterAndSetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedAndNamedGetterAndSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("item", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&item_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("namedItem", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&namedItem_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FNSPEC("toString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&__stringifier_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedAndNamedGetterAndSetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[6];
static PropertyInfo sNativeProperties_propertyInfos[6];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  6,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[4] }
  }
};
static_assert(6 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedAndNamedGetterAndSetterInterface() {\n    [native code]\n}",
  TestIndexedSetterInterface_Binding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedAndNamedGetterAndSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterAndSetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  TestIndexedSetterInterface_Binding::GetProtoObject
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    *done = true;
    // https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
    // Step 1.1.  The no-indexed-setter case is handled by step 1.2.
    if (!desc.isDataDescriptor()) {
      return opresult.failNotDataDescriptor();
    }

    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    int32_t item;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc.value(), "Value being assigned to TestIndexedAndNamedGetterAndSetterInterface setter", &item)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, item))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, item);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    return opresult.succeed();
  }
  JSContext* cx = cx_;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    binding_detail::FakeString<char16_t> item;
    if (!ConvertJSValueToString(cx, desc.value(), eStringify, eStringify, item)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), NonNullHelper(Constify(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), NonNullHelper(Constify(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return opresult.succeed();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
          return false;
        }
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestIndexedAndNamedGetterAndSetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, v);
    int32_t item;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, v, "Value being assigned to TestIndexedAndNamedGetterAndSetterInterface setter", &item)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, item))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, item);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return true;
  }

  *done = false;
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestIndexedAndNamedGetterAndSetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestIndexedSetterInterface, prototypes::id::TestIndexedAndNamedGetterAndSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedSetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedSetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
  constructors::id::TestIndexedAndNamedGetterAndSetterInterface,
  TestIndexedSetterInterface_Binding::sNativePropertyHooks,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(TestIndexedSetterInterface_Binding::GetProtoObjectHandle(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(TestIndexedSetterInterface_Binding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedAndNamedGetterAndSetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedAndNamedGetterAndSetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedAndNamedGetterAndSetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedAndNamedGetterAndSetterInterface_Binding



namespace TestIndexedAndNamedGetterInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
namedItem(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterInterface", "namedItem", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedAndNamedGetterInterface.namedItem", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedItem(NonNullHelper(Constify(arg0)), result))>, "Should be returning void here");
  MOZ_KnownLive(self)->NamedItem(NonNullHelper(Constify(arg0)), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo namedItem_methodinfo = {
  { (JSJitGetterOp)namedItem },
  { prototypes::id::TestIndexedAndNamedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedGetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedAndNamedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("namedItem", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&namedItem_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedAndNamedGetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[4];
static PropertyInfo sNativeProperties_propertyInfos[4];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  4,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[2] }
  }
};
static_assert(4 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedAndNamedGetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedAndNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedGetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  if (IsArrayIndex(GetArrayIndexFromId(id))) {
    *done = true;
    return opresult.failNoIndexedSetter();
  }
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    DOMString result;
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
          return false;
        }
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestIndexedAndNamedGetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedGetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestIndexedAndNamedGetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestIndexedAndNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedGetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestIndexedAndNamedGetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestIndexedAndNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedGetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestIndexedAndNamedGetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestIndexedAndNamedGetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestIndexedAndNamedGetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedGetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedAndNamedGetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestIndexedAndNamedGetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedAndNamedGetterInterface,
  constructors::id::TestIndexedAndNamedGetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedAndNamedGetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedAndNamedGetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedAndNamedGetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedAndNamedGetterInterface_Binding



namespace TestIndexedAndNamedSetterInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedSetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedAndNamedSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
setNamedItem(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestIndexedAndNamedSetterInterface.setNamedItem");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedAndNamedSetterInterface", "setNamedItem", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedAndNamedSetterInterface.setNamedItem", 2)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  NonNull<mozilla::dom::TestIndexedSetterInterface> arg1;
  if (args[1].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(args[1], arg1, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestIndexedSetterInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNamedItem(NonNullHelper(Constify(arg0)), MOZ_KnownLive(NonNullHelper(arg1))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNamedItem(NonNullHelper(Constify(arg0)), MOZ_KnownLive(NonNullHelper(arg1)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setNamedItem_methodinfo = {
  { (JSJitGetterOp)setNamedItem },
  { prototypes::id::TestIndexedAndNamedSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("setNamedItem", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&setNamedItem_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedAndNamedSetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[4];
static PropertyInfo sNativeProperties_propertyInfos[4];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  4,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[2] }
  }
};
static_assert(4 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedAndNamedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedAndNamedSetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedAndNamedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedAndNamedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedAndNamedSetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedSetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedAndNamedSetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->IndexedGetter(index, found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      if (!GetOrCreateDOMReflector(cx, result, desc.value())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!GetOrCreateDOMReflector(cx, result, desc.value())) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    BindingCallContext cx(cx_, "TestIndexedAndNamedSetterInterface indexed setter");
    *done = true;
    // https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
    // Step 1.1.  The no-indexed-setter case is handled by step 1.2.
    if (!desc.isDataDescriptor()) {
      return opresult.failNotDataDescriptor();
    }

    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    NonNull<mozilla::dom::TestIndexedSetterInterface> item;
    if (desc.value().isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(&rootedValue, item, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned to TestIndexedAndNamedSetterInterface setter", "TestIndexedSetterInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned to TestIndexedAndNamedSetterInterface setter");
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, MOZ_KnownLive(NonNullHelper(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, MOZ_KnownLive(NonNullHelper(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    return opresult.succeed();
  }
  BindingCallContext cx(cx_, "TestIndexedAndNamedSetterInterface.setNamedItem");
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    NonNull<mozilla::dom::TestIndexedSetterInterface> item;
    if (desc.value().isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(&rootedValue, item, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned to TestIndexedAndNamedSetterInterface setter", "TestIndexedSetterInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned to TestIndexedAndNamedSetterInterface setter");
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), MOZ_KnownLive(NonNullHelper(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(name)), MOZ_KnownLive(NonNullHelper(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return opresult.succeed();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->IndexedGetter(index, found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->IndexedGetter(index, found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      if (!GetOrCreateDOMReflector(cx, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!GetOrCreateDOMReflector(cx, result, vp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestIndexedAndNamedSetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedSetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestIndexedAndNamedSetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->IndexedGetter(index, found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    bool found = false;
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->IndexedGetter(index, found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    if (!GetOrCreateDOMReflector(cx, result, &temp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    BindingCallContext cx(cx_, "TestIndexedAndNamedSetterInterface indexed setter");
    mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, v);
    NonNull<mozilla::dom::TestIndexedSetterInterface> item;
    if (v.isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(&rootedValue, item, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned to TestIndexedAndNamedSetterInterface setter", "TestIndexedSetterInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned to TestIndexedAndNamedSetterInterface setter");
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, MOZ_KnownLive(NonNullHelper(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, MOZ_KnownLive(NonNullHelper(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return true;
  }

  *done = false;
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestIndexedAndNamedSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedAndNamedSetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestIndexedAndNamedSetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestIndexedAndNamedSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedAndNamedSetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestIndexedAndNamedSetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestIndexedAndNamedSetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestIndexedAndNamedSetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedAndNamedSetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedAndNamedSetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestIndexedAndNamedSetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedAndNamedSetterInterface,
  constructors::id::TestIndexedAndNamedSetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedAndNamedSetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedAndNamedSetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedAndNamedSetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedAndNamedSetterInterface_Binding



namespace TestIndexedGetterAndSetterAndNamedGetterInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedGetterAndSetterAndNamedGetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedGetterAndSetterAndNamedGetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[3];
static PropertyInfo sNativeProperties_propertyInfos[3];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  3,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(3 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedGetterAndSetterAndNamedGetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedGetterAndSetterAndNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> myName;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, myName, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    *done = true;
    // https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
    // Step 1.1.  The no-indexed-setter case is handled by step 1.2.
    if (!desc.isDataDescriptor()) {
      return opresult.failNotDataDescriptor();
    }

    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    int32_t arg;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc.value(), "Value being assigned to TestIndexedGetterAndSetterAndNamedGetterInterface setter", &arg)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, arg))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, arg);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    return opresult.succeed();
  }
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> myName;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, myName, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    DOMString result;
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> myName;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, myName, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> myName;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, myName, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
          return false;
        }
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestIndexedGetterAndSetterAndNamedGetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> myName;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, myName, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(myName)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(index, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, v);
    int32_t arg;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, v, "Value being assigned to TestIndexedGetterAndSetterAndNamedGetterInterface setter", &arg)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(index, arg))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(index, arg);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return true;
  }

  *done = false;
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestIndexedGetterAndSetterAndNamedGetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedGetterAndSetterAndNamedGetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedGetterAndSetterAndNamedGetterInterface_Binding



namespace TestIndexedGetterInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
item(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedGetterInterface", "item", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedGetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedGetterInterface.item", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t result(MOZ_KnownLive(self)->Item(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo item_methodinfo = {
  { (JSJitGetterOp)item },
  { prototypes::id::TestIndexedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 3, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedGetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedGetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 3, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_cachedAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedGetterInterface", "cachedAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedGetterInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 0) : (DOM_INSTANCE_RESERVED_SLOTS + 0);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int32_t result(MOZ_KnownLive(self)->CachedAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedAttr_getterinfo = {
  { get_cachedAttr },
  { prototypes::id::TestIndexedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 0)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) < 3, "There is no slot for us");

static bool
get_storeInSlotAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedGetterInterface", "storeInSlotAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedGetterInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 1) : (DOM_INSTANCE_RESERVED_SLOTS + 1);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int32_t result(MOZ_KnownLive(self)->StoreInSlotAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo storeInSlotAttr_getterinfo = {
  { get_storeInSlotAttr },
  { prototypes::id::TestIndexedGetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 1)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < 3, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("item", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&item_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("cachedAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedAttr_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("storeInSlotAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &storeInSlotAttr_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedGetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[6];
static PropertyInfo sNativeProperties_propertyInfos[6];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  6,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[2] }
  }
};
static_assert(6 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedGetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

MOZ_CAN_RUN_SCRIPT static bool
_legacycaller(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  mozilla::dom::TestIndexedGetterInterface* self;
  JS::Rooted<JS::Value> rootSelf(cx, JS::ObjectValue(*obj));
  {
    // Our JSContext should be in the right global to do unwrapping in.
    nsresult rv = UnwrapObject<prototypes::id::TestIndexedGetterInterface, mozilla::dom::TestIndexedGetterInterface>(&rootSelf, self, cx);
    if (NS_FAILED(rv)) {
      MOZ_CRASH("Unexpected object in '_legacycaller' hook");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->LegacyCall(args.thisv()))>, "Should be returning void here");
  MOZ_KnownLive(self)->LegacyCall(args.thisv());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedGetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedGetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedGetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  call(JSContext* cx, JS::Handle<JSObject*> proxy, const JS::CallArgs& args) const override;

  bool
  isCallable(JSObject* obj) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestIndexedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestIndexedGetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(idx, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, true);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  if (IsArrayIndex(GetArrayIndexFromId(id))) {
    *done = true;
    return opresult.failNoIndexedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(idx, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(idx, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestIndexedGetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestIndexedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedGetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestIndexedGetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    uint32_t idx = index;
    mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(idx, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestIndexedGetterInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    uint32_t idx = index;
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(idx, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::call(JSContext* cx, JS::Handle<JSObject*> proxy, const JS::CallArgs& args) const
{
  return js::ForwardToNative(cx, _legacycaller, args);
}

bool
DOMProxyHandler::isCallable(JSObject* obj) const
{
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestIndexedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestIndexedGetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestIndexedGetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3)),
  { prototypes::id::TestIndexedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestIndexedGetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestIndexedGetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestIndexedGetterInterface>::Get(),
  nullptr,
  nullptr
};

static bool
UpdateMemberSlots(JSContext* aCx, JS::Handle<JSObject*> aWrapper, mozilla::dom::TestIndexedGetterInterface* aObject)
{
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);

  static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < JS::shadow::Object::MAX_FIXED_SLOTS,
                "Not enough fixed slots to fit 'TestIndexedGetterInterface.storeInSlotAttr.  Ion's visitGetDOMMemberV/visitGetDOMMemberT assume StoreInSlot things are all in fixed slots.");
  if (!get_storeInSlotAttr(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  return true;
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestIndexedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestIndexedGetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestIndexedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestIndexedGetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestIndexedGetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestIndexedGetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  if (!UpdateMemberSlots(aCx, aReflector, aObject)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

// This may allocate too many slots, because we only really need
// slots for our non-interface-typed members that we cache.  But
// allocating slots only for those would make the slot index
// computations much more complicated, so let's do this the simple
// way for now.
DEFINE_XRAY_EXPANDO_CLASS(static, sXrayExpandoObjectClass, 2);

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedGetterInterface,
  constructors::id::TestIndexedGetterInterface,
  nullptr,
  &sXrayExpandoObjectClass
} };

void
ClearCachedCachedAttrValue(mozilla::dom::TestIndexedGetterInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 0), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 0));
}

bool
ClearCachedStoreInSlotAttrValue(JSContext* aCx, mozilla::dom::TestIndexedGetterInterface* aObject)
{
  JS::Rooted<JSObject*> obj(aCx);
  obj = aObject->GetWrapper();
  if (!obj) {
    return true;
  }
  JS::Rooted<JS::Value> oldValue(aCx, JS::GetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 1)));
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 1), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 1));
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);
  JSAutoRealm ar(aCx, obj);
  if (!get_storeInSlotAttr(aCx, obj, aObject, args)) {
    JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 1), oldValue);
    return false;
  }
  return true;
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedGetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedGetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedGetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedGetterInterface_Binding



namespace TestIndexedSetterInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
setItem(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedSetterInterface", "setItem", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedSetterInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestIndexedSetterInterface.setItem", 2)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg1;
  if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetItem(arg0, NonNullHelper(Constify(arg1))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetItem(arg0, NonNullHelper(Constify(arg1)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setItem_methodinfo = {
  { (JSJitGetterOp)setItem },
  { prototypes::id::TestIndexedSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedSetterInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestIndexedSetterInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestIndexedSetterInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestIndexedSetterInterface },
  { PrototypeTraits<prototypes::id::TestIndexedSetterInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("setItem", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&setItem_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestIndexedSetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[3];
static PropertyInfo sNativeProperties_propertyInfos[3];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  3,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(3 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestIndexedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedSetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestIndexedSetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestIndexedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestIndexedSetterInterface,
  PrototypeTraits<prototypes::id::TestIndexedSetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestIndexedSetterInterface,
  constructors::id::TestIndexedSetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestIndexedSetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestIndexedSetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestIndexedSetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestIndexedSetterInterface_Binding



namespace TestInterface_Binding {

static bool
_Test(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test(global, rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test(global, NonNullHelper(Constify(arg0)), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
_Test2(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test2 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test2", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test2");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "Test2 constructor", 5)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  RootedDictionary<binding_detail::FastDictForConstructor> arg0(cx);
  if (!arg0.Init(cx, args[0], "Argument 1", false)) {
    return false;
  }
  JS::Rooted<JS::Value> arg1(cx);
  arg1 = args[1];
  JS::Rooted<JSObject*> arg2(cx);
  if (args[2].isObject()) {
    arg2 = &args[2].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
    return false;
  }
  JS::Rooted<JSObject*> arg3(cx);
  if (args[3].isObject()) {
    arg3 = &args[3].toObject();
  } else if (args[3].isNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 4");
    return false;
  }
  binding_detail::AutoSequence<Dict> arg4;
  SequenceRooter<Dict> arg4_holder(cx, &arg4);
  if (args[4].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[4], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 5");
      return false;
    }
    binding_detail::AutoSequence<Dict> &arr = arg4;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Dict* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Dict& slot = *slotPtr;
      if (!slot.Init(cx, temp, "Element of argument 5", false)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 5");
    return false;
  }
  JS::Rooted<JS::Value> arg5(cx);
  if (args.hasDefined(5)) {
    arg5 = args[5];
  } else {
    arg5 = JS::UndefinedValue();
  }
  Optional<JS::Handle<JSObject*>> arg6;
  if (args.hasDefined(6)) {
    arg6.Construct(cx);
    if (args[6].isObject()) {
      arg6.Value() = &args[6].toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 7");
      return false;
    }
  }
  Optional<JS::Handle<JSObject*>> arg7;
  if (args.hasDefined(7)) {
    arg7.Construct(cx);
    if (args[7].isObject()) {
      arg7.Value() = &args[7].toObject();
    } else if (args[7].isNullOrUndefined()) {
      arg7.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 8");
      return false;
    }
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mAny1))) {
      return false;
    }
    if (arg0.mDict.WasPassed()) {
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mAnotherAny))) {
        return false;
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mAnotherObj))) {
        return false;
      }
      if (arg0.mDict.Value().mArrayBuffer.WasPassed()) {
        if (!arg0.mDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg0.mDict.Value().mCustomEventInit.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mCustomEventInit.Value().mDetail))) {
          return false;
        }
      }
      if (arg0.mDict.Value().mDictionaryTypedef.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mDictionaryTypedef.Value().mDetail))) {
          return false;
        }
      }
      if (!arg0.mDict.Value().mFloat64Array.IsNull()) {
        if (!arg0.mDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg0.mDict.Value().mNullableArrayBuffer.WasPassed()) {
        if (!arg0.mDict.Value().mNullableArrayBuffer.Value().IsNull()) {
          if (!arg0.mDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
      }
      if (arg0.mDict.Value().mObjectOrLong.WasPassed()) {
        if (arg0.mDict.Value().mObjectOrLong.Value().IsObject()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mObjectOrLong.Value().GetAsObject()))) {
            return false;
          }
        }
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mRequiredObject))) {
        return false;
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mSomeAny))) {
        return false;
      }
      if (arg0.mDict.Value().mSomeObj.WasPassed()) {
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mSomeObj.Value()))) {
          return false;
        }
      }
      if (arg0.mDict.Value().mUint8Array.WasPassed()) {
        if (!arg0.mDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mParentAny))) {
        return false;
      }
    }
    if (arg0.mDict2.WasPassed()) {
      if (arg0.mDict2.Value().mMemberDict.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mAnotherAny))) {
          return false;
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mAnotherObj))) {
          return false;
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mArrayBuffer.WasPassed()) {
          if (!arg0.mDict2.Value().mMemberDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mCustomEventInit.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mCustomEventInit.Value().mDetail))) {
            return false;
          }
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.Value().mDetail))) {
            return false;
          }
        }
        if (!arg0.mDict2.Value().mMemberDict.Value().mFloat64Array.IsNull()) {
          if (!arg0.mDict2.Value().mMemberDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.WasPassed()) {
          if (!arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().IsNull()) {
            if (!arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.WasPassed()) {
          if (arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().IsObject()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().GetAsObject()))) {
              return false;
            }
          }
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mRequiredObject))) {
          return false;
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mSomeAny))) {
          return false;
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mSomeObj.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mSomeObj.Value()))) {
            return false;
          }
        }
        if (arg0.mDict2.Value().mMemberDict.Value().mUint8Array.WasPassed()) {
          if (!arg0.mDict2.Value().mMemberDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mParentAny))) {
          return false;
        }
      }
    }
    if (arg0.mObj1.WasPassed()) {
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mObj1.Value()))) {
        return false;
      }
    }
    if (arg0.mObj2.WasPassed()) {
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mObj2.Value()))) {
        return false;
      }
    }
    if (arg0.mSeq1.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq1.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mAnotherAny))) {
          return false;
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mAnotherObj))) {
          return false;
        }
        if (arg0.mSeq1.Value()[indexName0].mArrayBuffer.WasPassed()) {
          if (!arg0.mSeq1.Value()[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg0.mSeq1.Value()[indexName0].mCustomEventInit.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mCustomEventInit.Value().mDetail))) {
            return false;
          }
        }
        if (arg0.mSeq1.Value()[indexName0].mDictionaryTypedef.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mDictionaryTypedef.Value().mDetail))) {
            return false;
          }
        }
        if (!arg0.mSeq1.Value()[indexName0].mFloat64Array.IsNull()) {
          if (!arg0.mSeq1.Value()[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.WasPassed()) {
          if (!arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().IsNull()) {
            if (!arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
        }
        if (arg0.mSeq1.Value()[indexName0].mObjectOrLong.WasPassed()) {
          if (arg0.mSeq1.Value()[indexName0].mObjectOrLong.Value().IsObject()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mObjectOrLong.Value().GetAsObject()))) {
              return false;
            }
          }
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mRequiredObject))) {
          return false;
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mSomeAny))) {
          return false;
        }
        if (arg0.mSeq1.Value()[indexName0].mSomeObj.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mSomeObj.Value()))) {
            return false;
          }
        }
        if (arg0.mSeq1.Value()[indexName0].mUint8Array.WasPassed()) {
          if (!arg0.mSeq1.Value()[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mParentAny))) {
          return false;
        }
      }
    }
    if (arg0.mSeq2.WasPassed()) {
      if (!arg0.mSeq2.Value().IsNull()) {
        for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq2.Value().Value().Length(); ++indexName0) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq2.Value().Value()[indexName0].Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mAnotherObj))) {
              return false;
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.WasPassed()) {
              if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.IsNull()) {
              if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.WasPassed()) {
              if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().IsNull()) {
                if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.WasPassed()) {
              if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeAny))) {
              return false;
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.WasPassed()) {
              if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mParentAny))) {
              return false;
            }
          }
        }
      }
    }
    if (arg0.mSeq3.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq3.Value().Length(); ++indexName0) {
        if (!arg0.mSeq3.Value()[indexName0].IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq3.Value()[indexName0].Value().Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherObj))) {
              return false;
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.WasPassed()) {
              if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.IsNull()) {
              if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.WasPassed()) {
              if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().IsNull()) {
                if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.WasPassed()) {
              if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeAny))) {
              return false;
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.WasPassed()) {
              if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mParentAny))) {
              return false;
            }
          }
        }
      }
    }
    if (arg0.mSeq4.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq4.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq4.Value()[indexName0]))) {
          return false;
        }
      }
    }
    if (arg0.mSeq5.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq5.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq5.Value()[indexName0]))) {
          return false;
        }
      }
    }
    if (arg0.mSeq6.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq6.Value().Length(); ++indexName0) {
        if (arg0.mSeq6.Value()[indexName0].mOurSequence3.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence3.Value().Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence3.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg0.mSeq6.Value()[indexName0].mOurSequence4.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence4.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence4.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg0.mSeq6.Value()[indexName0].mOurSequence5.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence5.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence5.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg0.mSeq6.Value()[indexName0].mOurSequence6.WasPassed()) {
          if (!arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().IsNull()) {
            for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().Value().Length(); ++indexName1) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().Value()[indexName1]))) {
                return false;
              }
            }
          }
        }
        if (arg0.mSeq6.Value()[indexName0].mOurSequence7.WasPassed()) {
          if (!arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().IsNull()) {
            for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().Value().Length(); ++indexName1) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().Value()[indexName1]))) {
                return false;
              }
            }
          }
        }
        if (!arg0.mSeq6.Value()[indexName0].mOurSequence8.IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence8.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence8.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (!arg0.mSeq6.Value()[indexName0].mOurSequence9.IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence9.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence9.Value()[indexName1]))) {
              return false;
            }
          }
        }
      }
    }
    if (!JS_WrapValue(cx, &arg1)) {
      return false;
    }
    if (!JS_WrapObject(cx, &arg2)) {
      return false;
    }
    if (!JS_WrapObject(cx, &arg3)) {
      return false;
    }
    for (uint32_t indexName0 = 0; indexName0 < arg4.Length(); ++indexName0) {
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mAnotherAny))) {
        return false;
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mAnotherObj))) {
        return false;
      }
      if (arg4[indexName0].mArrayBuffer.WasPassed()) {
        if (!arg4[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg4[indexName0].mCustomEventInit.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mCustomEventInit.Value().mDetail))) {
          return false;
        }
      }
      if (arg4[indexName0].mDictionaryTypedef.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mDictionaryTypedef.Value().mDetail))) {
          return false;
        }
      }
      if (!arg4[indexName0].mFloat64Array.IsNull()) {
        if (!arg4[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg4[indexName0].mNullableArrayBuffer.WasPassed()) {
        if (!arg4[indexName0].mNullableArrayBuffer.Value().IsNull()) {
          if (!arg4[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
      }
      if (arg4[indexName0].mObjectOrLong.WasPassed()) {
        if (arg4[indexName0].mObjectOrLong.Value().IsObject()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mObjectOrLong.Value().GetAsObject()))) {
            return false;
          }
        }
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mRequiredObject))) {
        return false;
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mSomeAny))) {
        return false;
      }
      if (arg4[indexName0].mSomeObj.WasPassed()) {
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mSomeObj.Value()))) {
          return false;
        }
      }
      if (arg4[indexName0].mUint8Array.WasPassed()) {
        if (!arg4[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mParentAny))) {
        return false;
      }
    }
    if (!JS_WrapValue(cx, &arg5)) {
      return false;
    }
    if (arg6.WasPassed()) {
      if (!JS_WrapObject(cx, &arg6.Value())) {
        return false;
      }
    }
    if (arg7.WasPassed()) {
      if (!JS_WrapObject(cx, &arg7.Value())) {
        return false;
      }
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test2(global, Constify(arg0), arg1, arg2, arg3, Constify(arg4), arg5, Constify(arg6), Constify(arg7), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test2 constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
_Test3(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test3 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test3", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test3");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "Test3 constructor", 1)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  LongOrStringAnyRecord arg0;
  LongOrStringAnyRecordArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!done) {
        done = (failed = !arg0_holder.TrySetToStringAnyRecord(cx, args[0], tryNext, false)) || !tryNext;
      }
    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "record<DOMString, any>");
      return false;
    }
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    if (arg0.IsStringAnyRecord()) {
      for (auto& mapEntry0 : arg0.GetAsStringAnyRecord().Entries()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&mapEntry0.mValue))) {
          return false;
        }
      }
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test3(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test3 constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
_Test4(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test4 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test4", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test4");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "Test4 constructor", 1)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Record<nsString, Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, Record<nsString, JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, JS::Value>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, JS::Value>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    for (auto& mapEntry0 : arg0.Entries()) {
      for (auto& mapEntry1 : mapEntry0.mValue.Entries()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&mapEntry1.mValue))) {
          return false;
        }
      }
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test4(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test4 constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
_Test5(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test5 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test5", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test5");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "Test5 constructor", 1)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Record<nsString, Sequence<Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>>> arg0;
  RecordRooter<nsString, Sequence<Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Sequence<Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Sequence<Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>>& slot = entry->mValue;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
          return false;
        }
        Sequence<Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>& slot1 = *slotPtr1;
          if (temp1.isObject()) {
            auto& recordEntries = slot1.Entries();

            JS::Rooted<JSObject*> recordObj(cx, &temp1.toObject());
            JS::RootedVector<jsid> ids(cx);
            if (!js::GetPropertyKeys(cx, recordObj,
                                     JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
              return false;
            }
            if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Rooted<JS::Value> propNameValue(cx);
            JS::Rooted<JS::Value> temp(cx);
            JS::Rooted<jsid> curId(cx);
            JS::Rooted<JS::Value> idVal(cx);
            // Use a hashset to keep track of ids seen, to avoid
            // introducing nasty O(N^2) behavior scanning for them all the
            // time.  Ideally we'd use a data structure with O(1) lookup
            // _and_ ordering for the MozMap, but we don't have one lying
            // around.
            nsTHashtable<nsStringHashKey> idsSeen;
            for (size_t i = 0; i < ids.length(); ++i) {
              curId = ids[i];

              JS::Rooted<JS::PropertyDescriptor> desc(cx);
              if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                   &desc)) {
                return false;
              }

              if (!desc.object() /* == undefined in spec terms */ ||
                  !desc.enumerable()) {
                continue;
              }

              idVal = js::IdToValue(curId);
              nsString propName;
              // This will just throw if idVal is a Symbol, like the spec says
              // to do.
              if (!ConvertJSValueToString(cx, idVal, "key of element of value in argument 1", propName)) {
                return false;
              }

              if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
                return false;
              }

              Record<nsString, Record<nsString, Sequence<Sequence<JS::Value>>>>::EntryType* entry;
              if (!idsSeen.EnsureInserted(propName)) {
                // Find the existing entry.
                auto idx = recordEntries.IndexOf(propName);
                MOZ_ASSERT(idx != recordEntries.NoIndex,
                           "Why is it not found?");
                // Now blow it away to make it look like it was just added
                // to the array, because it's not obvious that it's
                // safe to write to its already-initialized mValue via our
                // normal codegen conversions.  For example, the value
                // could be a union and this would change its type, but
                // codegen assumes we won't do that.
                entry = recordEntries.ReconstructElementAt(idx);
              } else {
                // Safe to do an infallible append here, because we did a
                // SetCapacity above to the right capacity.
                entry = recordEntries.AppendElement();
              }
              entry->mKey = propName;
              Record<nsString, Sequence<Sequence<JS::Value>>>& slot = entry->mValue;
              if (temp.isObject()) {
                auto& recordEntries = slot.Entries();

                JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
                JS::RootedVector<jsid> ids(cx);
                if (!js::GetPropertyKeys(cx, recordObj,
                                         JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
                  return false;
                }
                if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
                  JS_ReportOutOfMemory(cx);
                  return false;
                }
                JS::Rooted<JS::Value> propNameValue(cx);
                JS::Rooted<JS::Value> temp(cx);
                JS::Rooted<jsid> curId(cx);
                JS::Rooted<JS::Value> idVal(cx);
                // Use a hashset to keep track of ids seen, to avoid
                // introducing nasty O(N^2) behavior scanning for them all the
                // time.  Ideally we'd use a data structure with O(1) lookup
                // _and_ ordering for the MozMap, but we don't have one lying
                // around.
                nsTHashtable<nsStringHashKey> idsSeen;
                for (size_t i = 0; i < ids.length(); ++i) {
                  curId = ids[i];

                  JS::Rooted<JS::PropertyDescriptor> desc(cx);
                  if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                       &desc)) {
                    return false;
                  }

                  if (!desc.object() /* == undefined in spec terms */ ||
                      !desc.enumerable()) {
                    continue;
                  }

                  idVal = js::IdToValue(curId);
                  nsString propName;
                  // This will just throw if idVal is a Symbol, like the spec says
                  // to do.
                  if (!ConvertJSValueToString(cx, idVal, "key of value in element of value in argument 1", propName)) {
                    return false;
                  }

                  if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
                    return false;
                  }

                  Record<nsString, Sequence<Sequence<JS::Value>>>::EntryType* entry;
                  if (!idsSeen.EnsureInserted(propName)) {
                    // Find the existing entry.
                    auto idx = recordEntries.IndexOf(propName);
                    MOZ_ASSERT(idx != recordEntries.NoIndex,
                               "Why is it not found?");
                    // Now blow it away to make it look like it was just added
                    // to the array, because it's not obvious that it's
                    // safe to write to its already-initialized mValue via our
                    // normal codegen conversions.  For example, the value
                    // could be a union and this would change its type, but
                    // codegen assumes we won't do that.
                    entry = recordEntries.ReconstructElementAt(idx);
                  } else {
                    // Safe to do an infallible append here, because we did a
                    // SetCapacity above to the right capacity.
                    entry = recordEntries.AppendElement();
                  }
                  entry->mKey = propName;
                  Sequence<Sequence<JS::Value>>& slot = entry->mValue;
                  if (temp.isObject()) {
                    JS::ForOfIterator iter4(cx);
                    if (!iter4.init(temp, JS::ForOfIterator::AllowNonIterable)) {
                      return false;
                    }
                    if (!iter4.valueIsIterable()) {
                      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in value in element of value in argument 1");
                      return false;
                    }
                    Sequence<Sequence<JS::Value>> &arr4 = slot;
                    JS::Rooted<JS::Value> temp4(cx);
                    while (true) {
                      bool done4;
                      if (!iter4.next(&temp4, &done4)) {
                        return false;
                      }
                      if (done4) {
                        break;
                      }
                      Sequence<JS::Value>* slotPtr4 = arr4.AppendElement(mozilla::fallible);
                      if (!slotPtr4) {
                        JS_ReportOutOfMemory(cx);
                        return false;
                      }
                      Sequence<JS::Value>& slot4 = *slotPtr4;
                      if (temp4.isObject()) {
                        JS::ForOfIterator iter5(cx);
                        if (!iter5.init(temp4, JS::ForOfIterator::AllowNonIterable)) {
                          return false;
                        }
                        if (!iter5.valueIsIterable()) {
                          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of value in value in element of value in argument 1");
                          return false;
                        }
                        Sequence<JS::Value> &arr5 = slot4;
                        JS::Rooted<JS::Value> temp5(cx);
                        while (true) {
                          bool done5;
                          if (!iter5.next(&temp5, &done5)) {
                            return false;
                          }
                          if (done5) {
                            break;
                          }
                          JS::Value* slotPtr5 = arr5.AppendElement(mozilla::fallible);
                          if (!slotPtr5) {
                            JS_ReportOutOfMemory(cx);
                            return false;
                          }
                          JS::Value& slot5 = *slotPtr5;
                          slot5 = temp5;
                        }
                      } else {
                        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of value in value in element of value in argument 1");
                        return false;
                      }
                    }
                  } else {
                    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in value in element of value in argument 1");
                    return false;
                  }
                }
              } else {
                cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in element of value in argument 1");
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of value in argument 1");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    for (auto& mapEntry0 : arg0.Entries()) {
      for (uint32_t indexName0 = 0; indexName0 < mapEntry0.mValue.Length(); ++indexName0) {
        for (auto& mapEntry1 : mapEntry0.mValue[indexName0].Entries()) {
          for (auto& mapEntry2 : mapEntry1.mValue.Entries()) {
            for (uint32_t indexName1 = 0; indexName1 < mapEntry2.mValue.Length(); ++indexName1) {
              for (uint32_t indexName2 = 0; indexName2 < mapEntry2.mValue[indexName1].Length(); ++indexName2) {
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&mapEntry2.mValue[indexName1][indexName2]))) {
                  return false;
                }
              }
            }
          }
        }
      }
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test5(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test5 constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static bool
_Test6(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Test6 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Test6", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Test6");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "Test6 constructor", 1)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  binding_detail::AutoSequence<Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>> arg0;
  SequenceRooter<Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>& slot = *slotPtr;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsCStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsCString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToByteString(cx, idVal, "key of element of argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsCString, Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>>& slot = entry->mValue;
          if (temp.isObject()) {
            JS::ForOfIterator iter2(cx);
            if (!iter2.init(temp, JS::ForOfIterator::AllowNonIterable)) {
              return false;
            }
            if (!iter2.valueIsIterable()) {
              cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in element of argument 1");
              return false;
            }
            Sequence<Sequence<Record<nsCString, Record<nsString, JS::Value>>>> &arr2 = slot;
            JS::Rooted<JS::Value> temp2(cx);
            while (true) {
              bool done2;
              if (!iter2.next(&temp2, &done2)) {
                return false;
              }
              if (done2) {
                break;
              }
              Sequence<Record<nsCString, Record<nsString, JS::Value>>>* slotPtr2 = arr2.AppendElement(mozilla::fallible);
              if (!slotPtr2) {
                JS_ReportOutOfMemory(cx);
                return false;
              }
              Sequence<Record<nsCString, Record<nsString, JS::Value>>>& slot2 = *slotPtr2;
              if (temp2.isObject()) {
                JS::ForOfIterator iter3(cx);
                if (!iter3.init(temp2, JS::ForOfIterator::AllowNonIterable)) {
                  return false;
                }
                if (!iter3.valueIsIterable()) {
                  cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of value in element of argument 1");
                  return false;
                }
                Sequence<Record<nsCString, Record<nsString, JS::Value>>> &arr3 = slot2;
                JS::Rooted<JS::Value> temp3(cx);
                while (true) {
                  bool done3;
                  if (!iter3.next(&temp3, &done3)) {
                    return false;
                  }
                  if (done3) {
                    break;
                  }
                  Record<nsCString, Record<nsString, JS::Value>>* slotPtr3 = arr3.AppendElement(mozilla::fallible);
                  if (!slotPtr3) {
                    JS_ReportOutOfMemory(cx);
                    return false;
                  }
                  Record<nsCString, Record<nsString, JS::Value>>& slot3 = *slotPtr3;
                  if (temp3.isObject()) {
                    auto& recordEntries = slot3.Entries();

                    JS::Rooted<JSObject*> recordObj(cx, &temp3.toObject());
                    JS::RootedVector<jsid> ids(cx);
                    if (!js::GetPropertyKeys(cx, recordObj,
                                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
                      return false;
                    }
                    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
                      JS_ReportOutOfMemory(cx);
                      return false;
                    }
                    JS::Rooted<JS::Value> propNameValue(cx);
                    JS::Rooted<JS::Value> temp(cx);
                    JS::Rooted<jsid> curId(cx);
                    JS::Rooted<JS::Value> idVal(cx);
                    // Use a hashset to keep track of ids seen, to avoid
                    // introducing nasty O(N^2) behavior scanning for them all the
                    // time.  Ideally we'd use a data structure with O(1) lookup
                    // _and_ ordering for the MozMap, but we don't have one lying
                    // around.
                    nsTHashtable<nsCStringHashKey> idsSeen;
                    for (size_t i = 0; i < ids.length(); ++i) {
                      curId = ids[i];

                      JS::Rooted<JS::PropertyDescriptor> desc(cx);
                      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                           &desc)) {
                        return false;
                      }

                      if (!desc.object() /* == undefined in spec terms */ ||
                          !desc.enumerable()) {
                        continue;
                      }

                      idVal = js::IdToValue(curId);
                      nsCString propName;
                      // This will just throw if idVal is a Symbol, like the spec says
                      // to do.
                      if (!ConvertJSValueToByteString(cx, idVal, "key of element of element of value in element of argument 1", propName)) {
                        return false;
                      }

                      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
                        return false;
                      }

                      Record<nsCString, Record<nsString, JS::Value>>::EntryType* entry;
                      if (!idsSeen.EnsureInserted(propName)) {
                        // Find the existing entry.
                        auto idx = recordEntries.IndexOf(propName);
                        MOZ_ASSERT(idx != recordEntries.NoIndex,
                                   "Why is it not found?");
                        // Now blow it away to make it look like it was just added
                        // to the array, because it's not obvious that it's
                        // safe to write to its already-initialized mValue via our
                        // normal codegen conversions.  For example, the value
                        // could be a union and this would change its type, but
                        // codegen assumes we won't do that.
                        entry = recordEntries.ReconstructElementAt(idx);
                      } else {
                        // Safe to do an infallible append here, because we did a
                        // SetCapacity above to the right capacity.
                        entry = recordEntries.AppendElement();
                      }
                      entry->mKey = propName;
                      Record<nsString, JS::Value>& slot = entry->mValue;
                      if (temp.isObject()) {
                        auto& recordEntries = slot.Entries();

                        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
                        JS::RootedVector<jsid> ids(cx);
                        if (!js::GetPropertyKeys(cx, recordObj,
                                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
                          return false;
                        }
                        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
                          JS_ReportOutOfMemory(cx);
                          return false;
                        }
                        JS::Rooted<JS::Value> propNameValue(cx);
                        JS::Rooted<JS::Value> temp(cx);
                        JS::Rooted<jsid> curId(cx);
                        JS::Rooted<JS::Value> idVal(cx);
                        // Use a hashset to keep track of ids seen, to avoid
                        // introducing nasty O(N^2) behavior scanning for them all the
                        // time.  Ideally we'd use a data structure with O(1) lookup
                        // _and_ ordering for the MozMap, but we don't have one lying
                        // around.
                        nsTHashtable<nsStringHashKey> idsSeen;
                        for (size_t i = 0; i < ids.length(); ++i) {
                          curId = ids[i];

                          JS::Rooted<JS::PropertyDescriptor> desc(cx);
                          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                               &desc)) {
                            return false;
                          }

                          if (!desc.object() /* == undefined in spec terms */ ||
                              !desc.enumerable()) {
                            continue;
                          }

                          idVal = js::IdToValue(curId);
                          nsString propName;
                          // This will just throw if idVal is a Symbol, like the spec says
                          // to do.
                          if (!ConvertJSValueToUSVString(cx, idVal, "key of value in element of element of value in element of argument 1", propName)) {
                            return false;
                          }

                          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
                            return false;
                          }

                          Record<nsString, JS::Value>::EntryType* entry;
                          if (!idsSeen.EnsureInserted(propName)) {
                            // Find the existing entry.
                            auto idx = recordEntries.IndexOf(propName);
                            MOZ_ASSERT(idx != recordEntries.NoIndex,
                                       "Why is it not found?");
                            // Now blow it away to make it look like it was just added
                            // to the array, because it's not obvious that it's
                            // safe to write to its already-initialized mValue via our
                            // normal codegen conversions.  For example, the value
                            // could be a union and this would change its type, but
                            // codegen assumes we won't do that.
                            entry = recordEntries.ReconstructElementAt(idx);
                          } else {
                            // Safe to do an infallible append here, because we did a
                            // SetCapacity above to the right capacity.
                            entry = recordEntries.AppendElement();
                          }
                          entry->mKey = propName;
                          JS::Value& slot = entry->mValue;
                          slot = temp;
                        }
                      } else {
                        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in element of element of value in element of argument 1");
                        return false;
                      }
                    }
                  } else {
                    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of value in element of argument 1");
                    return false;
                  }
                }
              } else {
                cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of value in element of argument 1");
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in element of argument 1");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    for (uint32_t indexName0 = 0; indexName0 < arg0.Length(); ++indexName0) {
      for (auto& mapEntry0 : arg0[indexName0].Entries()) {
        for (uint32_t indexName1 = 0; indexName1 < mapEntry0.mValue.Length(); ++indexName1) {
          for (uint32_t indexName2 = 0; indexName2 < mapEntry0.mValue[indexName1].Length(); ++indexName2) {
            for (auto& mapEntry1 : mapEntry0.mValue[indexName1][indexName2].Entries()) {
              for (auto& mapEntry2 : mapEntry1.mValue.Entries()) {
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&mapEntry2.mValue))) {
                  return false;
                }
              }
            }
          }
        }
      }
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Test6(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Test6 constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReadonlyByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyByte_getterinfo = {
  { get_readonlyByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->WritableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableByte_getterinfo = {
  { get_writableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableByte_setterinfo = {
  { (JSJitGetterOp)set_writableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passByte", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByte_methodinfo = {
  { (JSJitGetterOp)passByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReceiveByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveByte_methodinfo = {
  { (JSJitGetterOp)receiveByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByte_methodinfo = {
  { (JSJitGetterOp)passOptionalByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByteBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passOptionalByteBeforeRequired", 2)) {
    return false;
  }
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteBeforeRequired },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByteWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefaultBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByteWithDefaultBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passOptionalByteWithDefaultBeforeRequired", 2)) {
    return false;
  }
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefaultBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefaultBeforeRequired },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableByte", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByte_methodinfo = {
  { (JSJitGetterOp)passNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<int8_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value().SetValue())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByte_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<int8_t> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      int8_t& slot = *arg0.AppendElement();
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[variadicArg], "Argument 1", &slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByte_methodinfo = {
  { (JSJitGetterOp)passVariadicByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

static bool
get_cachedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "cachedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 0) : (DOM_INSTANCE_RESERVED_SLOTS + 0);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedByte_getterinfo = {
  { get_cachedByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 0)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) < 16, "There is no slot for us");

static bool
get_cachedConstantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "cachedConstantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 1) : (DOM_INSTANCE_RESERVED_SLOTS + 1);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedConstantByte_getterinfo = {
  { get_cachedConstantByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 1)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < 16, "There is no slot for us");

static bool
get_cachedWritableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "cachedWritableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 2) : (DOM_INSTANCE_RESERVED_SLOTS + 2);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedWritableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_cachedWritableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "cachedWritableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCachedWritableByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCachedWritableByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedCachedWritableByteValue(cx, self);
  return true;
}

static const JSJitInfo cachedWritableByte_getterinfo = {
  { get_cachedWritableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 2)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) < 16, "There is no slot for us");
static const JSJitInfo cachedWritableByte_setterinfo = {
  { (JSJitGetterOp)set_cachedWritableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->SideEffectFreeByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo sideEffectFreeByte_getterinfo = {
  { get_sideEffectFreeByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo sideEffectFreeByte_setterinfo = {
  { (JSJitGetterOp)set_sideEffectFreeByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->DomDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDomDependentByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDomDependentByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo domDependentByte_getterinfo = {
  { get_domDependentByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo domDependentByte_setterinfo = {
  { (JSJitGetterOp)set_domDependentByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_constantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "constantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo constantByte_getterinfo = {
  { get_constantByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "deviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->DeviceStateDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deviceStateDependentByte_getterinfo = {
  { get_deviceStateDependentByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnByteSideEffectFree(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "returnByteSideEffectFree", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnByteSideEffectFree());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnByteSideEffectFree_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnByteSideEffectFree_methodinfo = {
  {
    { (JSJitGetterOp)returnByteSideEffectFree },
    { prototypes::id::TestInterface },
    { PrototypeTraits<prototypes::id::TestInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnByteSideEffectFree_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDOMDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "returnDOMDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnDOMDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDOMDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDOMDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDOMDependentByte },
    { prototypes::id::TestInterface },
    { PrototypeTraits<prototypes::id::TestInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDOMDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnConstantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "returnConstantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnConstantByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnConstantByte_methodinfo = {
  {
    { (JSJitGetterOp)returnConstantByte },
    { prototypes::id::TestInterface },
    { PrototypeTraits<prototypes::id::TestInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnConstantByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDeviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "returnDeviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnDeviceStateDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDeviceStateDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDeviceStateDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDeviceStateDependentByte },
    { prototypes::id::TestInterface },
    { PrototypeTraits<prototypes::id::TestInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDeviceStateDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->ReadonlyShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyShort_getterinfo = {
  { get_readonlyShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->WritableShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableShort_getterinfo = {
  { get_writableShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableShort_setterinfo = {
  { (JSJitGetterOp)set_writableShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passShort", 1)) {
    return false;
  }
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passShort_methodinfo = {
  { (JSJitGetterOp)passShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->ReceiveShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveShort_methodinfo = {
  { (JSJitGetterOp)receiveShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<int16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShort_methodinfo = {
  { (JSJitGetterOp)passOptionalShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 5;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalShortWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->ReadonlyLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyLong_getterinfo = {
  { get_readonlyLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->WritableLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLong_getterinfo = {
  { get_writableLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableLong_setterinfo = {
  { (JSJitGetterOp)set_writableLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passLong", 1)) {
    return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLong_methodinfo = {
  { (JSJitGetterOp)passLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->ReceiveLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveLong_methodinfo = {
  { (JSJitGetterOp)receiveLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 7;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->ReadonlyLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyLongLong_getterinfo = {
  { get_readonlyLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->WritableLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLongLong_getterinfo = {
  { get_writableLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passLongLong", 1)) {
    return false;
  }
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLongLong_methodinfo = {
  { (JSJitGetterOp)passLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->ReceiveLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveLongLong_methodinfo = {
  { (JSJitGetterOp)receiveLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<int64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = -12LL;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLongWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->ReadonlyOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyOctet_getterinfo = {
  { get_readonlyOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->WritableOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableOctet(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableOctet(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableOctet_getterinfo = {
  { get_writableOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableOctet_setterinfo = {
  { (JSJitGetterOp)set_writableOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passOctet", 1)) {
    return false;
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOctet(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOctet(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOctet_methodinfo = {
  { (JSJitGetterOp)passOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->ReceiveOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveOctet_methodinfo = {
  { (JSJitGetterOp)receiveOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<uint8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctet_methodinfo = {
  { (JSJitGetterOp)passOptionalOctet },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctetWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalOctetWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 19;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctetWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalOctetWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->ReadonlyUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyUnsignedShort_getterinfo = {
  { get_readonlyUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->WritableUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedShort_getterinfo = {
  { get_writableUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedShort_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnsignedShort", 1)) {
    return false;
  }
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->ReceiveUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveUnsignedShort_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<uint16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShort },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 2;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShortWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->ReadonlyUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo readonlyUnsignedLong_getterinfo = {
  { get_readonlyUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->WritableUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLong_getterinfo = {
  { get_writableUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnsignedLong", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->ReceiveUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo receiveUnsignedLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<uint32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 6U;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->ReadonlyUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyUnsignedLongLong_getterinfo = {
  { get_readonlyUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->WritableUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLongLong_getterinfo = {
  { get_writableUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnsignedLongLong", 1)) {
    return false;
  }
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->ReceiveUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<uint64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnsignedLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  uint64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 17ULL;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLongWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float result(MOZ_KnownLive(self)->WritableFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableFloat(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableFloat(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableFloat_getterinfo = {
  { get_writableFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float result(MOZ_KnownLive(self)->WritableUnrestrictedFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedFloat_getterinfo = {
  { get_writableUnrestrictedFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableNullableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableFloat_getterinfo = {
  { get_writableNullableFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedFloat_getterinfo = {
  { get_writableNullableUnrestrictedFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  double result(MOZ_KnownLive(self)->WritableDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableDouble(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableDouble(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableDouble_getterinfo = {
  { get_writableDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  double result(MOZ_KnownLive(self)->WritableUnrestrictedDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedDouble_getterinfo = {
  { get_writableUnrestrictedDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableNullableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableDouble_getterinfo = {
  { get_writableNullableDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedDouble_getterinfo = {
  { get_writableNullableUnrestrictedDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedDouble },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passFloat", 16)) {
    return false;
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 7");
    return false;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 9");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 11");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 13");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 15");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat_methodinfo = {
  { (JSJitGetterOp)passFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLenientFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passLenientFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passLenientFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passLenientFloat", 16)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLenientFloat_methodinfo = {
  { (JSJitGetterOp)passLenientFloat },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientFloatAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float result(MOZ_KnownLive(self)->LenientFloatAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientFloatAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.lenientFloatAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientFloatAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientFloatAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientFloatAttr_getterinfo = {
  { get_lenientFloatAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo lenientFloatAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientFloatAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientDoubleAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  double result(MOZ_KnownLive(self)->LenientDoubleAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientDoubleAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.lenientDoubleAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientDoubleAttr_getterinfo = {
  { get_lenientDoubleAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo lenientDoubleAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientDoubleAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnrestricted(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnrestricted", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  float arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0.0F;
  }
  float arg1;
  if (args.hasDefined(1)) {
    if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
      return false;
    }
  } else {
    arg1 = mozilla::PositiveInfinity<float>();
  }
  float arg2;
  if (args.hasDefined(2)) {
    if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2)) {
      return false;
    }
  } else {
    arg2 = mozilla::NegativeInfinity<float>();
  }
  float arg3;
  if (args.hasDefined(3)) {
    if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3)) {
      return false;
    }
  } else {
    arg3 = mozilla::UnspecifiedNaN<float>();
  }
  double arg4;
  if (args.hasDefined(4)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
      return false;
    }
  } else {
    arg4 = 0.0;
  }
  double arg5;
  if (args.hasDefined(5)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
      return false;
    }
  } else {
    arg5 = mozilla::PositiveInfinity<double>();
  }
  double arg6;
  if (args.hasDefined(6)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6)) {
      return false;
    }
  } else {
    arg6 = mozilla::NegativeInfinity<double>();
  }
  double arg7;
  if (args.hasDefined(7)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7)) {
      return false;
    }
  } else {
    arg7 = mozilla::UnspecifiedNaN<double>();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnrestricted(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnrestricted(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnrestricted_methodinfo = {
  { (JSJitGetterOp)passUnrestricted },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveSelf_methodinfo = {
  { (JSJitGetterOp)receiveSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveNullableSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveWeakSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSelf", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSelf_methodinfo = {
  { (JSJitGetterOp)passSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableSelf", 1)) {
    return false;
  }
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSelf_methodinfo = {
  { (JSJitGetterOp)passNullableSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->NonNullSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nonNullSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullSelf_getterinfo = {
  { get_nonNullSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullSelf_setterinfo = {
  { (JSJitGetterOp)set_nonNullSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->GetNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nullableSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableSelf_getterinfo = {
  { get_nullableSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableSelf_setterinfo = {
  { (JSJitGetterOp)set_nullableSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_cachedSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "cachedSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> slotStorage(cx, js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false));
  MOZ_ASSERT(IsDOMObject(slotStorage));
  const size_t slotIndex = (DOM_INSTANCE_RESERVED_SLOTS + 3);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->CachedSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    PreserveWrapper(self);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedSelf_getterinfo = {
  { get_cachedSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 3)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<mozilla::dom::TestInterface*> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNonNullSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<NonNull<mozilla::dom::TestInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullSelf },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelfWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSelfWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSelfWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  mozilla::dom::TestInterface* arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelfWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalSelfWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveExternal_methodinfo = {
  { (JSJitGetterOp)receiveExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveNullableExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passExternal", 1)) {
    return false;
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternal_methodinfo = {
  { (JSJitGetterOp)passExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableExternal", 1)) {
    return false;
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternal_methodinfo = {
  { (JSJitGetterOp)passNullableExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->NonNullExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nonNullExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullExternal_getterinfo = {
  { get_nonNullExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullExternal_setterinfo = {
  { (JSJitGetterOp)set_nonNullExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->GetNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nullableExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableExternal_getterinfo = {
  { get_nullableExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableExternal_setterinfo = {
  { (JSJitGetterOp)set_nullableExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNonNullExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullExternal },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternalWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalExternalWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalExternalWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder);
      arg0 = arg0_holder;
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternalWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalExternalWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveWeakNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCallbackInterface", 1)) {
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCallbackInterface", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passNullableCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->NonNullCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nonNullCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullCallbackInterface_getterinfo = {
  { get_nonNullCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nonNullCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->GetNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.nullableCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableCallbackInterface_getterinfo = {
  { get_nullableCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nullableCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<RefPtr<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNonNullCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<OwningNonNull<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullCallbackInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterfaceWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalCallbackInterfaceWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalCallbackInterfaceWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterfaceWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterfaceWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 4) : (DOM_INSTANCE_RESERVED_SLOTS + 4);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlySequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlySequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(result[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlySequence_getterinfo = {
  { get_readonlySequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 4)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 4) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 4) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlySequenceOfDictionaries(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlySequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 5) : (DOM_INSTANCE_RESERVED_SLOTS + 5);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<Dict> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlySequenceOfDictionaries(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlySequenceOfDictionaries(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlySequenceOfDictionaries_getterinfo = {
  { get_readonlySequenceOfDictionaries },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 5)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 5) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 5) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyNullableSequenceOfDictionaries(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyNullableSequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 6) : (DOM_INSTANCE_RESERVED_SLOTS + 6);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  Nullable<nsTArray<Dict>> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyNullableSequenceOfDictionaries(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyNullableSequenceOfDictionaries(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }

      uint32_t length = result.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result.Value()[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyNullableSequenceOfDictionaries_getterinfo = {
  { get_readonlyNullableSequenceOfDictionaries },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 6)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 6) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 6) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyFrozenSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 7) : (DOM_INSTANCE_RESERVED_SLOTS + 7);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<Dict> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenSequence_getterinfo = {
  { get_readonlyFrozenSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 7)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 7) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 7) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyFrozenNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 8) : (DOM_INSTANCE_RESERVED_SLOTS + 8);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  Nullable<nsTArray<Dict>> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenNullableSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenNullableSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }

      uint32_t length = result.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result.Value()[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
    if (args.rval().isObject()) {
      JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
      if (!JS_FreezeObject(cx, rvalObj)) {
        return false;
      }
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenNullableSequence_getterinfo = {
  { get_readonlyFrozenNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 8)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 8) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 8) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequence_methodinfo = {
  { (JSJitGetterOp)receiveSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveSequenceOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result.Value()[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequenceOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<int32_t> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<int32_t> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequence_methodinfo = {
  { (JSJitGetterOp)passSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<int32_t> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfNullableInts", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<int32_t>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Sequence<Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCallbackObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
          tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
          if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
            return false;
          }
          break;
        } else {
          tmp.setNull();
          break;
        }
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveWeakNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCastableObjectSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCastableObjectSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCastableObjectNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCastableObjectNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::AutoSequence<int32_t> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      binding_detail::AutoSequence<int32_t> &arr = arg0;
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    /* arg0 array is already empty; nothing to do */
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Sequence<OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passExternalInterfaceSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableExternalInterfaceSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveStringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveStringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveStringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passStringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passStringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passStringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassStringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassStringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passStringSequence_methodinfo = {
  { (JSJitGetterOp)passStringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByteStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveByteStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveByteStringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveByteStringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidByteStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveByteStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveByteStringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteStringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passByteStringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passByteStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passByteStringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsCString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsCString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToByteString(cx, temp, false, "element of argument 1", slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteStringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteStringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteStringSequence_methodinfo = {
  { (JSJitGetterOp)passByteStringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUTF8StringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUTF8StringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidUTF8StringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveUTF8StringSequence_methodinfo = {
  { (JSJitGetterOp)receiveUTF8StringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8StringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUTF8StringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUTF8StringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUTF8StringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsCString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsCString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8StringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8StringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8StringSequence_methodinfo = {
  { (JSJitGetterOp)passUTF8StringSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<JS::Value> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnySequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnySequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result[sequenceIdx0]);
        tmp.set(result[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveAnySequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<nsTArray<JS::Value>> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableAnySequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableAnySequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result.Value()[sequenceIdx0]);
        tmp.set(result.Value()[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableAnySequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnySequenceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveAnySequenceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsTArray<JS::Value>> result;
  SequenceRooter<nsTArray<JS::Value> > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnySequenceSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnySequenceSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {

        uint32_t length = result[sequenceIdx0].Length();
        JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
        if (!returnArray) {
          return false;
        }
        // Scope for 'tmp'
        {
          JS::Rooted<JS::Value> tmp(cx);
          for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
            // Control block to let us common up the JS_DefineElement calls when there
            // are different ways to succeed at wrapping the object.
            do {
              JS::ExposeValueToActiveJS(result[sequenceIdx0][sequenceIdx1]);
              tmp.set(result[sequenceIdx0][sequenceIdx1]);
              if (!MaybeWrapValue(cx, &tmp)) {
                return false;
              }
              break;
            } while (false);
            if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                  JSPROP_ENUMERATE)) {
              return false;
            }
          }
        }
        tmp.setObject(*returnArray);
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveAnySequenceSequence_methodinfo = {
  { (JSJitGetterOp)receiveAnySequenceSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObjectSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObjectSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
        tmp.setObject(*result[sequenceIdx0]);
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObjectSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObjectSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
                      JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
                    }
                    tmp.setObjectOrNull(result[sequenceIdx0]);
        if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableObjectSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfSequences", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<int32_t>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<int32_t> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          int32_t* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          int32_t& slot1 = *slotPtr1;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp1, "Element of element of argument 1", &slot1)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequences },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequencesOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfSequencesOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfSequencesOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfSequencesOfSequences", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<Sequence<int32_t>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<Sequence<int32_t>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<Sequence<int32_t>> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          Sequence<int32_t>* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          Sequence<int32_t>& slot1 = *slotPtr1;
          if (temp1.isObject()) {
            JS::ForOfIterator iter2(cx);
            if (!iter2.init(temp1, JS::ForOfIterator::AllowNonIterable)) {
              return false;
            }
            if (!iter2.valueIsIterable()) {
              cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
              return false;
            }
            Sequence<int32_t> &arr2 = slot1;
            JS::Rooted<JS::Value> temp2(cx);
            while (true) {
              bool done2;
              if (!iter2.next(&temp2, &done2)) {
                return false;
              }
              if (done2) {
                break;
              }
              int32_t* slotPtr2 = arr2.AppendElement(mozilla::fallible);
              if (!slotPtr2) {
                JS_ReportOutOfMemory(cx);
                return false;
              }
              int32_t& slot2 = *slotPtr2;
              if (!ValueToPrimitive<int32_t, eDefault>(cx, temp2, "Element of element of element of argument 1", &slot2)) {
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequencesOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequencesOfSequences },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequenceOfSequences(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveSequenceOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsTArray<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequenceOfSequences(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequenceOfSequences(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {

        uint32_t length = result[sequenceIdx0].Length();
        JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
        if (!returnArray) {
          return false;
        }
        // Scope for 'tmp'
        {
          JS::Rooted<JS::Value> tmp(cx);
          for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
            // Control block to let us common up the JS_DefineElement calls when there
            // are different ways to succeed at wrapping the object.
            do {
              tmp.setInt32(int32_t(result[sequenceIdx0][sequenceIdx1]));
              break;
            } while (false);
            if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                  JSPROP_ENUMERATE)) {
              return false;
            }
          }
        }
        tmp.setObject(*returnArray);
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequenceOfSequences_methodinfo = {
  { (JSJitGetterOp)receiveSequenceOfSequences },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequenceOfSequencesOfSequences(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveSequenceOfSequencesOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsTArray<nsTArray<nsTArray<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequenceOfSequencesOfSequences(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequenceOfSequencesOfSequences(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {

        uint32_t length = result[sequenceIdx0].Length();
        JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
        if (!returnArray) {
          return false;
        }
        // Scope for 'tmp'
        {
          JS::Rooted<JS::Value> tmp(cx);
          for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
            // Control block to let us common up the JS_DefineElement calls when there
            // are different ways to succeed at wrapping the object.
            do {

              uint32_t length = result[sequenceIdx0][sequenceIdx1].Length();
              JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
              if (!returnArray) {
                return false;
              }
              // Scope for 'tmp'
              {
                JS::Rooted<JS::Value> tmp(cx);
                for (uint32_t sequenceIdx2 = 0; sequenceIdx2 < length; ++sequenceIdx2) {
                  // Control block to let us common up the JS_DefineElement calls when there
                  // are different ways to succeed at wrapping the object.
                  do {
                    tmp.setInt32(int32_t(result[sequenceIdx0][sequenceIdx1][sequenceIdx2]));
                    break;
                  } while (false);
                  if (!JS_DefineElement(cx, returnArray, sequenceIdx2, tmp,
                                        JSPROP_ENUMERATE)) {
                    return false;
                  }
                }
              }
              tmp.setObject(*returnArray);
              break;
            } while (false);
            if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                  JSPROP_ENUMERATE)) {
              return false;
            }
          }
        }
        tmp.setObject(*returnArray);
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequenceOfSequencesOfSequences_methodinfo = {
  { (JSJitGetterOp)receiveSequenceOfSequencesOfSequences },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecord", 1)) {
    return false;
  }
  Record<nsString, int32_t> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecord_methodinfo = {
  { (JSJitGetterOp)passRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfNullableInts", 1)) {
    return false;
  }
  Record<nsString, Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<int32_t>& slot = entry->mValue;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Record<nsString, Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCastableObjectRecord", 1)) {
    return false;
  }
  Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCastableObjectRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCastableObjectNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCastableObjectNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, RefPtr<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Record<nsString, int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecordWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecordWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passExternalInterfaceRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableExternalInterfaceRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passStringRecord", 1)) {
    return false;
  }
  Record<nsString, nsString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassStringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassStringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passStringRecord_methodinfo = {
  { (JSJitGetterOp)passStringRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passByteStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passByteStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passByteStringRecord", 1)) {
    return false;
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToByteString(cx, temp, false, "value in argument 1", slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteStringRecord_methodinfo = {
  { (JSJitGetterOp)passByteStringRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8StringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUTF8StringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUTF8StringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUTF8StringRecord", 1)) {
    return false;
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8StringRecord_methodinfo = {
  { (JSJitGetterOp)passUTF8StringRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecords(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfRecords");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfRecords", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfRecords", 1)) {
    return false;
  }
  Record<nsString, Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, int32_t>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, int32_t>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          int32_t& slot = entry->mValue;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in value in argument 1", &slot)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecords_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecords },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Record<nsString, int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecord(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecord(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecord_methodinfo = {
  { (JSJitGetterOp)receiveRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Record<nsString, int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecord(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecord(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecord_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Record<nsString, Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveRecordOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Record<nsString, Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecordOfNullableInts },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecordOfRecords(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveRecordOfRecords", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Record<nsString, Record<nsString, int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecordOfRecords(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecordOfRecords(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {

        JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
        if (!returnObj) {
          return false;
        }
        // Scope for 'tmp'
        {
          JS::Rooted<JS::Value> tmp(cx);
          for (auto& entry : recordValue0.Entries()) {
            auto& recordValue1 = entry.mValue;
            // Control block to let us common up the JS_DefineUCProperty calls when there
            // are different ways to succeed at wrapping the value.
            do {
              tmp.setInt32(int32_t(recordValue1));
              break;
            } while (false);
            if (!JS_DefineUCProperty(cx, returnObj,
                                     entry.mKey.BeginReading(),
                                     entry.mKey.Length(), tmp,
                                     JSPROP_ENUMERATE)) {
              return false;
            }
          }
        }
        tmp.setObject(*returnObj);
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecordOfRecords_methodinfo = {
  { (JSJitGetterOp)receiveRecordOfRecords },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnyRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveAnyRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Record<nsString, JS::Value> result;
  RecordRooter<nsString, JS::Value> resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnyRecord(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnyRecord(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        JS::ExposeValueToActiveJS(recordValue0);
        tmp.set(recordValue0);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveAnyRecord_methodinfo = {
  { (JSJitGetterOp)receiveAnyRecord },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passNullableArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<ArrayBuffer> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      if (!arg0.Value().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<ArrayBuffer>> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      if (!arg0.Value().SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBufferWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableArrayBufferWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableArrayBufferWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (!arg0.SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBufferWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBufferWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passInt8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passInt8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passInt8Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt8Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt8Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt8Array_methodinfo = {
  { (JSJitGetterOp)passInt8Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passInt16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passInt16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passInt16Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt16Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt16Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt16Array_methodinfo = {
  { (JSJitGetterOp)passInt16Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passInt32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passInt32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passInt32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt32Array_methodinfo = {
  { (JSJitGetterOp)passInt32Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUint8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUint8Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8Array_methodinfo = {
  { (JSJitGetterOp)passUint8Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUint16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUint16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUint16Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint16Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint16Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint16Array_methodinfo = {
  { (JSJitGetterOp)passUint16Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUint32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUint32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUint32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint32Array_methodinfo = {
  { (JSJitGetterOp)passUint32Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8ClampedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUint8ClampedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUint8ClampedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUint8ClampedArray", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint8ClampedArray> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8ClampedArray");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8ClampedArray_methodinfo = {
  { (JSJitGetterOp)passUint8ClampedArray },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passFloat32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passFloat32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passFloat32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Float32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat32Array_methodinfo = {
  { (JSJitGetterOp)passFloat32Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat64Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passFloat64Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passFloat64Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passFloat64Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Float64Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float64Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat64Array_methodinfo = {
  { (JSJitGetterOp)passFloat64Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfArrayBuffers", 1)) {
    return false;
  }
  binding_detail::AutoSequence<ArrayBuffer> arg0;
  SequenceRooter<ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<ArrayBuffer> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      ArrayBuffer* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      ArrayBuffer& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfArrayBuffers },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfNullableArrayBuffers", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<ArrayBuffer>> arg0;
  SequenceRooter<Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<ArrayBuffer>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<ArrayBuffer>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<ArrayBuffer>& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableArrayBuffers },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfArrayBuffers", 1)) {
    return false;
  }
  Record<nsString, ArrayBuffer> arg0;
  RecordRooter<nsString, ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, ArrayBuffer>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      ArrayBuffer& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfArrayBuffers },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfNullableArrayBuffers", 1)) {
    return false;
  }
  Record<nsString, Nullable<ArrayBuffer>> arg0;
  RecordRooter<nsString, Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<ArrayBuffer>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<ArrayBuffer>& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableArrayBuffers },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<Float32Array> arg0;
  SequenceRooter<Float32Array> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Float32Array& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicTypedArray },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicNullableTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicNullableTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<Nullable<Float32Array>> arg0;
  SequenceRooter<Nullable<Float32Array>> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<Float32Array>& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.SetValue().Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32ArrayOrNull");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableTypedArray },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUint8Array(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUint8Array(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUint8Array(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUint8Array_methodinfo = {
  { (JSJitGetterOp)receiveUint8Array },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_uint8ArrayAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetUint8ArrayAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetUint8ArrayAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_uint8ArrayAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.uint8ArrayAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value being assigned");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo uint8ArrayAttr_getterinfo = {
  { get_uint8ArrayAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo uint8ArrayAttr_setterinfo = {
  { (JSJitGetterOp)set_uint8ArrayAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passString", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passString_methodinfo = {
  { (JSJitGetterOp)passString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableString", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableString_methodinfo = {
  { (JSJitGetterOp)passNullableString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalString_methodinfo = {
  { (JSJitGetterOp)passOptionalString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicString_methodinfo = {
  { (JSJitGetterOp)passVariadicString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveString(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveString(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveString_methodinfo = {
  { (JSJitGetterOp)receiveString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passByteString", 1)) {
    return false;
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteString_methodinfo = {
  { (JSJitGetterOp)passByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableByteString", 1)) {
    return false;
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByteString_methodinfo = {
  { (JSJitGetterOp)passNullableByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalByteStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToByteString(cx, args[variadicArg], false, "argument 1", slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByteString_methodinfo = {
  { (JSJitGetterOp)passVariadicByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalUnionByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnionByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<ByteStringOrLong> arg0;
  Maybe<ByteStringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalUnionByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnionByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  ByteStringOrLong arg0;
  ByteStringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUTF8String", 1)) {
    return false;
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8String_methodinfo = {
  { (JSJitGetterOp)passUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableUTF8String", 1)) {
    return false;
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passNullableUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8StringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8StringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUTF8String_methodinfo = {
  { (JSJitGetterOp)passVariadicUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8String(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalUnionUTF8String");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnionUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<UTF8StringOrLong> arg0;
  Maybe<UTF8StringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8String },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8StringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalUnionUTF8StringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnionUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UTF8StringOrLong arg0;
  UTF8StringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8StringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUSVS", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUSVS_methodinfo = {
  { (JSJitGetterOp)passUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableUSVS", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUSVS_methodinfo = {
  { (JSJitGetterOp)passNullableUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUSVSWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUSVSWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUSVSWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUSVSWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUSVSWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUSVSWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
      if (!NormalizeUSVString(slot)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUSVS_methodinfo = {
  { (JSJitGetterOp)passVariadicUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUSVS(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUSVS(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUSVS_methodinfo = {
  { (JSJitGetterOp)receiveUSVS },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passJSString", 1)) {
    return false;
  }
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassJSString(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassJSString(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passJSString_methodinfo = {
  { (JSJitGetterOp)passJSString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalJSStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalJSStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSString*> arg0(cx);
  if (args.hasDefined(0)) {
    if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
      return false;
    }
  } else {
    static const char data[] = { 'a', 'b', 'c', 0 };
    arg0 = JS_NewStringCopyN(cx, data, ArrayLength(data) - 1);
    if (!arg0) {
        return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalJSStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalJSStringWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveJSString(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveJSString(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveJSString_methodinfo = {
  { (JSJitGetterOp)receiveJSString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyJSStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyJSStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyJSStringAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyJSStringAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyJSStringAttr_getterinfo = {
  { get_readonlyJSStringAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetJsStringAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetJsStringAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetJsStringAttr(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetJsStringAttr(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo jsStringAttr_getterinfo = {
  { get_jsStringAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo jsStringAttr_setterinfo = {
  { (JSJitGetterOp)set_jsStringAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passEnum", 1)) {
    return false;
  }
  TestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
      return false;
    }
    MOZ_ASSERT(index >= 0);
    arg0 = static_cast<TestEnum>(index);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnum(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnum(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnum_methodinfo = {
  { (JSJitGetterOp)passEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableEnum", 1)) {
    return false;
  }
  Nullable<TestEnum> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.SetValue() = static_cast<TestEnum>(index);
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableEnum_methodinfo = {
  { (JSJitGetterOp)passNullableEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<TestEnum> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.Value() = static_cast<TestEnum>(index);
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnumWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passEnumWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passEnumWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  TestEnum arg0;
  if (args.hasDefined(0)) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0 = static_cast<TestEnum>(index);
    }
  } else {
    arg0 = TestEnum::A;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnumWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnumWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnumWithDefault_methodinfo = {
  { (JSJitGetterOp)passEnumWithDefault },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<TestEnum>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.Value().SetValue() = static_cast<TestEnum>(index);
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableEnumWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableEnumWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<TestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<TestEnum>(index);
      }
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableEnumWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableEnumWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<TestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<TestEnum>(index);
      }
    }
  } else {
    arg0.SetValue() = TestEnum::A;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->ReceiveEnum());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveEnum_methodinfo = {
  { (JSJitGetterOp)receiveEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<TestEnum> result(MOZ_KnownLive(self)->ReceiveNullableEnum());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  } else {
    if (!ToJSValue(cx, result.Value(), args.rval())) {
      return false;
    }
    return true;
  }
}

static const JSJitInfo receiveNullableEnum_methodinfo = {
  { (JSJitGetterOp)receiveNullableEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->EnumAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enumAttribute(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.enumAttribute setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  TestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<false>(cx, args[0], TestEnumValues::strings, "TestEnum", "value being assigned", &index)) {
      return false;
    }
    if (index < 0) {
      return true;
    }
    arg0 = static_cast<TestEnum>(index);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnumAttribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnumAttribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enumAttribute_getterinfo = {
  { get_enumAttribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enumAttribute_setterinfo = {
  { (JSJitGetterOp)set_enumAttribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyEnumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyEnumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->ReadonlyEnumAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyEnumAttribute_getterinfo = {
  { get_readonlyEnumAttribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passCallback", 1)) {
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallback_methodinfo = {
  { (JSJitGetterOp)passCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableCallback", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallback_methodinfo = {
  { (JSJitGetterOp)passNullableCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<OwningNonNull<TestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<RefPtr<TestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallbackWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RefPtr<TestCallback> result(MOZ_KnownLive(self)->ReceiveCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallback_methodinfo = {
  { (JSJitGetterOp)receiveCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RefPtr<TestCallback> result(MOZ_KnownLive(self)->ReceiveNullableCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallback_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableTreatAsNullCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableTreatAsNullCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableTreatAsNullCallback", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableTreatAsNullCallback_methodinfo = {
  { (JSJitGetterOp)passNullableTreatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableTreatAsNullCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableTreatAsNullCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<RefPtr<TestTreatAsNullCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestTreatAsNullCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableTreatAsNullCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableTreatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableTreatAsNullCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableTreatAsNullCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableTreatAsNullCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableTreatAsNullCallbackWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_treatAsNullCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "treatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RefPtr<TestTreatAsNullCallback> result(MOZ_KnownLive(self)->TreatAsNullCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_treatAsNullCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.treatAsNullCallback setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "treatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<OwningNonNull<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTreatAsNullCallback(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetTreatAsNullCallback(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo treatAsNullCallback_getterinfo = {
  { get_treatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo treatAsNullCallback_setterinfo = {
  { (JSJitGetterOp)set_treatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableTreatAsNullCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RefPtr<TestTreatAsNullCallback> result(MOZ_KnownLive(self)->GetNullableTreatAsNullCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableTreatAsNullCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args[0].isObject() && JS::IsCallable(&args[0].toObject())) {
  { // scope for tempRoot and tempGlobalRoot if needed
    arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
  }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableTreatAsNullCallback_getterinfo = {
  { get_nullableTreatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableTreatAsNullCallback_setterinfo = {
  { (JSJitGetterOp)set_nullableTreatAsNullCallback },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
forceCallbackGeneration(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.forceCallbackGeneration");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "forceCallbackGeneration", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.forceCallbackGeneration", 38)) {
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestIntegerReturn>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestIntegerReturn(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableIntegerReturn>> arg1(cx);
  if (args[1].isObject()) {
    if (JS::IsCallable(&args[1].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg1 = new binding_detail::FastTestNullableIntegerReturn(&args[1].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 2");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestBooleanReturn>> arg2(cx);
  if (args[2].isObject()) {
    if (JS::IsCallable(&args[2].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg2 = new binding_detail::FastTestBooleanReturn(&args[2].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 3");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestFloatReturn>> arg3(cx);
  if (args[3].isObject()) {
    if (JS::IsCallable(&args[3].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg3 = new binding_detail::FastTestFloatReturn(&args[3].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 4");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 4");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestStringReturn>> arg4(cx);
  if (args[4].isObject()) {
    if (JS::IsCallable(&args[4].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg4 = new binding_detail::FastTestStringReturn(&args[4].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 5");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 5");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestEnumReturn>> arg5(cx);
  if (args[5].isObject()) {
    if (JS::IsCallable(&args[5].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg5 = new binding_detail::FastTestEnumReturn(&args[5].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 6");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 6");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestInterfaceReturn>> arg6(cx);
  if (args[6].isObject()) {
    if (JS::IsCallable(&args[6].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg6 = new binding_detail::FastTestInterfaceReturn(&args[6].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 7");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 7");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableInterfaceReturn>> arg7(cx);
  if (args[7].isObject()) {
    if (JS::IsCallable(&args[7].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg7 = new binding_detail::FastTestNullableInterfaceReturn(&args[7].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 8");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 8");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestExternalInterfaceReturn>> arg8(cx);
  if (args[8].isObject()) {
    if (JS::IsCallable(&args[8].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg8 = new binding_detail::FastTestExternalInterfaceReturn(&args[8].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 9");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 9");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableExternalInterfaceReturn>> arg9(cx);
  if (args[9].isObject()) {
    if (JS::IsCallable(&args[9].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg9 = new binding_detail::FastTestNullableExternalInterfaceReturn(&args[9].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 10");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 10");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterfaceReturn>> arg10(cx);
  if (args[10].isObject()) {
    if (JS::IsCallable(&args[10].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg10 = new binding_detail::FastTestCallbackInterfaceReturn(&args[10].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 11");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 11");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableCallbackInterfaceReturn>> arg11(cx);
  if (args[11].isObject()) {
    if (JS::IsCallable(&args[11].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg11 = new binding_detail::FastTestNullableCallbackInterfaceReturn(&args[11].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 12");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 12");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackReturn>> arg12(cx);
  if (args[12].isObject()) {
    if (JS::IsCallable(&args[12].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg12 = new binding_detail::FastTestCallbackReturn(&args[12].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 13");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 13");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableCallbackReturn>> arg13(cx);
  if (args[13].isObject()) {
    if (JS::IsCallable(&args[13].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg13 = new binding_detail::FastTestNullableCallbackReturn(&args[13].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 14");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 14");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestObjectReturn>> arg14(cx);
  if (args[14].isObject()) {
    if (JS::IsCallable(&args[14].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg14 = new binding_detail::FastTestObjectReturn(&args[14].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 15");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 15");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableObjectReturn>> arg15(cx);
  if (args[15].isObject()) {
    if (JS::IsCallable(&args[15].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg15 = new binding_detail::FastTestNullableObjectReturn(&args[15].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 16");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 16");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestTypedArrayReturn>> arg16(cx);
  if (args[16].isObject()) {
    if (JS::IsCallable(&args[16].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg16 = new binding_detail::FastTestTypedArrayReturn(&args[16].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 17");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 17");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableTypedArrayReturn>> arg17(cx);
  if (args[17].isObject()) {
    if (JS::IsCallable(&args[17].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg17 = new binding_detail::FastTestNullableTypedArrayReturn(&args[17].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 18");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 18");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestSequenceReturn>> arg18(cx);
  if (args[18].isObject()) {
    if (JS::IsCallable(&args[18].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg18 = new binding_detail::FastTestSequenceReturn(&args[18].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 19");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 19");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestNullableSequenceReturn>> arg19(cx);
  if (args[19].isObject()) {
    if (JS::IsCallable(&args[19].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg19 = new binding_detail::FastTestNullableSequenceReturn(&args[19].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 20");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 20");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestIntegerArguments>> arg20(cx);
  if (args[20].isObject()) {
    if (JS::IsCallable(&args[20].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg20 = new binding_detail::FastTestIntegerArguments(&args[20].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 21");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 21");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestInterfaceArguments>> arg21(cx);
  if (args[21].isObject()) {
    if (JS::IsCallable(&args[21].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg21 = new binding_detail::FastTestInterfaceArguments(&args[21].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 22");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 22");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestStringEnumArguments>> arg22(cx);
  if (args[22].isObject()) {
    if (JS::IsCallable(&args[22].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg22 = new binding_detail::FastTestStringEnumArguments(&args[22].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 23");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 23");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestObjectArguments>> arg23(cx);
  if (args[23].isObject()) {
    if (JS::IsCallable(&args[23].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg23 = new binding_detail::FastTestObjectArguments(&args[23].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 24");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 24");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestOptionalArguments>> arg24(cx);
  if (args[24].isObject()) {
    if (JS::IsCallable(&args[24].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg24 = new binding_detail::FastTestOptionalArguments(&args[24].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 25");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 25");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestVoidConstruction>> arg25(cx);
  if (args[25].isObject()) {
    if (JS::IsCallable(&args[25].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg25 = new binding_detail::FastTestVoidConstruction(&args[25].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 26");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 26");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestIntegerConstruction>> arg26(cx);
  if (args[26].isObject()) {
    if (JS::IsCallable(&args[26].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg26 = new binding_detail::FastTestIntegerConstruction(&args[26].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 27");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 27");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestBooleanConstruction>> arg27(cx);
  if (args[27].isObject()) {
    if (JS::IsCallable(&args[27].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg27 = new binding_detail::FastTestBooleanConstruction(&args[27].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 28");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 28");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestFloatConstruction>> arg28(cx);
  if (args[28].isObject()) {
    if (JS::IsCallable(&args[28].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg28 = new binding_detail::FastTestFloatConstruction(&args[28].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 29");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 29");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestStringConstruction>> arg29(cx);
  if (args[29].isObject()) {
    if (JS::IsCallable(&args[29].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg29 = new binding_detail::FastTestStringConstruction(&args[29].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 30");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 30");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestEnumConstruction>> arg30(cx);
  if (args[30].isObject()) {
    if (JS::IsCallable(&args[30].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg30 = new binding_detail::FastTestEnumConstruction(&args[30].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 31");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 31");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestInterfaceConstruction>> arg31(cx);
  if (args[31].isObject()) {
    if (JS::IsCallable(&args[31].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg31 = new binding_detail::FastTestInterfaceConstruction(&args[31].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 32");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 32");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestExternalInterfaceConstruction>> arg32(cx);
  if (args[32].isObject()) {
    if (JS::IsCallable(&args[32].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg32 = new binding_detail::FastTestExternalInterfaceConstruction(&args[32].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 33");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 33");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterfaceConstruction>> arg33(cx);
  if (args[33].isObject()) {
    if (JS::IsCallable(&args[33].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg33 = new binding_detail::FastTestCallbackInterfaceConstruction(&args[33].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 34");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 34");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackConstruction>> arg34(cx);
  if (args[34].isObject()) {
    if (JS::IsCallable(&args[34].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg34 = new binding_detail::FastTestCallbackConstruction(&args[34].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 35");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 35");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestObjectConstruction>> arg35(cx);
  if (args[35].isObject()) {
    if (JS::IsCallable(&args[35].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg35 = new binding_detail::FastTestObjectConstruction(&args[35].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 36");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 36");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestTypedArrayConstruction>> arg36(cx);
  if (args[36].isObject()) {
    if (JS::IsCallable(&args[36].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg36 = new binding_detail::FastTestTypedArrayConstruction(&args[36].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 37");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 37");
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestSequenceConstruction>> arg37(cx);
  if (args[37].isObject()) {
    if (JS::IsCallable(&args[37].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg37 = new binding_detail::FastTestSequenceConstruction(&args[37].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 38");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 38");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ForceCallbackGeneration(MOZ_KnownLive(NonNullHelper(arg0)), MOZ_KnownLive(NonNullHelper(arg1)), MOZ_KnownLive(NonNullHelper(arg2)), MOZ_KnownLive(NonNullHelper(arg3)), MOZ_KnownLive(NonNullHelper(arg4)), MOZ_KnownLive(NonNullHelper(arg5)), MOZ_KnownLive(NonNullHelper(arg6)), MOZ_KnownLive(NonNullHelper(arg7)), MOZ_KnownLive(NonNullHelper(arg8)), MOZ_KnownLive(NonNullHelper(arg9)), MOZ_KnownLive(NonNullHelper(arg10)), MOZ_KnownLive(NonNullHelper(arg11)), MOZ_KnownLive(NonNullHelper(arg12)), MOZ_KnownLive(NonNullHelper(arg13)), MOZ_KnownLive(NonNullHelper(arg14)), MOZ_KnownLive(NonNullHelper(arg15)), MOZ_KnownLive(NonNullHelper(arg16)), MOZ_KnownLive(NonNullHelper(arg17)), MOZ_KnownLive(NonNullHelper(arg18)), MOZ_KnownLive(NonNullHelper(arg19)), MOZ_KnownLive(NonNullHelper(arg20)), MOZ_KnownLive(NonNullHelper(arg21)), MOZ_KnownLive(NonNullHelper(arg22)), MOZ_KnownLive(NonNullHelper(arg23)), MOZ_KnownLive(NonNullHelper(arg24)), MOZ_KnownLive(NonNullHelper(arg25)), MOZ_KnownLive(NonNullHelper(arg26)), MOZ_KnownLive(NonNullHelper(arg27)), MOZ_KnownLive(NonNullHelper(arg28)), MOZ_KnownLive(NonNullHelper(arg29)), MOZ_KnownLive(NonNullHelper(arg30)), MOZ_KnownLive(NonNullHelper(arg31)), MOZ_KnownLive(NonNullHelper(arg32)), MOZ_KnownLive(NonNullHelper(arg33)), MOZ_KnownLive(NonNullHelper(arg34)), MOZ_KnownLive(NonNullHelper(arg35)), MOZ_KnownLive(NonNullHelper(arg36)), MOZ_KnownLive(NonNullHelper(arg37))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ForceCallbackGeneration(MOZ_KnownLive(NonNullHelper(arg0)), MOZ_KnownLive(NonNullHelper(arg1)), MOZ_KnownLive(NonNullHelper(arg2)), MOZ_KnownLive(NonNullHelper(arg3)), MOZ_KnownLive(NonNullHelper(arg4)), MOZ_KnownLive(NonNullHelper(arg5)), MOZ_KnownLive(NonNullHelper(arg6)), MOZ_KnownLive(NonNullHelper(arg7)), MOZ_KnownLive(NonNullHelper(arg8)), MOZ_KnownLive(NonNullHelper(arg9)), MOZ_KnownLive(NonNullHelper(arg10)), MOZ_KnownLive(NonNullHelper(arg11)), MOZ_KnownLive(NonNullHelper(arg12)), MOZ_KnownLive(NonNullHelper(arg13)), MOZ_KnownLive(NonNullHelper(arg14)), MOZ_KnownLive(NonNullHelper(arg15)), MOZ_KnownLive(NonNullHelper(arg16)), MOZ_KnownLive(NonNullHelper(arg17)), MOZ_KnownLive(NonNullHelper(arg18)), MOZ_KnownLive(NonNullHelper(arg19)), MOZ_KnownLive(NonNullHelper(arg20)), MOZ_KnownLive(NonNullHelper(arg21)), MOZ_KnownLive(NonNullHelper(arg22)), MOZ_KnownLive(NonNullHelper(arg23)), MOZ_KnownLive(NonNullHelper(arg24)), MOZ_KnownLive(NonNullHelper(arg25)), MOZ_KnownLive(NonNullHelper(arg26)), MOZ_KnownLive(NonNullHelper(arg27)), MOZ_KnownLive(NonNullHelper(arg28)), MOZ_KnownLive(NonNullHelper(arg29)), MOZ_KnownLive(NonNullHelper(arg30)), MOZ_KnownLive(NonNullHelper(arg31)), MOZ_KnownLive(NonNullHelper(arg32)), MOZ_KnownLive(NonNullHelper(arg33)), MOZ_KnownLive(NonNullHelper(arg34)), MOZ_KnownLive(NonNullHelper(arg35)), MOZ_KnownLive(NonNullHelper(arg36)), MOZ_KnownLive(NonNullHelper(arg37)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo forceCallbackGeneration_methodinfo = {
  { (JSJitGetterOp)forceCallbackGeneration },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAny", 1)) {
    return false;
  }
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAny(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAny(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAny_methodinfo = {
  { (JSJitGetterOp)passAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JS::Value& slot = *arg0.AppendElement();
      slot = args[variadicArg];
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicAny_methodinfo = {
  { (JSJitGetterOp)passVariadicAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
    arg0 = args[0];
  } else {
    arg0 = JS::UndefinedValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalAny(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalAny(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalAny_methodinfo = {
  { (JSJitGetterOp)passOptionalAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAnyDefaultNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAnyDefaultNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
    arg0 = args[0];
  } else {
    arg0 = JS::NullValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAnyDefaultNull(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAnyDefaultNull(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAnyDefaultNull_methodinfo = {
  { (JSJitGetterOp)passAnyDefaultNull },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JS::Value> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableSequenceOfAny", 1)) {
    return false;
  }
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JS::Value> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Sequence<JS::Value>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<JS::Value>>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalSequenceOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalSequenceOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAnyWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<JS::Value>> arg0;
  SequenceRooter<Sequence<JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<JS::Value>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<JS::Value>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<JS::Value>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  Nullable<Sequence<Nullable<Sequence<JS::Value>>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, JS::Value> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableRecordOfAny", 1)) {
    return false;
  }
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Record<nsString, JS::Value>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Record<nsString, JS::Value>>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalRecordOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalRecordOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAnyWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, Record<nsString, JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, JS::Value>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, JS::Value>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, Nullable<Record<nsString, JS::Value>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableRecordOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableRecordOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Sequence<JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Sequence<JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableSequenceOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Record<nsString, JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Record<nsString, JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Record<nsString, JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of element of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableRecordOfAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAny(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAny(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveAny_methodinfo = {
  { (JSJitGetterOp)receiveAny },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passObject", 1)) {
    return false;
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassObject(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassObject(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passObject_methodinfo = {
  { (JSJitGetterOp)passObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicObject_methodinfo = {
  { (JSJitGetterOp)passVariadicObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableObject", 1)) {
    return false;
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableObject(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableObject(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableObject_methodinfo = {
  { (JSJitGetterOp)passNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableObject_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
      arg0.Value() = &args[0].toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObject_methodinfo = {
  { (JSJitGetterOp)passOptionalObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
      arg0.Value() = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObjectWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableObjectWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableObjectWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      arg0 = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObjectWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObjectWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfObject", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfNullableObject", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableSequenceOfObject", 1)) {
    return false;
  }
  Nullable<Sequence<JSObject*>> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JSObject*> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
              slot1 = &temp1.toObject();
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableSequenceOfNullableSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableSequenceOfNullableSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
              slot1 = &temp1.toObject();
            } else if (temp1.isNullOrUndefined()) {
              slot1 = nullptr;
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfObject", 1)) {
    return false;
  }
  Record<nsString, JSObject*> arg0;
  RecordRooter<nsString, JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JSObject*>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JSObject*& slot = entry->mValue;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfObject_methodinfo = {
  { (JSJitGetterOp)passRecordOfObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObject(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObject(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveObject_methodinfo = {
  { (JSJitGetterOp)receiveObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObject(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObject(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableObject_methodinfo = {
  { (JSJitGetterOp)receiveNullableObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnion", 1)) {
    return false;
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnion_methodinfo = {
  { (JSJitGetterOp)passUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionWithNullable", 1)) {
    return false;
  }
  ObjectOrNullOrLong arg0;
  ObjectOrNullOrLongArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithNullable(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithNullable(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithNullable_methodinfo = {
  { (JSJitGetterOp)passUnionWithNullable },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passNullableUnion", 1)) {
    return false;
  }
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnion_methodinfo = {
  { (JSJitGetterOp)passNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<ObjectOrLong> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<Nullable<ObjectOrLong >> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      arg0_holder.emplace(arg0.Value().SetValue());
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnionWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOptionalNullableUnionWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalNullableUnionWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnionWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnionWithDefaultValue },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionWithArrayBuffer", 1)) {
    return false;
  }
  ArrayBufferOrLong arg0;
  ArrayBufferOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionWithArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionWithString", 1)) {
    return false;
  }
  StringOrObject arg0;
  StringOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithString(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithString(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithString_methodinfo = {
  { (JSJitGetterOp)passUnionWithString },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionWithEnum", 1)) {
    return false;
  }
  SupportedTypeOrObject arg0;
  SupportedTypeOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithEnum(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithEnum(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithEnum_methodinfo = {
  { (JSJitGetterOp)passUnionWithEnum },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionWithObject", 1)) {
    return false;
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithObject_methodinfo = {
  { (JSJitGetterOp)passUnionWithObject },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue4 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue5 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.5F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue6 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue7 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue8 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue9 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = mozilla::PositiveInfinity<double>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue10 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue11 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue12 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = mozilla::PositiveInfinity<float>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue13 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue14 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue15 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue16 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsSupportedType() = SupportedType::Text_html;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue17 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue18 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue19 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue20 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue21 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue22 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue23 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue24 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue25 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue4 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue5 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue6 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue7 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue8 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue9 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue10 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue11 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue12 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue13 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue14 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue15 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue16 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsSupportedType() = SupportedType::Text_html;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue17 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue18 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue19 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue20 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"abc");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue21 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue22 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue23 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue24 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("abc");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue25 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue26(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue26");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue26", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue26_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue26 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue27(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue27");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue27", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue27_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue27 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue28(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passNullableUnionWithDefaultValue28");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passNullableUnionWithDefaultValue28", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue28_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue28 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfUnions", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningCanvasPatternOrCanvasGradient* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningCanvasPatternOrCanvasGradient& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfUnions2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfUnions2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfUnions2", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningObjectOrLong> arg0;
  SequenceRooter<OwningObjectOrLong> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningObjectOrLong> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningObjectOrLong* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningObjectOrLong& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          if (!slot.SetToObject(cx, &temp.toObject(), false)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !slot.TrySetToLong(cx, temp, tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "object");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions2(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions2(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions2_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningCanvasPatternOrCanvasGradient& slot = *arg0.AppendElement();
      {
        bool done = false, failed = false, tryNext;
        if (args[variadicArg].isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, args[variadicArg], tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, args[variadicArg], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfNullableUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfNullableUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfNullableUnions", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (temp.isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableUnions },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *arg0.AppendElement();
      if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (args[variadicArg].isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, args[variadicArg], tryNext, false)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, args[variadicArg], tryNext, false)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfUnions", 1)) {
    return false;
  }
  Record<nsString, OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningCanvasPatternOrCanvasGradient>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningCanvasPatternOrCanvasGradient& slot = entry->mValue;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value in argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfUnions_methodinfo = {
  { (JSJitGetterOp)passRecordOfUnions },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion_methodinfo = {
  { (JSJitGetterOp)receiveUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion2(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion2(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion2_methodinfo = {
  { (JSJitGetterOp)receiveUnion2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnionContainingNull(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnionContainingNull(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnionContainingNull_methodinfo = {
  { (JSJitGetterOp)receiveUnionContainingNull },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NullableRootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion2(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion2(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion2_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  CanvasPatternOrCanvasGradient arg0;
  CanvasPatternOrCanvasGradientArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnion_getterinfo = {
  { get_writableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnionContainingNull(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnionContainingNull(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnionContainingNull(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableUnionContainingNull setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  CanvasPatternOrNullOrCanvasGradient arg0;
  CanvasPatternOrNullOrCanvasGradientArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
               (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnionContainingNull_getterinfo = {
  { get_writableUnionContainingNull },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnionContainingNull_setterinfo = {
  { (JSJitGetterOp)set_writableUnionContainingNull },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableNullableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableNullableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableNullableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<CanvasPatternOrCanvasGradient > arg0;
  Maybe<CanvasPatternOrCanvasGradientArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.ref().TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
               (failed = !arg0_holder.ref().TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnion_getterinfo = {
  { get_writableNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnion },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passPromise", 1)) {
    return false;
  }
  OwningNonNull<Promise> arg0;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    globalObj = JS::CurrentGlobalOrNull(cx);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      return false;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      return false;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      return false;
    }
    arg0 = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromise_methodinfo = {
  { (JSJitGetterOp)passPromise },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOptionalPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<OwningNonNull<Promise>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
      // etc.

      JS::Rooted<JSObject*> globalObj(cx);
      globalObj = JS::CurrentGlobalOrNull(cx);
      JSAutoRealm ar(cx, globalObj);
      GlobalObject promiseGlobal(cx, globalObj);
      if (promiseGlobal.Failed()) {
        return false;
      }

      JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
      if (!JS_WrapValue(cx, &valueToResolve)) {
        return false;
      }
      binding_detail::FastErrorResult promiseRv;
      nsCOMPtr<nsIGlobalObject> global =
        do_QueryInterface(promiseGlobal.GetAsSupports());
      if (!global) {
        promiseRv.Throw(NS_ERROR_UNEXPECTED);
        MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
        return false;
      }
      arg0.Value() = Promise::Resolve(global, cx, valueToResolve,
                                      promiseRv);
      if (promiseRv.MaybeSetPendingException(cx)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalPromise_methodinfo = {
  { (JSJitGetterOp)passOptionalPromise },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromiseSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passPromiseSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passPromiseSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passPromiseSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningNonNull<Promise>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<Promise>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<Promise>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<Promise>& slot = *slotPtr;
      { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
        // etc.

        JS::Rooted<JSObject*> globalObj(cx);
        globalObj = JS::CurrentGlobalOrNull(cx);
        JSAutoRealm ar(cx, globalObj);
        GlobalObject promiseGlobal(cx, globalObj);
        if (promiseGlobal.Failed()) {
          return false;
        }

        JS::Rooted<JS::Value> valueToResolve(cx, temp);
        if (!JS_WrapValue(cx, &valueToResolve)) {
          return false;
        }
        binding_detail::FastErrorResult promiseRv;
        nsCOMPtr<nsIGlobalObject> global =
          do_QueryInterface(promiseGlobal.GetAsSupports());
        if (!global) {
          promiseRv.Throw(NS_ERROR_UNEXPECTED);
          MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
          return false;
        }
        slot = Promise::Resolve(global, cx, valueToResolve,
                                        promiseRv);
        if (promiseRv.MaybeSetPendingException(cx)) {
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromiseSequence_methodinfo = {
  { (JSJitGetterOp)passPromiseSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receivePromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receivePromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceivePromise()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receivePromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receivePromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receivePromise_methodinfo = {
  { (JSJitGetterOp)receivePromise_promiseWrapper },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveAddrefedPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceiveAddrefedPromise()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receiveAddrefedPromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receiveAddrefedPromise_methodinfo = {
  { (JSJitGetterOp)receiveAddrefedPromise_promiseWrapper },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
methodRenamedFrom(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.methodRenamedFrom");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "methodRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo())>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo();
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      int8_t arg0;
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo methodRenamedFrom_methodinfo = {
  { (JSJitGetterOp)methodRenamedFrom },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeGetterRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "attributeGetterRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->AttributeGetterRenamedTo());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo attributeGetterRenamedFrom_getterinfo = {
  { get_attributeGetterRenamedFrom },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->AttributeRenamedTo());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attributeRenamedFrom_getterinfo = {
  { get_attributeRenamedFrom },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo attributeRenamedFrom_setterinfo = {
  { (JSJitGetterOp)set_attributeRenamedFrom },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary_methodinfo = {
  { (JSJitGetterOp)passDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passDictionary2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passDictionary2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passDictionary2", 1)) {
    return false;
  }
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary2(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary2(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary2_methodinfo = {
  { (JSJitGetterOp)passDictionary2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 9) : (DOM_INSTANCE_RESERVED_SLOTS + 9);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyDictionary_getterinfo = {
  { get_readonlyDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 9)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 9) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 9) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 10) : (DOM_INSTANCE_RESERVED_SLOTS + 10);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }
      if (!result.Value().ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyNullableDictionary_getterinfo = {
  { get_readonlyNullableDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 10)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 10) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 10) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 11) : (DOM_INSTANCE_RESERVED_SLOTS + 11);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableDictionary setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Value being assigned", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedWritableDictionaryValue(self);
  return true;
}

static const JSJitInfo writableDictionary_getterinfo = {
  { get_writableDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 11)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 11) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 11) < 16, "There is no slot for us");
static const JSJitInfo writableDictionary_setterinfo = {
  { (JSJitGetterOp)set_writableDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 12) : (DOM_INSTANCE_RESERVED_SLOTS + 12);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenDictionary_getterinfo = {
  { get_readonlyFrozenDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 12)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 12) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 12) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "readonlyFrozenNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 13) : (DOM_INSTANCE_RESERVED_SLOTS + 13);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }
      if (!result.Value().ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    if (args.rval().isObject()) {
      JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
      if (!JS_FreezeObject(cx, rvalObj)) {
        return false;
      }
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenNullableDictionary_getterinfo = {
  { get_readonlyFrozenNullableDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 13)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 13) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 13) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableFrozenDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 14) : (DOM_INSTANCE_RESERVED_SLOTS + 14);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableFrozenDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableFrozenDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableFrozenDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.writableFrozenDictionary setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "writableFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Value being assigned", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableFrozenDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableFrozenDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedWritableFrozenDictionaryValue(self);
  return true;
}

static const JSJitInfo writableFrozenDictionary_getterinfo = {
  { get_writableFrozenDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 14)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 14) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 14) < 16, "There is no slot for us");
static const JSJitInfo writableFrozenDictionary_setterinfo = {
  { (JSJitGetterOp)set_writableFrozenDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictionary_methodinfo = {
  { (JSJitGetterOp)receiveDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableDictionary_methodinfo = {
  { (JSJitGetterOp)receiveNullableDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOtherDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passOtherDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passOtherDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  binding_detail::FastGrandparentDict arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOtherDictionary_methodinfo = {
  { (JSJitGetterOp)passOtherDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passSequenceOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passSequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passSequenceOfDictionaries", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Dict> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Dict* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Dict& slot = *slotPtr;
      if (!slot.Init(cx, temp, "Element of argument 1", false)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfDictionaries(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfDictionaries(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passSequenceOfDictionaries },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRecordOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRecordOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRecordOfDictionaries", 1)) {
    return false;
  }
  Record<nsString, GrandparentDict> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, GrandparentDict>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      GrandparentDict& slot = entry->mValue;
      if (!slot.Init(cx, temp, "Value in argument 1", false)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passRecordOfDictionaries },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionaryOrLong(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passDictionaryOrLong");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passDictionaryOrLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo passDictionaryOrLong_methodinfo = {
  { (JSJitGetterOp)passDictionaryOrLong },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingDict(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passDictContainingDict");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passDictContainingDict", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<binding_detail::FastDictContainingDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingDict(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingDict(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingDict_methodinfo = {
  { (JSJitGetterOp)passDictContainingDict },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passDictContainingSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<binding_detail::FastDictContainingSequence> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingSequence(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingSequence(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)passDictContainingSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictContainingSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "receiveDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedDictionary<DictContainingSequence> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictContainingSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictContainingSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)receiveDictContainingSequence },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Dict& slot = *arg0.AppendElement();
      if (!slot.Init(cx, args[variadicArg], "Argument 1", false)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicDictionary_methodinfo = {
  { (JSJitGetterOp)passVariadicDictionary },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dontEnforceRangeOrClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "dontEnforceRangeOrClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.dontEnforceRangeOrClamp", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dontEnforceRangeOrClamp_methodinfo = {
  { (JSJitGetterOp)dontEnforceRangeOrClamp },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRange(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.doEnforceRange");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "doEnforceRange", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.doEnforceRange", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRange(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRange(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRange_methodinfo = {
  { (JSJitGetterOp)doEnforceRange },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRangeNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.doEnforceRangeNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "doEnforceRangeNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.doEnforceRangeNullable", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRangeNullable_methodinfo = {
  { (JSJitGetterOp)doEnforceRangeNullable },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "doClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.doClamp", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClamp(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClamp(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClamp_methodinfo = {
  { (JSJitGetterOp)doClamp },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClampNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "doClampNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.doClampNullable", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClampNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClampNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClampNullable_methodinfo = {
  { (JSJitGetterOp)doClampNullable },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->EnforcedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedByte(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.enforcedByte setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedByte_getterinfo = {
  { get_enforcedByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enforcedByte_setterinfo = {
  { (JSJitGetterOp)set_enforcedByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enforcedNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetEnforcedNullableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedNullableByte(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.enforcedNullableByte setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "enforcedNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedNullableByte_getterinfo = {
  { get_enforcedNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enforcedNullableByte_setterinfo = {
  { (JSJitGetterOp)set_enforcedNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ClampedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedByte_getterinfo = {
  { get_clampedByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo clampedByte_setterinfo = {
  { (JSJitGetterOp)set_clampedByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "clampedNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetClampedNullableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "clampedNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedNullableByte_getterinfo = {
  { get_clampedNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo clampedNullableByte_setterinfo = {
  { (JSJitGetterOp)set_clampedNullableByte },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.exerciseTypedefInterfaces1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "exerciseTypedefInterfaces1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.exerciseTypedefInterfaces1", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces1_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.exerciseTypedefInterfaces2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "exerciseTypedefInterfaces2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.exerciseTypedefInterfaces2", 1)) {
    return false;
  }
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ExerciseTypedefInterfaces2(MOZ_KnownLive(Constify(arg0)))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces2_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.exerciseTypedefInterfaces3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "exerciseTypedefInterfaces3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.exerciseTypedefInterfaces3", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces3_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  int8_t result(MOZ_KnownLive(self)->DeprecatedAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo deprecatedAttribute_getterinfo = {
  { get_deprecatedAttribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo deprecatedAttribute_setterinfo = {
  { (JSJitGetterOp)set_deprecatedAttribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "deprecatedMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  int8_t result(MOZ_KnownLive(self)->DeprecatedMethod());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deprecatedMethod_methodinfo = {
  { (JSJitGetterOp)deprecatedMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethodWithContext(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "deprecatedMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.deprecatedMethodWithContext", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  int8_t result(MOZ_KnownLive(self)->DeprecatedMethodWithContext(cx, arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deprecatedMethodWithContext_methodinfo = {
  { (JSJitGetterOp)deprecatedMethodWithContext },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool result(mozilla::dom::TestInterface::StaticAttribute(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "staticAttribute setter", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::SetStaticAttribute(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::SetStaticAttribute(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestInterface.staticMethod", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::StaticMethod(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::StaticMethod(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticMethodWithContext(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestInterface.staticMethodWithContext", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::StaticMethodWithContext(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::StaticMethodWithContext(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
_assert_(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "assert", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestInterface.assert", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::Assert(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::Assert(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
get_staticDeprecatedAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticDeprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  int8_t result(mozilla::dom::TestInterface::StaticDeprecatedAttribute(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_staticDeprecatedAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticDeprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "staticDeprecatedAttribute setter", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::SetStaticDeprecatedAttribute(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::SetStaticDeprecatedAttribute(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticDeprecatedMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticDeprecatedMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::StaticDeprecatedMethod(global))>, "Should be returning void here");
  mozilla::dom::TestInterface::StaticDeprecatedMethod(global);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticDeprecatedMethodWithContext(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "staticDeprecatedMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestInterface.staticDeprecatedMethodWithContext", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestInterface::StaticDeprecatedMethodWithContext(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestInterface::StaticDeprecatedMethodWithContext(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
overload1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 1: {
      NonNull<mozilla::dom::TestInterface> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      bool result(MOZ_KnownLive(self)->Overload1(MOZ_KnownLive(NonNullHelper(arg0))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 2: {
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      NonNull<mozilla::dom::TestInterface> arg1;
      if (args[1].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
        return false;
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->Overload1(NonNullHelper(Constify(arg0)), MOZ_KnownLive(NonNullHelper(arg1)))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload1_methodinfo = {
  { (JSJitGetterOp)overload1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload2_methodinfo = {
  { (JSJitGetterOp)overload2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastTestCallback>> arg0(cx);
          if (JS::IsCallable(&args[0].toObject())) {
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          } else {
            break;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      bool arg0;
      if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload3(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload3_methodinfo = {
  { (JSJitGetterOp)overload3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload4_methodinfo = {
  { (JSJitGetterOp)overload4 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload5(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      TestEnum arg0;
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0 = static_cast<TestEnum>(index);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload5(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload5_methodinfo = {
  { (JSJitGetterOp)overload5 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload6(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload6(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload6_methodinfo = {
  { (JSJitGetterOp)overload6 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      nsCString arg0;
      if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload7(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload7_methodinfo = {
  { (JSJitGetterOp)overload7 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload8(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload8_methodinfo = {
  { (JSJitGetterOp)overload8 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload9_methodinfo = {
  { (JSJitGetterOp)overload9 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          JS::Rooted<JSObject*> arg0(cx);
          arg0 = &args[0].toObject();
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(cx, arg0))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload10(cx, arg0);
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload10(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload10_methodinfo = {
  { (JSJitGetterOp)overload10 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload11(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload11_methodinfo = {
  { (JSJitGetterOp)overload11 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isBoolean()) {
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload12(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload12_methodinfo = {
  { (JSJitGetterOp)overload12 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload13(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload13(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload13_methodinfo = {
  { (JSJitGetterOp)overload13 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload14_methodinfo = {
  { (JSJitGetterOp)overload14 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<NonNull<mozilla::dom::TestInterface>> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isUndefined()) {
        Optional<NonNull<mozilla::dom::TestInterface>> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          if (args[0].isObject()) {
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
            return false;
          }
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<NonNull<mozilla::dom::TestInterface>> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload15_methodinfo = {
  { (JSJitGetterOp)overload15 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<mozilla::dom::TestInterface*> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else if (args[0].isNullOrUndefined()) {
          arg0.Value() = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Optional<mozilla::dom::TestInterface*> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          arg0.Value() = nullptr;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<mozilla::dom::TestInterface*> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload16_methodinfo = {
  { (JSJitGetterOp)overload16 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, int32_t> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, int32_t>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            int32_t& slot = entry->mValue;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload17_methodinfo = {
  { (JSJitGetterOp)overload17 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<nsString> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<nsString> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            nsString* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            nsString& slot = *slotPtr;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, nsString> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, nsString>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            nsString& slot = entry->mValue;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload18_methodinfo = {
  { (JSJitGetterOp)overload18 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload19_methodinfo = {
  { (JSJitGetterOp)overload19 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.overload20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "overload20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload20_methodinfo = {
  { (JSJitGetterOp)overload20 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicThirdArg(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passVariadicThirdArg");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passVariadicThirdArg", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passVariadicThirdArg", 2)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> arg2;
  if (args.length() > 2) {
    if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arg2.AppendElement();
      if (args[variadicArg].isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[variadicArg], slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 3", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicThirdArg_methodinfo = {
  { (JSJitGetterOp)passVariadicThirdArg },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable1());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable1_getterinfo = {
  { get_prefable1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable2_getterinfo = {
  { get_prefable2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable3());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable3_getterinfo = {
  { get_prefable3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable4());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable4_getterinfo = {
  { get_prefable4 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable5());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable5_getterinfo = {
  { get_prefable5 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable6());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable6_getterinfo = {
  { get_prefable6 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable7());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable7_getterinfo = {
  { get_prefable7 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable8());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable8_getterinfo = {
  { get_prefable8 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable9(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable9());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable9_getterinfo = {
  { get_prefable9 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable10(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable10())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable10();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable10_methodinfo = {
  { (JSJitGetterOp)prefable10 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable11(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable11())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable11();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable11_methodinfo = {
  { (JSJitGetterOp)prefable11 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable12(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable12());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable12_getterinfo = {
  { get_prefable12 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable13(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable13())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable13();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable13_methodinfo = {
  { (JSJitGetterOp)prefable13 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable14(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable14());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable14_getterinfo = {
  { get_prefable14 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable15(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable15());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable15_getterinfo = {
  { get_prefable15 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable16(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable16());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable16_getterinfo = {
  { get_prefable16 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable17(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable17())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable17();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable17_methodinfo = {
  { (JSJitGetterOp)prefable17 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable18(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable18())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable18();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable18_methodinfo = {
  { (JSJitGetterOp)prefable18 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable19(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable19())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable19();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable19_methodinfo = {
  { (JSJitGetterOp)prefable19 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable20(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "prefable20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable20())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable20();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable20_methodinfo = {
  { (JSJitGetterOp)prefable20 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext1());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext1_getterinfo = {
  { get_conditionalOnSecureContext1 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext2_getterinfo = {
  { get_conditionalOnSecureContext2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext3());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext3_getterinfo = {
  { get_conditionalOnSecureContext3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext4());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext4_getterinfo = {
  { get_conditionalOnSecureContext4 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext5())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext5();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext5_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext5 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext6())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext6();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext6_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext6 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext7())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext7();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext7_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext7 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "conditionalOnSecureContext8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext8())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext8();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext8_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext8 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->AttrWithLenientThis());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attrWithLenientThis_getterinfo = {
  { get_attrWithLenientThis },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo attrWithLenientThis_setterinfo = {
  { (JSJitGetterOp)set_attrWithLenientThis },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_unforgeableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "unforgeableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableAttr_getterinfo = {
  { get_unforgeableAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_unforgeableAttr2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "unforgeableAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableAttr2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableAttr2_getterinfo = {
  { get_unforgeableAttr2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
unforgeableMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "unforgeableMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableMethod());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableMethod_methodinfo = {
  { (JSJitGetterOp)unforgeableMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
unforgeableMethod2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "unforgeableMethod2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableMethod2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableMethod2_methodinfo = {
  { (JSJitGetterOp)unforgeableMethod2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
__stringifier(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "__stringifier", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Stringify(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->Stringify(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo __stringifier_methodinfo = {
  { (JSJitGetterOp)__stringifier },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRenamedInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passRenamedInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passRenamedInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passRenamedInterface", 1)) {
    return false;
  }
  NonNull<nsRenamedInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestRenamedInterface, nsRenamedInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestRenamedInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRenamedInterface_methodinfo = {
  { (JSJitGetterOp)passRenamedInterface },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->PutForwardsAttr()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.putForwardsAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestInterface.putForwardsAttr");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr_getterinfo = {
  { get_putForwardsAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->PutForwardsAttr2()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.putForwardsAttr2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr2", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestInterface.putForwardsAttr2");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr2_getterinfo = {
  { get_putForwardsAttr2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr2_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->PutForwardsAttr3()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.putForwardsAttr3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr3", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestInterface.putForwardsAttr3");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr3_getterinfo = {
  { get_putForwardsAttr3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr3_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
throwingMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ThrowingMethod(rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->ThrowingMethod(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.throwingMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo throwingMethod_methodinfo = {
  { (JSJitGetterOp)throwingMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingAttr(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.throwingAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.throwingAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingAttr_getterinfo = {
  { get_throwingAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingGetterAttr(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.throwingGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingGetterAttr_getterinfo = {
  { get_throwingGetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingGetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ThrowingSetterAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.throwingSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingSetterAttr_getterinfo = {
  { get_throwingSetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingSetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
canOOMMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CanOOMMethod(OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->CanOOMMethod(OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.canOOMMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo canOOMMethod_methodinfo = {
  { (JSJitGetterOp)canOOMMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMAttr(OOMReporter::From(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.canOOMAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMAttr(arg0, OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMAttr(arg0, OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.canOOMAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMAttr_getterinfo = {
  { get_canOOMAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMGetterAttr(OOMReporter::From(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.canOOMGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMGetterAttr_getterinfo = {
  { get_canOOMGetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMGetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->CanOOMSetterAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestInterface.canOOMSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMSetterAttr_getterinfo = {
  { get_canOOMSetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMSetterAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(NonNullHelper(subjectPrincipal))))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(NonNullHelper(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsSubjectPrincipalMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  bool result(MOZ_KnownLive(self)->NeedsSubjectPrincipalAttr(MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(NonNullHelper(subjectPrincipal))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(NonNullHelper(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsSubjectPrincipalAttr_getterinfo = {
  { get_needsSubjectPrincipalAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsSubjectPrincipalAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsCallerTypeMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsCallerTypeMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsCallerTypeMethod_methodinfo = {
  { (JSJitGetterOp)needsCallerTypeMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NeedsCallerTypeAttr(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsCallerTypeAttr_getterinfo = {
  { get_needsCallerTypeAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsCallerTypeAttr_setterinfo = {
  { (JSJitGetterOp)set_needsCallerTypeAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsNonSystemSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsNonSystemSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsNonSystemSubjectPrincipalMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  bool result(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalAttr_getterinfo = {
  { get_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsNonSystemSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "ceReactionsMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethod())>, "Should be returning void here");
  MOZ_KnownLive(self)->CeReactionsMethod();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo ceReactionsMethod_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethodOverload(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.ceReactionsMethodOverload");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "ceReactionsMethodOverload", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload())>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload();
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo ceReactionsMethodOverload_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethodOverload },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->CeReactionsAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCeReactionsAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCeReactionsAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ceReactionsAttr_getterinfo = {
  { get_ceReactionsAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo ceReactionsAttr_setterinfo = {
  { (JSJitGetterOp)set_ceReactionsAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArgsWithDefaults(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passArgsWithDefaults");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passArgsWithDefaults", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  mozilla::dom::TestInterface* arg1;
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
          return false;
        }
      }
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  RootedDictionary<binding_detail::FastDict> arg2(cx);
  if (!arg2.Init(cx, (args.hasDefined(2)) ? args[2] : JS::NullHandleValue, "Argument 3", false)) {
    return false;
  }
  double arg3;
  if (args.hasDefined(3)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
      return false;
    } else if (!mozilla::IsFinite(arg3)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
      return false;
    }
  } else {
    arg3 = 5.0;
  }
  Optional<float> arg4;
  if (args.hasDefined(4)) {
    arg4.Construct();
    if (!ValueToPrimitive<float, eDefault>(cx, args[4], "Argument 5", &arg4.Value())) {
      return false;
    } else if (!mozilla::IsFinite(arg4.Value())) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArgsWithDefaults(cx, Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArgsWithDefaults(cx, Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArgsWithDefaults_methodinfo = {
  { (JSJitGetterOp)passArgsWithDefaults },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetToJSONShouldSkipThis(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetToJSONShouldSkipThis(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis_getterinfo = {
  { get_toJSONShouldSkipThis },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestParentInterface>(MOZ_KnownLive(self)->ToJSONShouldSkipThis2()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.toJSONShouldSkipThis2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  NonNull<mozilla::dom::TestParentInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestParentInterface, mozilla::dom::TestParentInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestParentInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis2_getterinfo = {
  { get_toJSONShouldSkipThis2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis2_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis2 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ToJSONShouldSkipThis3()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.toJSONShouldSkipThis3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis3_getterinfo = {
  { get_toJSONShouldSkipThis3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis3_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis3 },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->Dashed_attribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDashed_attribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDashed_attribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo dashed_attribute_getterinfo = {
  { get_dashed_attribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo dashed_attribute_setterinfo = {
  { (JSJitGetterOp)set_dashed_attribute },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dashed_method(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "dashed-method", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Dashed_method())>, "Should be returning void here");
  MOZ_KnownLive(self)->Dashed_method();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dashed_method_methodinfo = {
  { (JSJitGetterOp)dashed_method },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NonEnumerableAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonEnumerableAttr_getterinfo = {
  { get_nonEnumerableAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonEnumerableAttr_setterinfo = {
  { (JSJitGetterOp)set_nonEnumerableAttr },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
nonEnumerableMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "nonEnumerableMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NonEnumerableMethod())>, "Should be returning void here");
  MOZ_KnownLive(self)->NonEnumerableMethod();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo nonEnumerableMethod_methodinfo = {
  { (JSJitGetterOp)nonEnumerableMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferViewTypedef(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.allowSharedArrayBufferViewTypedef setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferViewTypedef_getterinfo = {
  { get_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferViewTypedef_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.allowSharedArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferView_getterinfo = {
  { get_allowSharedArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.allowSharedNullableArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBufferView_getterinfo = {
  { get_allowSharedNullableArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.allowSharedArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBuffer_getterinfo = {
  { get_allowSharedArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestInterface.allowSharedNullableArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBuffer_getterinfo = {
  { get_allowSharedNullableArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passAllowSharedArrayBufferViewTypedef");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAllowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAllowSharedArrayBufferViewTypedef", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferViewTypedef_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferViewTypedef },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passAllowSharedArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAllowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAllowSharedArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passAllowSharedNullableArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAllowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAllowSharedNullableArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBufferView },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAllowSharedArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passAllowSharedNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passAllowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passAllowSharedNullableArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionArrayBuffer", 1)) {
    return false;
  }
  StringOrArrayBuffer arg0;
  StringOrArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestInterface.passUnionAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "passUnionAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestInterface.passUnionAllowSharedArrayBuffer", 1)) {
    return false;
  }
  StringOrMaybeSharedArrayBuffer arg0;
  StringOrMaybeSharedArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionAllowSharedArrayBuffer },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
mixedInMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "mixedInMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MixedInMethod())>, "Should be returning void here");
  MOZ_KnownLive(self)->MixedInMethod();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo mixedInMethod_methodinfo = {
  { (JSJitGetterOp)mixedInMethod },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_mixedInProperty(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "mixedInProperty", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->MixedInProperty());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_mixedInProperty(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "mixedInProperty", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetMixedInProperty(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetMixedInProperty(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo mixedInProperty_getterinfo = {
  { get_mixedInProperty },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo mixedInProperty_setterinfo = {
  { (JSJitGetterOp)set_mixedInProperty },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
toJSON(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "toJSON", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx, JS_NewPlainObject(cx));
  if (!result) {
    return false;
  }
  if (!TestInterface_Binding::CollectJSONAttributes(cx, obj, MOZ_KnownLive(self), result)) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}

static const JSJitInfo toJSON_methodinfo = {
  { (JSJitGetterOp)toJSON },
  { prototypes::id::TestInterface },
  { PrototypeTraits<prototypes::id::TestInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("staticMethod", staticMethod, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticMethodWithContext", staticMethodWithContext, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("assert", _assert_, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticDeprecatedMethod", staticDeprecatedMethod, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticDeprecatedMethodWithContext", staticDeprecatedMethodWithContext, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(5 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sStaticAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("staticAttribute", JSPROP_ENUMERATE, get_staticAttribute, nullptr, set_staticAttribute, nullptr),
  JSPropertySpec::nativeAccessors("staticDeprecatedAttribute", JSPROP_ENUMERATE, get_staticDeprecatedAttribute, nullptr, set_staticDeprecatedAttribute, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sStaticAttributes[] = {
  { nullptr, &sStaticAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("passByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefaultBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefaultBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnByteSideEffectFree", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnByteSideEffectFree_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDOMDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDOMDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnConstantByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnConstantByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDeviceStateDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDeviceStateDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOctet_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctetWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctetWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLenientFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLenientFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnrestricted", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnrestricted_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelfWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelfWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternalWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternalWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterfaceWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterfaceWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passStringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByteStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByteStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteStringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUTF8StringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUTF8StringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8StringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8StringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnySequenceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnySequenceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequencesOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequencesOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequenceOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequenceOfSequences_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequenceOfSequencesOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequenceOfSequencesOfSequences_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8StringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8StringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecords", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecords_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecordOfRecords", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecordOfRecords_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnyRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnyRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBufferWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBufferWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8ClampedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8ClampedArray_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat64Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat64Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUint8Array_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passJSString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalJSStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalJSStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveJSString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnumWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnumWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableTreatAsNullCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableTreatAsNullCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableTreatAsNullCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableTreatAsNullCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableTreatAsNullCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("forceCallbackGeneration", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&forceCallbackGeneration_methodinfo), 38, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAnyDefaultNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAnyDefaultNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObjectWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObjectWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnionWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnionWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue26", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue26_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue27", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue27_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue28", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue28_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnionContainingNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnionContainingNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromise_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromiseSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromiseSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receivePromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receivePromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAddrefedPromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receiveAddrefedPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("methodRenamedFrom", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&methodRenamedFrom_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOtherDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOtherDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionaryOrLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionaryOrLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingDict", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingDict_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dontEnforceRangeOrClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dontEnforceRangeOrClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRange", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRange_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRangeNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRangeNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClampNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClampNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethodWithContext", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethodWithContext_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload4_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload5_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload6_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload7_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload8_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload9_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload10_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload11_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload12_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload13_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload17_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload18_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicThirdArg", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicThirdArg_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("passRenamedInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRenamedInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("throwingMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&throwingMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("canOOMMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&canOOMMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsCallerTypeMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsCallerTypeMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsNonSystemSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsNonSystemSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethodOverload", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethodOverload_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArgsWithDefaults", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArgsWithDefaults_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("toJSON", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&toJSON_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dashed-method", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dashed_method_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("nonEnumerableMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&nonEnumerableMethod_methodinfo), 0, 0, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferViewTypedef", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferViewTypedef_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("mixedInMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&mixedInMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("toString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&__stringifier_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sMethods_disablers391 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sMethods_disablers393 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers396 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers398 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers401 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers403 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers405 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers407 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { &sMethods_disablers391, &sMethods_specs[391] },
  { &sMethods_disablers393, &sMethods_specs[393] },
  { &sMethods_disablers396, &sMethods_specs[396] },
  { &sMethods_disablers398, &sMethods_specs[398] },
  { &sMethods_disablers401, &sMethods_specs[401] },
  { &sMethods_disablers403, &sMethods_specs[403] },
  { &sMethods_disablers405, &sMethods_specs[405] },
  { &sMethods_disablers407, &sMethods_specs[407] },
  { nullptr, &sMethods_specs[409] },
  { nullptr, nullptr }
};

static_assert(10 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(390 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("prefable20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sChromeMethods_disablers0 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { &sChromeMethods_disablers0, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("readonlyByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableByte_getterinfo, GenericSetter<NormalThisPolicy>, &writableByte_setterinfo),
  JSPropertySpec::nativeAccessors("cachedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("cachedConstantByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedConstantByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("cachedWritableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedWritableByte_getterinfo, GenericSetter<NormalThisPolicy>, &cachedWritableByte_setterinfo),
  JSPropertySpec::nativeAccessors("sideEffectFreeByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &sideEffectFreeByte_getterinfo, GenericSetter<NormalThisPolicy>, &sideEffectFreeByte_setterinfo),
  JSPropertySpec::nativeAccessors("domDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &domDependentByte_getterinfo, GenericSetter<NormalThisPolicy>, &domDependentByte_setterinfo),
  JSPropertySpec::nativeAccessors("constantByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &constantByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("deviceStateDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deviceStateDependentByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyOctet_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableOctet_getterinfo, GenericSetter<NormalThisPolicy>, &writableOctet_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("writableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("lenientFloatAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientFloatAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientFloatAttr_setterinfo),
  JSPropertySpec::nativeAccessors("lenientDoubleAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientDoubleAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientDoubleAttr_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullSelf_setterinfo),
  JSPropertySpec::nativeAccessors("nullableSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nullableSelf_setterinfo),
  JSPropertySpec::nativeAccessors("cachedSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedSelf_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("nonNullExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nullableExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nullableExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("nullableCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nullableCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("readonlySequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlySequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlySequenceOfDictionaries", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlySequenceOfDictionaries_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyNullableSequenceOfDictionaries", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyNullableSequenceOfDictionaries_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenSequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenSequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenNullableSequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenNullableSequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("uint8ArrayAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &uint8ArrayAttr_getterinfo, GenericSetter<NormalThisPolicy>, &uint8ArrayAttr_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyJSStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyJSStringAttr_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("jsStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &jsStringAttr_getterinfo, GenericSetter<NormalThisPolicy>, &jsStringAttr_setterinfo),
  JSPropertySpec::nativeAccessors("enumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enumAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &enumAttribute_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyEnumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyEnumAttribute_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("treatAsNullCallback", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &treatAsNullCallback_getterinfo, GenericSetter<NormalThisPolicy>, &treatAsNullCallback_setterinfo),
  JSPropertySpec::nativeAccessors("nullableTreatAsNullCallback", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableTreatAsNullCallback_getterinfo, GenericSetter<NormalThisPolicy>, &nullableTreatAsNullCallback_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnionContainingNull", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnionContainingNull_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnionContainingNull_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("attributeGetterRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeGetterRenamedFrom_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("attributeRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeRenamedFrom_getterinfo, GenericSetter<NormalThisPolicy>, &attributeRenamedFrom_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyNullableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyNullableDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableDictionary_getterinfo, GenericSetter<NormalThisPolicy>, &writableDictionary_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyFrozenDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenNullableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenNullableDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableFrozenDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableFrozenDictionary_getterinfo, GenericSetter<NormalThisPolicy>, &writableFrozenDictionary_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedByte_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedByte_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedNullableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedNullableByte_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedNullableByte_setterinfo),
  JSPropertySpec::nativeAccessors("clampedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedByte_getterinfo, GenericSetter<NormalThisPolicy>, &clampedByte_setterinfo),
  JSPropertySpec::nativeAccessors("clampedNullableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedNullableByte_getterinfo, GenericSetter<NormalThisPolicy>, &clampedNullableByte_setterinfo),
  JSPropertySpec::nativeAccessors("deprecatedAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deprecatedAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &deprecatedAttribute_setterinfo),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable1_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable3_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable5", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable5_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable6", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable6_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable7", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable7_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable8", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable8_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable9", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable9_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable12", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable12_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable14", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable14_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable15", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable15_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable16", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable16_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext1_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext3_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("attrWithLenientThis", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &attrWithLenientThis_getterinfo, GenericSetter<LenientThisPolicy>, &attrWithLenientThis_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr2", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &putForwardsAttr2_getterinfo, GenericSetter<LenientThisPolicy>, &putForwardsAttr2_setterinfo),
  JSPropertySpec::nativeAccessors("throwingAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsCallerTypeAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsCallerTypeAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsCallerTypeAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsNonSystemSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsNonSystemSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsNonSystemSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("ceReactionsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &ceReactionsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &ceReactionsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis2_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis2_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis3_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis3_setterinfo),
  JSPropertySpec::nativeAccessors("dashed-attribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &dashed_attribute_getterinfo, GenericSetter<NormalThisPolicy>, &dashed_attribute_setterinfo),
  JSPropertySpec::nativeAccessors("nonEnumerableAttr", 0, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonEnumerableAttr_getterinfo, GenericSetter<NormalThisPolicy>, &nonEnumerableAttr_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferViewTypedef", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferViewTypedef_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferViewTypedef_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBuffer_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBuffer_setterinfo),
  JSPropertySpec::nativeAccessors("mixedInProperty", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &mixedInProperty_getterinfo, GenericSetter<NormalThisPolicy>, &mixedInProperty_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestInterface", JSPROP_READONLY),
  JS_PS_END
};

static const PrefableDisablers sAttributes_disablers69 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers72 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers75 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers77 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers80 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers82 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers84 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers87 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers90 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers92 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers94 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers96 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers69, &sAttributes_specs[69] },
  { &sAttributes_disablers72, &sAttributes_specs[72] },
  { &sAttributes_disablers75, &sAttributes_specs[75] },
  { &sAttributes_disablers77, &sAttributes_specs[77] },
  { &sAttributes_disablers80, &sAttributes_specs[80] },
  { &sAttributes_disablers82, &sAttributes_specs[82] },
  { &sAttributes_disablers84, &sAttributes_specs[84] },
  { &sAttributes_disablers87, &sAttributes_specs[87] },
  { &sAttributes_disablers90, &sAttributes_specs[90] },
  { &sAttributes_disablers92, &sAttributes_specs[92] },
  { &sAttributes_disablers94, &sAttributes_specs[94] },
  { &sAttributes_disablers96, &sAttributes_specs[96] },
  { nullptr, &sAttributes_specs[98] },
  { nullptr, nullptr }
};

static_assert(14 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(68 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("putForwardsAttr3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr3_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr3_setterinfo),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sUnforgeableMethods_specs[] = {
  JS_FNSPEC("unforgeableMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&unforgeableMethod_methodinfo), 0, JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sUnforgeableMethods[] = {
  { nullptr, &sUnforgeableMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeUnforgeableMethods_specs[] = {
  JS_FNSPEC("unforgeableMethod2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&unforgeableMethod2_methodinfo), 0, JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sChromeUnforgeableMethods[] = {
  { nullptr, &sChromeUnforgeableMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sUnforgeableAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("unforgeableAttr", JSPROP_ENUMERATE | JSPROP_PERMANENT, GenericGetter<NormalThisPolicy, ThrowExceptions>, &unforgeableAttr_getterinfo, nullptr, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sUnforgeableAttributes[] = {
  { nullptr, &sUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeUnforgeableAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("unforgeableAttr2", JSPROP_ENUMERATE | JSPROP_PERMANENT, GenericGetter<NormalThisPolicy, ThrowExceptions>, &unforgeableAttr2_getterinfo, nullptr, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sChromeUnforgeableAttributes[] = {
  { nullptr, &sChromeUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const ConstantSpec sConstants_specs[] = {
  { "myLongConstant", JS::Int32Value(5) },
  { "nonEnumerableConst", JS::BooleanValue(true) },
  { "mixedInConstant", JS::Int32Value(5) },
  { 0, JS::UndefinedValue() }
};


static const Prefable<const ConstantSpec> sConstants[] = {
  { nullptr, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[543];
static PropertyInfo sNativeProperties_propertyInfos[543];

static const NativePropertiesN<7> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  true,  1 /* sStaticAttributes */,
  true,  2 /* sMethods */,
  true,  3 /* sAttributes */,
  true,  4 /* sUnforgeableMethods */,
  true,  5 /* sUnforgeableAttributes */,
  true,  6 /* sConstants */,
  -1,
  543,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] },
    { sStaticAttributes, &sNativeProperties_propertyInfos[5] },
    { sMethods, &sNativeProperties_propertyInfos[7] },
    { sAttributes, &sNativeProperties_propertyInfos[428] },
    { sUnforgeableMethods, &sNativeProperties_propertyInfos[538] },
    { sUnforgeableAttributes, &sNativeProperties_propertyInfos[539] },
    { sConstants, &sNativeProperties_propertyInfos[540] }
  }
};
static_assert(543 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static uint16_t sChromeOnlyNativeProperties_sortedPropertyIndices[4];
static PropertyInfo sChromeOnlyNativeProperties_propertyInfos[4];

static const NativePropertiesN<4> sChromeOnlyNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sChromeMethods */,
  true,  1 /* sChromeAttributes */,
  true,  2 /* sChromeUnforgeableMethods */,
  true,  3 /* sChromeUnforgeableAttributes */,
  false, 0,
  -1,
  4,
  sChromeOnlyNativeProperties_sortedPropertyIndices,
  {
    { sChromeMethods, &sChromeOnlyNativeProperties_propertyInfos[0] },
    { sChromeAttributes, &sChromeOnlyNativeProperties_propertyInfos[1] },
    { sChromeUnforgeableMethods, &sChromeOnlyNativeProperties_propertyInfos[2] },
    { sChromeUnforgeableAttributes, &sChromeOnlyNativeProperties_propertyInfos[3] }
  }
};
static_assert(4 < 1ull << (CHAR_BIT * sizeof(sChromeOnlyNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

MOZ_CAN_RUN_SCRIPT bool
CollectJSONAttributes(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::TestInterface* self, JS::Rooted<JSObject*>& result)
{
  JS::Rooted<JSObject*> unwrappedObj(cx, js::CheckedUnwrapStatic(obj));
  if (!unwrappedObj) {
    // How did that happen?  We managed to get called with that
    // object as "this"!  Just give up on sanity.
    return false;
  }

  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedConstantByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedConstantByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedWritableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedWritableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_sideEffectFreeByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "sideEffectFreeByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_domDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "domDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_constantByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "constantByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deviceStateDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deviceStateDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientFloatAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientFloatAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientDoubleAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientDoubleAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonNullSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonNullSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nullableSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nullableSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlySequence(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlySequence", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyJSStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyJSStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_jsStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "jsStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyEnumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyEnumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeGetterRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeGetterRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedNullableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedNullableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedNullableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedNullableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deprecatedAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deprecatedAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable5, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable5(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable5", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable6, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable6(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable6", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable7, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable7(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable7", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable8, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable8(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable8", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable9, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable9(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable9", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable12, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable12(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable12", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable14, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable14(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable14", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable15, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable15(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable15", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable16, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable16(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable16", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attrWithLenientThis(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attrWithLenientThis", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_unforgeableAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "unforgeableAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_unforgeableAttr2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "unforgeableAttr2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsSubjectPrincipalAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsSubjectPrincipalAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsCallerTypeAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsCallerTypeAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsNonSystemSubjectPrincipalAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsNonSystemSubjectPrincipalAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_ceReactionsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "ceReactionsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_dashed_attribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "dashed_attribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonEnumerableAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonEnumerableAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_mixedInProperty(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "mixedInProperty", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  return true;
}

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestInterface constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = nullptr;
        GlobalObject global(cx, obj);
        if (global.Failed()) {
          return false;
        }

        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        Maybe<JSAutoRealm> ar;
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          obj = js::CheckedUnwrapStatic(obj);
          if (!obj) {
            return false;
          }
          ar.emplace(cx, obj);
          if (!JS_WrapObject(cx, &desiredProto)) {
            return false;
          }
        }
        auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)))));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        static_assert(!std::is_pointer_v<decltype(result)>,
                      "NewObject implies that we need to keep the object alive with a strong reference.");
        if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (args[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsArrayBufferViewShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferView(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, NonNullHelper(Constify(arg0)))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (args[1].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg1;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, arg0, MOZ_KnownLive(NonNullHelper(arg1)))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Nullable<bool> arg1;
      if (args[1].isNullOrUndefined()) {
        arg1.SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, args[1], "Argument 2", &arg1.SetValue())) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(mozilla::dom::TestInterface::Constructor(global, arg0, Constify(arg1))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE + 6 /* slots for the named constructors */),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  sNativePropertyHooks,
  "function TestInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

const NativePropertyHooks sNamedConstructorNativePropertyHooks = {
    nullptr,
    nullptr,
    nullptr,
    { nullptr, nullptr },
    prototypes::id::TestInterface,
    constructors::id::TestInterface,
    nullptr
};

static const NamedConstructor namedConstructors[] = {
  { "Test", { _Test, &sNamedConstructorNativePropertyHooks }, 0 },
  { "Test2", { _Test2, &sNamedConstructorNativePropertyHooks }, 5 },
  { "Test3", { _Test3, &sNamedConstructorNativePropertyHooks }, 1 },
  { "Test4", { _Test4, &sNamedConstructorNativePropertyHooks }, 1 },
  { "Test5", { _Test5, &sNamedConstructorNativePropertyHooks }, 1 },
  { "Test6", { _Test6, &sNamedConstructorNativePropertyHooks }, 1 },
  { nullptr, { nullptr, nullptr }, 0 }
};

MOZ_CAN_RUN_SCRIPT static bool
_legacycaller(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestInterface legacy caller");
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  mozilla::dom::TestInterface* self;
  JS::Rooted<JS::Value> rootSelf(cx, JS::ObjectValue(*obj));
  {
    // Our JSContext should be in the right global to do unwrapping in.
    nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&rootSelf, self, cx);
    if (NS_FAILED(rv)) {
      MOZ_CRASH("Unexpected object in '_legacycaller' hook");
      return false;
    }
  }
  if (!args.requireAtLeast(cx, "TestInterface legacy caller", 2)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg1;
  if (args[1].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
    return false;
  }
  int16_t result(MOZ_KnownLive(self)->LegacyCall(args.thisv(), arg0, MOZ_KnownLive(NonNullHelper(arg1))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE + 1 /* slot for the JSObject holding the unforgeable properties */),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestInterface,
  PrototypeTraits<prototypes::id::TestInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  _legacycaller, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(16),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(16 >= 16,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

static bool
UpdateMemberSlots(JSContext* aCx, JS::Handle<JSObject*> aWrapper, mozilla::dom::TestInterface* aObject)
{
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);

  static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) < JS::shadow::Object::MAX_FIXED_SLOTS,
                "Not enough fixed slots to fit 'TestInterface.cachedByte.  Ion's visitGetDOMMemberV/visitGetDOMMemberT assume StoreInSlot things are all in fixed slots.");
  if (!get_cachedByte(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < JS::shadow::Object::MAX_FIXED_SLOTS,
                "Not enough fixed slots to fit 'TestInterface.cachedConstantByte.  Ion's visitGetDOMMemberV/visitGetDOMMemberT assume StoreInSlot things are all in fixed slots.");
  if (!get_cachedConstantByte(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) < JS::shadow::Object::MAX_FIXED_SLOTS,
                "Not enough fixed slots to fit 'TestInterface.cachedWritableByte.  Ion's visitGetDOMMemberV/visitGetDOMMemberT assume StoreInSlot things are all in fixed slots.");
  if (!get_cachedWritableByte(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  return true;
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);

  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  JS::Rooted<JSObject*> unforgeableHolder(aCx,
    &JS::GetReservedSlot(canonicalProto, DOM_INTERFACE_PROTO_SLOTS_BASE).toObject());
  if (!JS_InitializePropertiesFromCompatibleNativeObject(aCx, aReflector, unforgeableHolder)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  if (!UpdateMemberSlots(aCx, aReflector, aObject)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

// This may allocate too many slots, because we only really need
// slots for our non-interface-typed members that we cache.  But
// allocating slots only for those would make the slot index
// computations much more complicated, so let's do this the simple
// way for now.
DEFINE_XRAY_EXPANDO_CLASS(static, sXrayExpandoObjectClass, 15);

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::TestInterface,
  constructors::id::TestInterface,
  nullptr,
  &sXrayExpandoObjectClass
} };

bool
ClearCachedCachedByteValue(JSContext* aCx, mozilla::dom::TestInterface* aObject)
{
  JS::Rooted<JSObject*> obj(aCx);
  obj = aObject->GetWrapper();
  if (!obj) {
    return true;
  }
  JS::Rooted<JS::Value> oldValue(aCx, JS::GetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 0)));
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 0), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 0));
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);
  JSAutoRealm ar(aCx, obj);
  if (!get_cachedByte(aCx, obj, aObject, args)) {
    JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 0), oldValue);
    return false;
  }
  return true;
}

bool
ClearCachedCachedWritableByteValue(JSContext* aCx, mozilla::dom::TestInterface* aObject)
{
  JS::Rooted<JSObject*> obj(aCx);
  obj = aObject->GetWrapper();
  if (!obj) {
    return true;
  }
  JS::Rooted<JS::Value> oldValue(aCx, JS::GetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2)));
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 2));
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);
  JSAutoRealm ar(aCx, obj);
  if (!get_cachedWritableByte(aCx, obj, aObject, args)) {
    JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2), oldValue);
    return false;
  }
  return true;
}

void
ClearCachedCachedSelfValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 3), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 3));
}

void
ClearCachedReadonlySequenceValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 4), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 4));
}

void
ClearCachedReadonlySequenceOfDictionariesValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 5), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 5));
}

void
ClearCachedReadonlyNullableSequenceOfDictionariesValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 6), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 6));
}

void
ClearCachedReadonlyFrozenSequenceValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 7), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 7));
}

void
ClearCachedReadonlyFrozenNullableSequenceValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 8), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 8));
}

void
ClearCachedReadonlyDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 9), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 9));
}

void
ClearCachedReadonlyNullableDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 10), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 10));
}

void
ClearCachedWritableDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 11), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 11));
}

void
ClearCachedReadonlyFrozenDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 12), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 12));
}

void
ClearCachedReadonlyFrozenNullableDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 13), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 13));
}

void
ClearCachedWritableFrozenDictionaryValue(mozilla::dom::TestInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 14), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 14));
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    if (!InitIds(aCx, sChromeOnlyNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, namedConstructors,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              sChromeOnlyNativeProperties.Upcast(),
                              "TestInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);

  JS::Rooted<JSObject*> unforgeableHolder(aCx);
  {
    JS::Rooted<JSObject*> holderProto(aCx, *protoCache);
    unforgeableHolder = JS_NewObjectWithoutMetadata(aCx, sClass.ToJSClass(), holderProto);
    if (!unforgeableHolder) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }

  if (!DefineUnforgeableAttributes(aCx, unforgeableHolder, sUnforgeableAttributes)) {
    *protoCache = nullptr;
    if (interfaceCache) {
      *interfaceCache = nullptr;
    }
    return;
  }
  if (nsContentUtils::ThreadsafeIsSystemCaller(aCx)) {
    if (!DefineUnforgeableAttributes(aCx, unforgeableHolder, sChromeUnforgeableAttributes)) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }
  if (!DefineUnforgeableMethods(aCx, unforgeableHolder, sUnforgeableMethods)) {
    *protoCache = nullptr;
    if (interfaceCache) {
      *interfaceCache = nullptr;
    }
    return;
  }
  if (nsContentUtils::ThreadsafeIsSystemCaller(aCx)) {
    if (!DefineUnforgeableMethods(aCx, unforgeableHolder, sChromeUnforgeableMethods)) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }

  if (*protoCache) {
    JS::SetReservedSlot(*protoCache, DOM_INTERFACE_PROTO_SLOTS_BASE,
                        JS::ObjectValue(*unforgeableHolder));
  }
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestInterface_Binding



namespace TestInterfaceWithPromiseConstructorArg_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestInterfaceWithPromiseConstructorArg* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestInterfaceWithPromiseConstructorArg* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestInterfaceWithPromiseConstructorArg* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestInterfaceWithPromiseConstructorArg* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestInterfaceWithPromiseConstructorArg", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestInterfaceWithPromiseConstructorArg", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestInterfaceWithPromiseConstructorArg");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestInterfaceWithPromiseConstructorArg,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "TestInterfaceWithPromiseConstructorArg constructor", 1)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  OwningNonNull<Promise> arg0;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    globalObj = JS::CurrentGlobalOrNull(cx);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      return false;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      return false;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      return false;
    }
    arg0 = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      return false;
    }
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestInterfaceWithPromiseConstructorArg>(mozilla::dom::TestInterfaceWithPromiseConstructorArg::Constructor(global, NonNullHelper(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestInterfaceWithPromiseConstructorArg,
  PrototypeTraits<prototypes::id::TestInterfaceWithPromiseConstructorArg>::Depth,
  sNativePropertyHooks,
  "function TestInterfaceWithPromiseConstructorArg() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestInterfaceWithPromiseConstructorArgPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestInterfaceWithPromiseConstructorArg,
  PrototypeTraits<prototypes::id::TestInterfaceWithPromiseConstructorArg>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestInterfaceWithPromiseConstructorArg",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestInterfaceWithPromiseConstructorArg, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestInterfaceWithPromiseConstructorArg>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestInterfaceWithPromiseConstructorArg>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestInterfaceWithPromiseConstructorArg>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestInterfaceWithPromiseConstructorArg* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestInterfaceWithPromiseConstructorArg>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestInterfaceWithPromiseConstructorArg*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestInterfaceWithPromiseConstructorArg*>(aObject),
             "Multiple inheritance for mozilla::dom::TestInterfaceWithPromiseConstructorArg is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestInterfaceWithPromiseConstructorArg> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestInterfaceWithPromiseConstructorArg,
  constructors::id::TestInterfaceWithPromiseConstructorArg,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestInterfaceWithPromiseConstructorArg);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestInterfaceWithPromiseConstructorArg);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 1, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestInterfaceWithPromiseConstructorArg", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestInterfaceWithPromiseConstructorArg_Binding



namespace TestNamedDeleterInterface_Binding {

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestNamedDeleterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestNamedDeleterInterface,
  PrototypeTraits<prototypes::id::TestNamedDeleterInterface>::Depth,
  sNativePropertyHooks,
  "function TestNamedDeleterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestNamedDeleterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestNamedDeleterInterface,
  PrototypeTraits<prototypes::id::TestNamedDeleterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestNamedDeleterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedDeleterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedDeleterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        desc.value().setInt32(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
      int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  bool expandoHasProp = false;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
        return false;
      }

      if (expandoHasProp) {
        // Forward the get to the expando object, but our receiver is whatever our
        // receiver is.
        if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
          return false;
        }
      }
    }
  }

  if (expandoHasProp) {
    return true;
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestNamedDeleterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestNamedDeleterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedDeleterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestNamedDeleterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
    }
    deleteSucceeded = true;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestNamedDeleterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedDeleterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestNamedDeleterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestNamedDeleterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestNamedDeleterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestNamedDeleterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestNamedDeleterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestNamedDeleterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestNamedDeleterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedDeleterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedDeleterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestNamedDeleterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestNamedDeleterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

static bool
DeleteNamedProperty(JSContext* cx, JS::Handle<JSObject*> xray, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult)
{
  MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(xray));
  MOZ_ASSERT(js::IsProxy(proxy));
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy));
  JSAutoRealm ar(cx, proxy);
  bool deleteSucceeded = false;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterInterface* self = UnwrapProxy(proxy);
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
  }
  deleteSucceeded = true;
  if (!found || deleteSucceeded) {
    return opresult.succeed();
  }
  return opresult.failCantDelete();
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  DeleteNamedProperty,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestNamedDeleterInterface,
  constructors::id::TestNamedDeleterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestNamedDeleterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNamedDeleterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNamedDeleterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNamedDeleterInterface_Binding



namespace TestNamedDeleterWithRetvalInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
delNamedItem(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestNamedDeleterWithRetvalInterface", "delNamedItem", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestNamedDeleterWithRetvalInterface.delNamedItem", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  bool result(MOZ_KnownLive(self)->DelNamedItem(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo delNamedItem_methodinfo = {
  { (JSJitGetterOp)delNamedItem },
  { prototypes::id::TestNamedDeleterWithRetvalInterface },
  { PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("delNamedItem", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&delNamedItem_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestNamedDeleterWithRetvalInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestNamedDeleterWithRetvalInterface,
  PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>::Depth,
  sNativePropertyHooks,
  "function TestNamedDeleterWithRetvalInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestNamedDeleterWithRetvalInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestNamedDeleterWithRetvalInterface,
  PrototypeTraits<prototypes::id::TestNamedDeleterWithRetvalInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestNamedDeleterWithRetvalInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedDeleterWithRetvalInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
      bool found = false;
      int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        desc.value().setInt32(int32_t(result));
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
      int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  bool expandoHasProp = false;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
        return false;
      }

      if (expandoHasProp) {
        // Forward the get to the expando object, but our receiver is whatever our
        // receiver is.
        if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
          return false;
        }
      }
    }
  }

  if (expandoHasProp) {
    return true;
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestNamedDeleterWithRetvalInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedDeleterWithRetvalInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestNamedDeleterWithRetvalInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
      deleteSucceeded = MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
    }
    if (!found) {
      deleteSucceeded = true;
    }
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedDeleterWithRetvalInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestNamedDeleterWithRetvalInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestNamedDeleterWithRetvalInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestNamedDeleterWithRetvalInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestNamedDeleterWithRetvalInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestNamedDeleterWithRetvalInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestNamedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestNamedDeleterWithRetvalInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedDeleterWithRetvalInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestNamedDeleterWithRetvalInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestNamedDeleterWithRetvalInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

static bool
DeleteNamedProperty(JSContext* cx, JS::Handle<JSObject*> xray, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult)
{
  MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(xray));
  MOZ_ASSERT(js::IsProxy(proxy));
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy));
  JSAutoRealm ar(cx, proxy);
  bool deleteSucceeded = false;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedDeleterWithRetvalInterface* self = UnwrapProxy(proxy);
    deleteSucceeded = MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(name)), found);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
  }
  if (!found) {
    deleteSucceeded = true;
  }
  if (!found || deleteSucceeded) {
    return opresult.succeed();
  }
  return opresult.failCantDelete();
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  DeleteNamedProperty,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestNamedDeleterWithRetvalInterface,
  constructors::id::TestNamedDeleterWithRetvalInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestNamedDeleterWithRetvalInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNamedDeleterWithRetvalInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNamedDeleterWithRetvalInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNamedDeleterWithRetvalInterface_Binding



namespace TestNamedGetterInterface_Binding {

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestNamedGetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestNamedGetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestNamedGetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestNamedGetterInterface,
  PrototypeTraits<prototypes::id::TestNamedGetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestNamedGetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedGetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedGetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!xpc::NonVoidStringToJsval(cx, result, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
    DOMString result;
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  bool expandoHasProp = false;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
        return false;
      }

      if (expandoHasProp) {
        // Forward the get to the expando object, but our receiver is whatever our
        // receiver is.
        if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
          return false;
        }
      }
    }
  }

  if (expandoHasProp) {
    return true;
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    DOMString result;
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      if (!xpc::NonVoidStringToJsval(cx, result, vp)) {
        return false;
      }
      return true;
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestNamedGetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedGetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestNamedGetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedGetterInterface* self = UnwrapProxy(proxy);
      DOMString result;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found, result);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestNamedGetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedGetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestNamedGetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestNamedGetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestNamedGetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestNamedGetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestNamedGetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestNamedGetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedGetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedGetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestNamedGetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestNamedGetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestNamedGetterInterface,
  constructors::id::TestNamedGetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestNamedGetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNamedGetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNamedGetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNamedGetterInterface_Binding



namespace TestNamedSetterInterface_Binding {

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestNamedSetterInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestNamedSetterInterface,
  PrototypeTraits<prototypes::id::TestNamedSetterInterface>::Depth,
  sNativePropertyHooks,
  "function TestNamedSetterInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestNamedSetterInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestNamedSetterInterface,
  PrototypeTraits<prototypes::id::TestNamedSetterInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestNamedSetterInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestNamedSetterInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestNamedSetterInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
      bool found = false;
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        if (!GetOrCreateDOMReflector(cx, result, desc.value())) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        FillPropertyDescriptor(desc, proxy, false, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  BindingCallContext cx(cx_, "TestNamedSetterInterface named setter");
  FakeString<char16_t> myName;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, myName, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    NonNull<mozilla::dom::TestIndexedSetterInterface> item;
    if (desc.value().isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestIndexedSetterInterface, mozilla::dom::TestIndexedSetterInterface>(&rootedValue, item, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned to TestNamedSetterInterface setter", "TestIndexedSetterInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned to TestNamedSetterInterface setter");
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(myName)), MOZ_KnownLive(NonNullHelper(item))))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(myName)), MOZ_KnownLive(NonNullHelper(item)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return opresult.succeed();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  bool expandoHasProp = false;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
        return false;
      }

      if (expandoHasProp) {
        // Forward the get to the expando object, but our receiver is whatever our
        // receiver is.
        if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
          return false;
        }
      }
    }
  }

  if (expandoHasProp) {
    return true;
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
    bool found = false;
    auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      if (!GetOrCreateDOMReflector(cx, result, vp)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestNamedSetterInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestNamedSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedSetterInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestNamedSetterInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestNamedSetterInterface* self = UnwrapProxy(proxy);
      auto result(StrongOrRawPtr<mozilla::dom::TestIndexedSetterInterface>(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(name)), found)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestNamedSetterInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNamedSetterInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestNamedSetterInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestNamedSetterInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestNamedSetterInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestNamedSetterInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestNamedSetterInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestNamedSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestNamedSetterInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestNamedSetterInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNamedSetterInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestNamedSetterInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestNamedSetterInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestNamedSetterInterface,
  constructors::id::TestNamedSetterInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestNamedSetterInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNamedSetterInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNamedSetterInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNamedSetterInterface_Binding



namespace TestNamespace_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_foo(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestNamespace", "foo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool result(mozilla::dom::TestNamespace::Foo(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
bar(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestNamespace", "bar", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  int32_t result(mozilla::dom::TestNamespace::Bar(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
baz(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestNamespace", "baz", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestNamespace::Baz(global))>, "Should be returning void here");
  mozilla::dom::TestNamespace::Baz(global);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("bar", bar, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("baz", baz, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sStaticAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("foo", JSPROP_ENUMERATE, get_foo, nullptr, nullptr, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sStaticAttributes[] = {
  { nullptr, &sStaticAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[3];
static PropertyInfo sNativeProperties_propertyInfos[3];

static const NativePropertiesN<2> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  true,  1 /* sStaticAttributes */,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  -1,
  3,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] },
    { sStaticAttributes, &sNativeProperties_propertyInfos[2] }
  }
};
static_assert(3 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Object",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterface,
  false,
  prototypes::id::_ID_Count,
  0,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::_ID_Count,
  constructors::id::TestNamespace,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = nullptr;
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNamespace);
  dom::CreateInterfaceObjects(aCx, aGlobal, nullptr,
                              nullptr, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNamespace", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              true);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNamespace_Binding



namespace TestNonWrapperCacheInterface_Binding {

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestNonWrapperCacheInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestNonWrapperCacheInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestNonWrapperCacheInterface>(self);
  }
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestNonWrapperCacheInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestNonWrapperCacheInterface,
  PrototypeTraits<prototypes::id::TestNonWrapperCacheInterface>::Depth,
  sNativePropertyHooks,
  "function TestNonWrapperCacheInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestNonWrapperCacheInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestNonWrapperCacheInterface,
  PrototypeTraits<prototypes::id::TestNonWrapperCacheInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  nullptr, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  nullptr /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestNonWrapperCacheInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestNonWrapperCacheInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestNonWrapperCacheInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestNonWrapperCacheInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestNonWrapperCacheInterface>::Get(),
  nullptr,
  nullptr
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestNonWrapperCacheInterface* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TestNonWrapperCacheInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestNonWrapperCacheInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestNonWrapperCacheInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));

  JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestNonWrapperCacheInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }



  creator.InitializationSucceeded();
  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestNonWrapperCacheInterface,
  constructors::id::TestNonWrapperCacheInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestNonWrapperCacheInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestNonWrapperCacheInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestNonWrapperCacheInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestNonWrapperCacheInterface_Binding



namespace TestParentInterface_Binding {

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestParentInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestParentInterface,
  PrototypeTraits<prototypes::id::TestParentInterface>::Depth,
  sNativePropertyHooks,
  "function TestParentInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestParentInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestParentInterface,
  PrototypeTraits<prototypes::id::TestParentInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestParentInterface,
  constructors::id::TestParentInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestParentInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestParentInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestParentInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestParentInterface_Binding



namespace TestPrefChromeOnlySCFuncConstructorForInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestPrefChromeOnlySCFuncConstructorForInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestPrefChromeOnlySCFuncConstructorForInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!StaticPrefs::dom_webidl_test1() ||
      !nsContentUtils::ThreadsafeIsSystemCaller(cx) ||
      !Document::IsWebAnimationsEnabled(cx, obj) ||
      !mozilla::dom::IsSecureContextOrObjectIsFromSecureContext(cx, obj)) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestPrefChromeOnlySCFuncConstructorForInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>(mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface,
  PrototypeTraits<prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface>::Depth,
  sNativePropertyHooks,
  "function TestPrefChromeOnlySCFuncConstructorForInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestPrefChromeOnlySCFuncConstructorForInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface,
  PrototypeTraits<prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestPrefChromeOnlySCFuncConstructorForInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface,
  constructors::id::TestPrefChromeOnlySCFuncConstructorForInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestPrefChromeOnlySCFuncConstructorForInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestPrefChromeOnlySCFuncConstructorForInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestPrefChromeOnlySCFuncConstructorForInterface_Binding



namespace TestPrefConstructorForDifferentPrefInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestPrefConstructorForDifferentPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestPrefConstructorForDifferentPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestPrefConstructorForDifferentPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestPrefConstructorForDifferentPrefInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestPrefConstructorForDifferentPrefInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestPrefConstructorForDifferentPrefInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!StaticPrefs::dom_webidl_test2()) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestPrefConstructorForDifferentPrefInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestPrefConstructorForDifferentPrefInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>(mozilla::dom::TestPrefConstructorForDifferentPrefInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestPrefConstructorForDifferentPrefInterface,
  PrototypeTraits<prototypes::id::TestPrefConstructorForDifferentPrefInterface>::Depth,
  sNativePropertyHooks,
  "function TestPrefConstructorForDifferentPrefInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestPrefConstructorForDifferentPrefInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestPrefConstructorForDifferentPrefInterface,
  PrototypeTraits<prototypes::id::TestPrefConstructorForDifferentPrefInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return StaticPrefs::dom_webidl_test1();
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestPrefConstructorForDifferentPrefInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestPrefConstructorForDifferentPrefInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestPrefConstructorForDifferentPrefInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestPrefConstructorForDifferentPrefInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestPrefConstructorForDifferentPrefInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestPrefConstructorForDifferentPrefInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestPrefConstructorForDifferentPrefInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestPrefConstructorForDifferentPrefInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestPrefConstructorForDifferentPrefInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestPrefConstructorForDifferentPrefInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestPrefConstructorForDifferentPrefInterface,
  constructors::id::TestPrefConstructorForDifferentPrefInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestPrefConstructorForDifferentPrefInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestPrefConstructorForDifferentPrefInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestPrefConstructorForDifferentPrefInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestPrefConstructorForDifferentPrefInterface_Binding



namespace TestPrefConstructorForInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestPrefConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestPrefConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestPrefConstructorForInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestPrefConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestPrefConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestPrefConstructorForInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestPrefConstructorForInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestPrefConstructorForInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!StaticPrefs::dom_webidl_test1()) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestPrefConstructorForInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestPrefConstructorForInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestPrefConstructorForInterface>(mozilla::dom::TestPrefConstructorForInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestPrefConstructorForInterface,
  PrototypeTraits<prototypes::id::TestPrefConstructorForInterface>::Depth,
  sNativePropertyHooks,
  "function TestPrefConstructorForInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestPrefConstructorForInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestPrefConstructorForInterface,
  PrototypeTraits<prototypes::id::TestPrefConstructorForInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestPrefConstructorForInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestPrefConstructorForInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestPrefConstructorForInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestPrefConstructorForInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestPrefConstructorForInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestPrefConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestPrefConstructorForInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestPrefConstructorForInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestPrefConstructorForInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestPrefConstructorForInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestPrefConstructorForInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestPrefConstructorForInterface,
  constructors::id::TestPrefConstructorForInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestPrefConstructorForInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestPrefConstructorForInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestPrefConstructorForInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestPrefConstructorForInterface_Binding



namespace TestProtoObjectHackedNamespace_Binding {

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Object",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterface,
  false,
  prototypes::id::_ID_Count,
  0,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { nullptr, nullptr },
  prototypes::id::_ID_Count,
  constructors::id::TestProtoObjectHackedNamespace,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> constructorProto(aCx, GetHackedNamespaceProtoObject(aCx));
  if (!constructorProto) {
    return;
  }

  JS::Heap<JSObject*>* protoCache = nullptr;
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestProtoObjectHackedNamespace);
  dom::CreateInterfaceObjects(aCx, aGlobal, nullptr,
                              nullptr, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              nullptr,
                              nullptr,
                              "TestProtoObjectHackedNamespace", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              true);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestProtoObjectHackedNamespace_Binding



namespace TestRenamedInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  nsRenamedInterface* self = UnwrapPossiblyNotInitializedDOMObject<nsRenamedInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  nsRenamedInterface* self = UnwrapPossiblyNotInitializedDOMObject<nsRenamedInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<nsRenamedInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  nsRenamedInterface* self = UnwrapPossiblyNotInitializedDOMObject<nsRenamedInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  nsRenamedInterface* self = UnwrapPossiblyNotInitializedDOMObject<nsRenamedInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestRenamedInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestRenamedInterface,
  PrototypeTraits<prototypes::id::TestRenamedInterface>::Depth,
  sNativePropertyHooks,
  "function TestRenamedInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestRenamedInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestRenamedInterface,
  PrototypeTraits<prototypes::id::TestRenamedInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return StaticPrefs::dom_webidl_test1();
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestRenamedInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestRenamedInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, nsRenamedInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<nsRenamedInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<nsRenamedInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, nsRenamedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, nsRenamedInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<nsRenamedInterface*>(aObject) ==
             reinterpret_cast<nsRenamedInterface*>(aObject),
             "Multiple inheritance for nsRenamedInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<nsRenamedInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestRenamedInterface,
  constructors::id::TestRenamedInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestRenamedInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestRenamedInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestRenamedInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestRenamedInterface_Binding



namespace TestRenamedNamespace_Binding {

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "RenamedNamespaceClassName",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterface,
  false,
  prototypes::id::_ID_Count,
  0,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { nullptr, nullptr },
  prototypes::id::_ID_Count,
  constructors::id::TestRenamedNamespace,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  JS::Heap<JSObject*>* protoCache = nullptr;
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestRenamedNamespace);
  dom::CreateInterfaceObjects(aCx, aGlobal, nullptr,
                              nullptr, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              nullptr,
                              nullptr,
                              "TestRenamedNamespace", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              true);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestRenamedNamespace_Binding



namespace TestSCConstructorForInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestSCConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSCConstructorForInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestSCConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSCConstructorForInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestSCConstructorForInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestSCConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSCConstructorForInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestSCConstructorForInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSCConstructorForInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestSCConstructorForInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestSCConstructorForInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!mozilla::dom::IsSecureContextOrObjectIsFromSecureContext(cx, obj)) {
    return ThrowingConstructor(cx, argc, vp);
  }

  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestSCConstructorForInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestSCConstructorForInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestSCConstructorForInterface>(mozilla::dom::TestSCConstructorForInterface::Constructor(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestSCConstructorForInterface,
  PrototypeTraits<prototypes::id::TestSCConstructorForInterface>::Depth,
  sNativePropertyHooks,
  "function TestSCConstructorForInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestSCConstructorForInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestSCConstructorForInterface,
  PrototypeTraits<prototypes::id::TestSCConstructorForInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestSCConstructorForInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestSCConstructorForInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestSCConstructorForInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestSCConstructorForInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestSCConstructorForInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestSCConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestSCConstructorForInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestSCConstructorForInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestSCConstructorForInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestSCConstructorForInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestSCConstructorForInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestSCConstructorForInterface,
  constructors::id::TestSCConstructorForInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestSCConstructorForInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestSCConstructorForInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestSCConstructorForInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestSCConstructorForInterface_Binding



namespace TestSecureContextInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
alsoSecureContext(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestSecureContextInterface", "alsoSecureContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestSecureContextInterface::AlsoSecureContext(global))>, "Should be returning void here");
  mozilla::dom::TestSecureContextInterface::AlsoSecureContext(global);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestSecureContextInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSecureContextInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestSecureContextInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSecureContextInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestSecureContextInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestSecureContextInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSecureContextInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestSecureContextInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestSecureContextInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("alsoSecureContext", alsoSecureContext, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sStaticMethods_disablers0 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { &sStaticMethods_disablers0, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestSecureContextInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  false, 0,
  false, 0,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestSecureContextInterface,
  PrototypeTraits<prototypes::id::TestSecureContextInterface>::Depth,
  sNativePropertyHooks,
  "function TestSecureContextInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestSecureContextInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestSecureContextInterface,
  PrototypeTraits<prototypes::id::TestSecureContextInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return mozilla::dom::IsSecureContextOrObjectIsFromSecureContext(aCx, aObj);
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestSecureContextInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestSecureContextInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestSecureContextInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestSecureContextInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestSecureContextInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestSecureContextInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestSecureContextInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestSecureContextInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestSecureContextInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestSecureContextInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestSecureContextInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestSecureContextInterface,
  constructors::id::TestSecureContextInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestSecureContextInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestSecureContextInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestSecureContextInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestSecureContextInterface_Binding



namespace TestThrowingConstructorInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestThrowingConstructorInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestThrowingConstructorInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestThrowingConstructorInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestThrowingConstructorInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestThrowingConstructorInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestThrowingConstructorInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestThrowingConstructorInterface constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestThrowingConstructorInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestThrowingConstructorInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestThrowingConstructorInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = nullptr;
        GlobalObject global(cx, obj);
        if (global.Failed()) {
          return false;
        }

        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        Maybe<JSAutoRealm> ar;
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          obj = js::CheckedUnwrapStatic(obj);
          if (!obj) {
            return false;
          }
          ar.emplace(cx, obj);
          if (!JS_WrapObject(cx, &desiredProto)) {
            return false;
          }
        }
        FastErrorResult rv;
        auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)), rv)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        static_assert(!std::is_pointer_v<decltype(result)>,
                      "NewObject implies that we need to keep the object alive with a strong reference.");
        if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (args[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, Constify(arg0), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsArrayBufferViewShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferView(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, Constify(arg0), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, NonNullHelper(Constify(arg0)), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (args[1].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg1;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, arg0, MOZ_KnownLive(NonNullHelper(arg1)), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Nullable<bool> arg1;
      if (args[1].isNullOrUndefined()) {
        arg1.SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, args[1], "Argument 2", &arg1.SetValue())) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestThrowingConstructorInterface>(mozilla::dom::TestThrowingConstructorInterface::Constructor(global, arg0, Constify(arg1), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestThrowingConstructorInterface,
  PrototypeTraits<prototypes::id::TestThrowingConstructorInterface>::Depth,
  sNativePropertyHooks,
  "function TestThrowingConstructorInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestThrowingConstructorInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestThrowingConstructorInterface,
  PrototypeTraits<prototypes::id::TestThrowingConstructorInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestThrowingConstructorInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestThrowingConstructorInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestThrowingConstructorInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestThrowingConstructorInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestThrowingConstructorInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestThrowingConstructorInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestThrowingConstructorInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestThrowingConstructorInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestThrowingConstructorInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestThrowingConstructorInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestThrowingConstructorInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestThrowingConstructorInterface,
  constructors::id::TestThrowingConstructorInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestThrowingConstructorInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestThrowingConstructorInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestThrowingConstructorInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestThrowingConstructorInterface_Binding



namespace TestWorkerExposedInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
needsSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsSubjectPrincipalMethod },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  bool result(MOZ_KnownLive(self)->NeedsSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsSubjectPrincipalAttr_getterinfo = {
  { get_needsSubjectPrincipalAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsSubjectPrincipalAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsCallerTypeMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsCallerTypeMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsCallerTypeMethod_methodinfo = {
  { (JSJitGetterOp)needsCallerTypeMethod },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NeedsCallerTypeAttr(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsCallerTypeAttr_getterinfo = {
  { get_needsCallerTypeAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsCallerTypeAttr_setterinfo = {
  { (JSJitGetterOp)set_needsCallerTypeAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsNonSystemSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsNonSystemSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsNonSystemSubjectPrincipalMethod },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  bool result(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestWorkerExposedInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestWorkerExposedInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalAttr_getterinfo = {
  { get_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsNonSystemSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestWorkerExposedInterface },
  { PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestWorkerExposedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestWorkerExposedInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestWorkerExposedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestWorkerExposedInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestWorkerExposedInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestWorkerExposedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestWorkerExposedInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestWorkerExposedInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestWorkerExposedInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("needsSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsCallerTypeMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsCallerTypeMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsNonSystemSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsNonSystemSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("needsSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsCallerTypeAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsCallerTypeAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsCallerTypeAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsNonSystemSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsNonSystemSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsNonSystemSubjectPrincipalAttr_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestWorkerExposedInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[7];
static PropertyInfo sNativeProperties_propertyInfos[7];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  7,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[3] }
  }
};
static_assert(7 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestWorkerExposedInterface,
  PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth,
  sNativePropertyHooks,
  "function TestWorkerExposedInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestWorkerExposedInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestWorkerExposedInterface,
  PrototypeTraits<prototypes::id::TestWorkerExposedInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestWorkerExposedInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestWorkerExposedInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestWorkerExposedInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestWorkerExposedInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestWorkerExposedInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestWorkerExposedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestWorkerExposedInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestWorkerExposedInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestWorkerExposedInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestWorkerExposedInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestWorkerExposedInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestWorkerExposedInterface,
  constructors::id::TestWorkerExposedInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestWorkerExposedInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestWorkerExposedInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestWorkerExposedInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestWorkerExposedInterface_Binding



void
TestCallbackInterface::DoSomething(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.doSomething", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doSomething_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int32_t
TestCallbackInterface::DoSomethingElse(const nsAString& arg, TestInterface& otherArg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.doSomethingElse", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return int32_t(0);
  }
  unsigned argc = 2;

  do {
    if (!GetOrCreateDOMReflector(cx, otherArg, argv[1])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return int32_t(0);
    }
    break;
  } while (false);

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return int32_t(0);
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doSomethingElse_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestCallbackInterface.doSomethingElse", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

void
TestCallbackInterface::DoSequenceLongArg(const Sequence<int32_t>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.doSequenceLongArg", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doSequenceLongArg_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::DoSequenceStringArg(const Sequence<nsString>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.doSequenceStringArg", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!xpc::NonVoidStringToJsval(cx, arg[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doSequenceStringArg_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::DoRecordLongArg(const Record<nsString, int32_t>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.doRecordLongArg", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doRecordLongArg_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::GetSequenceOfLong(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getSequenceOfLong", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSequenceOfLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<int32_t> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfLong");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<int32_t> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestCallbackInterface.getSequenceOfLong", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfLong");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestCallbackInterface::GetSequenceOfInterfaces(nsTArray<RefPtr<TestInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getSequenceOfInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSequenceOfInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestCallbackInterface.getSequenceOfInterfaces", "TestInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getSequenceOfInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestCallbackInterface::GetNullableSequenceOfInterfaces(Nullable<nsTArray<RefPtr<TestInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getNullableSequenceOfInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getNullableSequenceOfInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestCallbackInterface.getNullableSequenceOfInterfaces", "TestInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getNullableSequenceOfInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestCallbackInterface::GetSequenceOfNullableInterfaces(nsTArray<RefPtr<TestInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getSequenceOfNullableInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSequenceOfNullableInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfNullableInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestCallbackInterface.getSequenceOfNullableInterfaces", "TestInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getSequenceOfNullableInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfNullableInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestCallbackInterface::GetNullableSequenceOfNullableInterfaces(Nullable<nsTArray<RefPtr<TestInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getNullableSequenceOfNullableInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getNullableSequenceOfNullableInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfNullableInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestCallbackInterface.getNullableSequenceOfNullableInterfaces", "TestInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getNullableSequenceOfNullableInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfNullableInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestCallbackInterface::GetSequenceOfCallbackInterfaces(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getSequenceOfCallbackInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSequenceOfCallbackInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<TestCallbackInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfCallbackInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getSequenceOfCallbackInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfCallbackInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestCallbackInterface::GetNullableSequenceOfCallbackInterfaces(Nullable<nsTArray<RefPtr<TestCallbackInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getNullableSequenceOfCallbackInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getNullableSequenceOfCallbackInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<TestCallbackInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfCallbackInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getNullableSequenceOfCallbackInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfCallbackInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestCallbackInterface::GetSequenceOfNullableCallbackInterfaces(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getSequenceOfNullableCallbackInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSequenceOfNullableCallbackInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<TestCallbackInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfNullableCallbackInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getSequenceOfNullableCallbackInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getSequenceOfNullableCallbackInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestCallbackInterface::GetNullableSequenceOfNullableCallbackInterfaces(Nullable<nsTArray<RefPtr<TestCallbackInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getNullableSequenceOfNullableCallbackInterfaces", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getNullableSequenceOfNullableCallbackInterfaces_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<TestCallbackInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfNullableCallbackInterfaces");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestCallbackInterface.getNullableSequenceOfNullableCallbackInterfaces");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestCallbackInterface.getNullableSequenceOfNullableCallbackInterfaces");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestCallbackInterface::GetRecordOfLong(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getRecordOfLong", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getRecordOfLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Record<nsString, int32_t>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestCallbackInterface.getRecordOfLong", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in return value of TestCallbackInterface.getRecordOfLong", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestCallbackInterface.getRecordOfLong");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestCallbackInterface::GetDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.getDictionary", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Dict>& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    if (!rvalDecl.SetValue().Init(cx, rval, "Return value of TestCallbackInterface.getDictionary", false)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
}

void
TestCallbackInterface::PassArrayBuffer(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passArrayBuffer", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassNullableArrayBuffer(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passNullableArrayBuffer", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
                  JS::ExposeObjectToActiveJS(arg);
                }
                argv[0].setObjectOrNull(arg);
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassOptionalArrayBuffer(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passOptionalArrayBuffer", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::ExposeObjectToActiveJS(arg.Value());
      argv[0].setObject(*arg.Value());
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassOptionalNullableArrayBuffer(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passOptionalNullableArrayBuffer", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value()) {
                    JS::ExposeObjectToActiveJS(arg.Value());
                  }
                  argv[0].setObjectOrNull(arg.Value());
      if (!MaybeWrapNonDOMObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassOptionalNullableArrayBufferWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passOptionalNullableArrayBufferWithDefaultValue", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
                  JS::ExposeObjectToActiveJS(arg);
                }
                argv[0].setObjectOrNull(arg);
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableArrayBufferWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassArrayBufferView(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passArrayBufferView", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passArrayBufferView_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassInt8Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passInt8Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassInt16Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passInt16Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt16Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassInt32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passInt32Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassUint8Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passUint8Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassUint16Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passUint16Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint16Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassUint32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passUint32Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassUint8ClampedArray(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passUint8ClampedArray", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint8ClampedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassFloat32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passFloat32Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passFloat32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassFloat64Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passFloat64Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passFloat64Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassSequenceOfArrayBuffers(const Sequence<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passSequenceOfArrayBuffers", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeObjectToActiveJS(arg[sequenceIdx0]);
          tmp.setObject(*arg[sequenceIdx0]);
          if (!MaybeWrapNonDOMObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassSequenceOfNullableArrayBuffers(const Sequence<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passSequenceOfNullableArrayBuffers", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg[sequenceIdx0]) {
                        JS::ExposeObjectToActiveJS(arg[sequenceIdx0]);
                      }
                      tmp.setObjectOrNull(arg[sequenceIdx0]);
          if (!MaybeWrapNonDOMObjectOrNullValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassVariadicTypedArray(const nsTArray<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passVariadicTypedArray", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::ExposeObjectToActiveJS(arg[idx]);
      argv[0 + idx].setObject(*arg[idx]);
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicTypedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::PassVariadicNullableTypedArray(const nsTArray<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.passVariadicNullableTypedArray", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (arg[idx]) {
                    JS::ExposeObjectToActiveJS(arg[idx]);
                  }
                  argv[0 + idx].setObjectOrNull(arg[idx]);
      if (!MaybeWrapNonDOMObjectOrNullValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicNullableTypedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestCallbackInterface::ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.receiveUint8Array", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUint8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  RootedSpiderMonkeyInterface<Uint8Array> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestCallbackInterface.receiveUint8Array", "Uint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsArrayBufferViewShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestCallbackInterface.receiveUint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestCallbackInterface.receiveUint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestCallbackInterface.receiveUint8Array");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

already_AddRefed<Promise>
TestCallbackInterface::ReceivePromise(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.receivePromise", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receivePromise_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    // We basically want our entry global here.  Play it safe
    // and use GetEntryGlobal() to get it, with whatever
    // principal-clamping it ends up doing.
    globalObj = GetEntryGlobal()->GetGlobalJSObject();
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

bool
TestCallbackInterface::InitIds(JSContext* cx, TestCallbackInterfaceAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->receivePromise_id.init(cx, "receivePromise") ||
      !atomsCache->uint8ArrayAttr_id.init(cx, "uint8ArrayAttr") ||
      !atomsCache->receiveUint8Array_id.init(cx, "receiveUint8Array") ||
      !atomsCache->passVariadicNullableTypedArray_id.init(cx, "passVariadicNullableTypedArray") ||
      !atomsCache->passVariadicTypedArray_id.init(cx, "passVariadicTypedArray") ||
      !atomsCache->passSequenceOfNullableArrayBuffers_id.init(cx, "passSequenceOfNullableArrayBuffers") ||
      !atomsCache->passSequenceOfArrayBuffers_id.init(cx, "passSequenceOfArrayBuffers") ||
      !atomsCache->passFloat64Array_id.init(cx, "passFloat64Array") ||
      !atomsCache->passFloat32Array_id.init(cx, "passFloat32Array") ||
      !atomsCache->passUint8ClampedArray_id.init(cx, "passUint8ClampedArray") ||
      !atomsCache->passUint32Array_id.init(cx, "passUint32Array") ||
      !atomsCache->passUint16Array_id.init(cx, "passUint16Array") ||
      !atomsCache->passUint8Array_id.init(cx, "passUint8Array") ||
      !atomsCache->passInt32Array_id.init(cx, "passInt32Array") ||
      !atomsCache->passInt16Array_id.init(cx, "passInt16Array") ||
      !atomsCache->passInt8Array_id.init(cx, "passInt8Array") ||
      !atomsCache->passArrayBufferView_id.init(cx, "passArrayBufferView") ||
      !atomsCache->passOptionalNullableArrayBufferWithDefaultValue_id.init(cx, "passOptionalNullableArrayBufferWithDefaultValue") ||
      !atomsCache->passOptionalNullableArrayBuffer_id.init(cx, "passOptionalNullableArrayBuffer") ||
      !atomsCache->passOptionalArrayBuffer_id.init(cx, "passOptionalArrayBuffer") ||
      !atomsCache->passNullableArrayBuffer_id.init(cx, "passNullableArrayBuffer") ||
      !atomsCache->passArrayBuffer_id.init(cx, "passArrayBuffer") ||
      !atomsCache->getDictionary_id.init(cx, "getDictionary") ||
      !atomsCache->getRecordOfLong_id.init(cx, "getRecordOfLong") ||
      !atomsCache->getNullableSequenceOfNullableCallbackInterfaces_id.init(cx, "getNullableSequenceOfNullableCallbackInterfaces") ||
      !atomsCache->getSequenceOfNullableCallbackInterfaces_id.init(cx, "getSequenceOfNullableCallbackInterfaces") ||
      !atomsCache->getNullableSequenceOfCallbackInterfaces_id.init(cx, "getNullableSequenceOfCallbackInterfaces") ||
      !atomsCache->getSequenceOfCallbackInterfaces_id.init(cx, "getSequenceOfCallbackInterfaces") ||
      !atomsCache->getNullableSequenceOfNullableInterfaces_id.init(cx, "getNullableSequenceOfNullableInterfaces") ||
      !atomsCache->getSequenceOfNullableInterfaces_id.init(cx, "getSequenceOfNullableInterfaces") ||
      !atomsCache->getNullableSequenceOfInterfaces_id.init(cx, "getNullableSequenceOfInterfaces") ||
      !atomsCache->getSequenceOfInterfaces_id.init(cx, "getSequenceOfInterfaces") ||
      !atomsCache->getSequenceOfLong_id.init(cx, "getSequenceOfLong") ||
      !atomsCache->doRecordLongArg_id.init(cx, "doRecordLongArg") ||
      !atomsCache->doSequenceStringArg_id.init(cx, "doSequenceStringArg") ||
      !atomsCache->doSequenceLongArg_id.init(cx, "doSequenceLongArg") ||
      !atomsCache->doSomethingElse_id.init(cx, "doSomethingElse") ||
      !atomsCache->doSomething_id.init(cx, "doSomething") ||
      !atomsCache->bar_id.init(cx, "bar") ||
      !atomsCache->foo_id.init(cx, "foo")) {
    return false;
  }
  return true;
}


int32_t
TestCallbackInterface::GetFoo(ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.foo", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->foo_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestCallbackInterface.foo", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

void
TestCallbackInterface::GetBar(nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.bar", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->bar_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  binding_detail::FakeString<char16_t> rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eStringify, eStringify, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}

void
TestCallbackInterface::GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.uint8ArrayAttr", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->uint8ArrayAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<Uint8Array> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestCallbackInterface.uint8ArrayAttr", "Uint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsArrayBufferViewShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestCallbackInterface.uint8ArrayAttr");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestCallbackInterface.uint8ArrayAttr");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestCallbackInterface.uint8ArrayAttr");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestCallbackInterface::SetBar(const nsAString& arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.bar", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->bar_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestCallbackInterface::SetUint8ArrayAttr(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason, ExceptionHandling aExceptionHandling, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestCallbackInterface.uint8ArrayAttr", aExceptionHandling, aRealm);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestCallbackInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->uint8ArrayAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}


already_AddRefed<TestInterface>
TestSingleOperationCallbackInterface::DoSomething(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int16_t arg, const Sequence<double>& anotherArg, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return nullptr;
  }
  unsigned argc = 2;

  do {

    uint32_t length = anotherArg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(anotherArg[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
    argv[1].setObject(*returnArray);
    break;
  } while (false);

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  bool isCallable = JS::IsCallable(mCallback);
  JS::Rooted<JS::Value> callable(cx);
  if (isCallable) {
    callable = JS::ObjectValue(*mCallback);
  } else {
    TestSingleOperationCallbackInterfaceAtoms* atomsCache = GetAtomCache<TestSingleOperationCallbackInterfaceAtoms>(cx);
    if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
         !InitIds(cx, atomsCache)) ||
        !GetCallableProperty(cx, atomsCache->doSomething_id, &callable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  JS::Rooted<JS::Value> thisValue(cx, isCallable ? aThisVal.get()
                                                 : JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestSingleOperationCallbackInterface.doSomething", "TestInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestSingleOperationCallbackInterface.doSomething");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

bool
TestSingleOperationCallbackInterface::InitIds(JSContext* cx, TestSingleOperationCallbackInterfaceAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->doSomething_id.init(cx, "doSomething")) {
    return false;
  }
  return true;
}



namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
