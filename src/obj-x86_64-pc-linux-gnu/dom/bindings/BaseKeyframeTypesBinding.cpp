/* THIS FILE IS AUTOGENERATED FROM BaseKeyframeTypes.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "BaseKeyframeTypesBinding.h"
#include "GeckoProfiler.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/StaticPrefs_dom.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/UnionConversions.h"
#include "nsContentUtils.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace CompositeOperationValues {
extern const EnumEntry strings[4] = {
  {"replace", 7},
  {"add", 3},
  {"accumulate", 10},
  { nullptr, 0 }
};
} // namespace CompositeOperationValues

bool
ToJSValue(JSContext* aCx, CompositeOperation aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(CompositeOperationValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, CompositeOperationValues::strings[uint32_t(aArgument)].value,
                      CompositeOperationValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace CompositeOperationOrAutoValues {
extern const EnumEntry strings[5] = {
  {"replace", 7},
  {"add", 3},
  {"accumulate", 10},
  {"auto", 4},
  { nullptr, 0 }
};
} // namespace CompositeOperationOrAutoValues

bool
ToJSValue(JSContext* aCx, CompositeOperationOrAuto aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(CompositeOperationOrAutoValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, CompositeOperationOrAutoValues::strings[uint32_t(aArgument)].value,
                      CompositeOperationOrAutoValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}



BaseKeyframe::BaseKeyframe()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
BaseKeyframe::InitIds(JSContext* cx, BaseKeyframeAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->simulateComputeValuesFailure_id.init(cx, "simulateComputeValuesFailure") ||
      !atomsCache->offset_id.init(cx, "offset") ||
      !atomsCache->easing_id.init(cx, "easing") ||
      !atomsCache->composite_id.init(cx, "composite")) {
    return false;
  }
  return true;
}

bool
BaseKeyframe::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  BaseKeyframeAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<BaseKeyframeAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (StaticPrefs::dom_animations_api_compositing_enabled()) {
      if (!JS_GetPropertyById(cx, *object, atomsCache->composite_id, temp.ptr())) {
        return false;
      }
    } else {
      temp->setUndefined();
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), CompositeOperationOrAutoValues::strings, "CompositeOperationOrAuto", "'composite' member of BaseKeyframe", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mComposite = static_cast<CompositeOperationOrAuto>(index);
    }
  } else {
    mComposite = CompositeOperationOrAuto::Auto;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->easing_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mEasing)) {
      return false;
    }
  } else {
    mEasing.AssignLiteral("linear");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->offset_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mOffset.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'offset' member of BaseKeyframe", &mOffset.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(mOffset.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("'offset' member of BaseKeyframe");
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (nsContentUtils::ThreadsafeIsSystemCaller(cx)) {
      if (!JS_GetPropertyById(cx, *object, atomsCache->simulateComputeValuesFailure_id, temp.ptr())) {
        return false;
      }
    } else {
      temp->setUndefined();
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'simulateComputeValuesFailure' member of BaseKeyframe", &mSimulateComputeValuesFailure)) {
      return false;
    }
  } else {
    mSimulateComputeValuesFailure = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
BaseKeyframe::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
BaseKeyframe::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  BaseKeyframeAtoms* atomsCache = GetAtomCache<BaseKeyframeAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (StaticPrefs::dom_animations_api_compositing_enabled()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      CompositeOperationOrAuto const & currentValue = mComposite;
      if (!ToJSValue(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->composite_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mEasing;
    if (!NonVoidUTF8StringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->easing_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<double> const & currentValue = mOffset;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->offset_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.set(JS_NumberValue(double(currentValue.Value())));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->offset_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (nsContentUtils::ThreadsafeIsSystemCaller(cx)) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mSimulateComputeValuesFailure;
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->simulateComputeValuesFailure_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
BaseKeyframe::TraceDictionary(JSTracer* trc)
{
}

BaseKeyframe&
BaseKeyframe::operator=(const BaseKeyframe& aOther)
{
  DictionaryBase::operator=(aOther);
  mComposite = aOther.mComposite;
  mEasing = aOther.mEasing;
  mOffset = aOther.mOffset;
  mSimulateComputeValuesFailure = aOther.mSimulateComputeValuesFailure;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


bool
CompositeOperationOrAutoOrCompositeOperationOrAutoSequence::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eCompositeOperationOrAuto: {
      if (!ToJSValue(cx, mValue.mCompositeOperationOrAuto.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    case eCompositeOperationOrAutoSequence: {

      uint32_t length = mValue.mCompositeOperationOrAutoSequence.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!ToJSValue(cx, mValue.mCompositeOperationOrAutoSequence.Value()[sequenceIdx0], &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      rval.setObject(*returnArray);
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


CompositeOperationOrAuto&
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::RawSetAsCompositeOperationOrAuto()
{
  if (mType == eCompositeOperationOrAuto) {
    return mValue.mCompositeOperationOrAuto.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eCompositeOperationOrAuto;
  return mValue.mCompositeOperationOrAuto.SetValue();
}

CompositeOperationOrAuto&
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::SetAsCompositeOperationOrAuto()
{
  if (mType == eCompositeOperationOrAuto) {
    return mValue.mCompositeOperationOrAuto.Value();
  }
  Uninit();
  mType = eCompositeOperationOrAuto;
  return mValue.mCompositeOperationOrAuto.SetValue();
}

bool
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::TrySetToCompositeOperationOrAuto(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    CompositeOperationOrAuto& memberSlot = RawSetAsCompositeOperationOrAuto();
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, value, CompositeOperationOrAutoValues::strings, "CompositeOperationOrAuto", "CompositeOperationOrAuto branch of (CompositeOperationOrAuto or sequence<CompositeOperationOrAuto>)", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      memberSlot = static_cast<CompositeOperationOrAuto>(index);
    }
  }
  return true;
}

bool
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::TrySetToCompositeOperationOrAuto(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToCompositeOperationOrAuto(cx, value, tryNext, passedToJSImpl);
}

void
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::DestroyCompositeOperationOrAuto()
{
  MOZ_ASSERT(IsCompositeOperationOrAuto(), "Wrong type!");
  mValue.mCompositeOperationOrAuto.Destroy();
  mType = eUninitialized;
}




Sequence<CompositeOperationOrAuto>&
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::RawSetAsCompositeOperationOrAutoSequence()
{
  if (mType == eCompositeOperationOrAutoSequence) {
    return mValue.mCompositeOperationOrAutoSequence.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eCompositeOperationOrAutoSequence;
  return mValue.mCompositeOperationOrAutoSequence.SetValue();
}

Sequence<CompositeOperationOrAuto>&
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::SetAsCompositeOperationOrAutoSequence()
{
  if (mType == eCompositeOperationOrAutoSequence) {
    return mValue.mCompositeOperationOrAutoSequence.Value();
  }
  Uninit();
  mType = eCompositeOperationOrAutoSequence;
  return mValue.mCompositeOperationOrAutoSequence.SetValue();
}

bool
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::TrySetToCompositeOperationOrAutoSequence(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    Sequence<CompositeOperationOrAuto>& memberSlot = RawSetAsCompositeOperationOrAutoSequence();
    JS::ForOfIterator iter(cx);
    if (!iter.init(value, JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      DestroyCompositeOperationOrAutoSequence();
      tryNext = true;
      return true;
    }
    Sequence<CompositeOperationOrAuto> &arr = memberSlot;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      CompositeOperationOrAuto* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      CompositeOperationOrAuto& slot = *slotPtr;
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, temp, CompositeOperationOrAutoValues::strings, "CompositeOperationOrAuto", "element of sequence<CompositeOperationOrAuto> branch of (CompositeOperationOrAuto or sequence<CompositeOperationOrAuto>)", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        slot = static_cast<CompositeOperationOrAuto>(index);
      }
    }
  }
  return true;
}

bool
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::TrySetToCompositeOperationOrAutoSequence(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToCompositeOperationOrAutoSequence(cx, value, tryNext, passedToJSImpl);
}

void
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::DestroyCompositeOperationOrAutoSequence()
{
  MOZ_ASSERT(IsCompositeOperationOrAutoSequence(), "Wrong type!");
  mValue.mCompositeOperationOrAutoSequence.Destroy();
  mType = eUninitialized;
}




void
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eCompositeOperationOrAuto: {
      DestroyCompositeOperationOrAuto();
      break;
    }
    case eCompositeOperationOrAutoSequence: {
      DestroyCompositeOperationOrAutoSequence();
      break;
    }
  }
}

bool
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eCompositeOperationOrAuto: {
      if (!ToJSValue(cx, mValue.mCompositeOperationOrAuto.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    case eCompositeOperationOrAutoSequence: {

      uint32_t length = mValue.mCompositeOperationOrAutoSequence.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!ToJSValue(cx, mValue.mCompositeOperationOrAutoSequence.Value()[sequenceIdx0], &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      rval.setObject(*returnArray);
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::TraceUnion(JSTracer* trc)
{
}

OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence&
OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence::operator=(const OwningCompositeOperationOrAutoOrCompositeOperationOrAutoSequence& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eCompositeOperationOrAuto: {
      SetAsCompositeOperationOrAuto() = aOther.GetAsCompositeOperationOrAuto();
      break;
    }
    case eCompositeOperationOrAutoSequence: {
      SetAsCompositeOperationOrAutoSequence() = aOther.GetAsCompositeOperationOrAutoSequence();
      break;
    }
  }
  return *this;
}


bool
DoubleOrNullOrDoubleOrNullSequence::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eNull: {
      rval.setNull();
      return true;
      break;
    }
    case eDouble: {
      rval.set(JS_NumberValue(double(mValue.mDouble.Value())));
      return true;
      break;
    }
    case eDoubleOrNullSequence: {

      uint32_t length = mValue.mDoubleOrNullSequence.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (mValue.mDoubleOrNullSequence.Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.set(JS_NumberValue(double(mValue.mDoubleOrNullSequence.Value()[sequenceIdx0].Value())));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      rval.setObject(*returnArray);
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


double&
OwningDoubleOrNullOrDoubleOrNullSequence::RawSetAsDouble()
{
  if (mType == eDouble) {
    return mValue.mDouble.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eDouble;
  return mValue.mDouble.SetValue();
}

double&
OwningDoubleOrNullOrDoubleOrNullSequence::SetAsDouble()
{
  if (mType == eDouble) {
    return mValue.mDouble.Value();
  }
  Uninit();
  mType = eDouble;
  return mValue.mDouble.SetValue();
}

bool
OwningDoubleOrNullOrDoubleOrNullSequence::TrySetToDouble(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    double& memberSlot = RawSetAsDouble();
    if (!ValueToPrimitive<double, eDefault>(cx, value, "Double branch of (double? or sequence<double?>)", &memberSlot)) {
      return false;
    } else if (!mozilla::IsFinite(memberSlot)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Double branch of (double? or sequence<double?>)");
      return false;
    }
  }
  return true;
}

bool
OwningDoubleOrNullOrDoubleOrNullSequence::TrySetToDouble(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToDouble(cx, value, tryNext, passedToJSImpl);
}

void
OwningDoubleOrNullOrDoubleOrNullSequence::DestroyDouble()
{
  MOZ_ASSERT(IsDouble(), "Wrong type!");
  mValue.mDouble.Destroy();
  mType = eUninitialized;
}




Sequence<Nullable<double>>&
OwningDoubleOrNullOrDoubleOrNullSequence::RawSetAsDoubleOrNullSequence()
{
  if (mType == eDoubleOrNullSequence) {
    return mValue.mDoubleOrNullSequence.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eDoubleOrNullSequence;
  return mValue.mDoubleOrNullSequence.SetValue();
}

Sequence<Nullable<double>>&
OwningDoubleOrNullOrDoubleOrNullSequence::SetAsDoubleOrNullSequence()
{
  if (mType == eDoubleOrNullSequence) {
    return mValue.mDoubleOrNullSequence.Value();
  }
  Uninit();
  mType = eDoubleOrNullSequence;
  return mValue.mDoubleOrNullSequence.SetValue();
}

bool
OwningDoubleOrNullOrDoubleOrNullSequence::TrySetToDoubleOrNullSequence(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    Sequence<Nullable<double>>& memberSlot = RawSetAsDoubleOrNullSequence();
    JS::ForOfIterator iter(cx);
    if (!iter.init(value, JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      DestroyDoubleOrNullSequence();
      tryNext = true;
      return true;
    }
    Sequence<Nullable<double>> &arr = memberSlot;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of sequence<double?> branch of (double? or sequence<double?>)", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of sequence<double?> branch of (double? or sequence<double?>)");
        return false;
      }
    }
  }
  return true;
}

bool
OwningDoubleOrNullOrDoubleOrNullSequence::TrySetToDoubleOrNullSequence(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToDoubleOrNullSequence(cx, value, tryNext, passedToJSImpl);
}

void
OwningDoubleOrNullOrDoubleOrNullSequence::DestroyDoubleOrNullSequence()
{
  MOZ_ASSERT(IsDoubleOrNullSequence(), "Wrong type!");
  mValue.mDoubleOrNullSequence.Destroy();
  mType = eUninitialized;
}




void
OwningDoubleOrNullOrDoubleOrNullSequence::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eNull: {
      break;
    }
    case eDouble: {
      DestroyDouble();
      break;
    }
    case eDoubleOrNullSequence: {
      DestroyDoubleOrNullSequence();
      break;
    }
  }
}

bool
OwningDoubleOrNullOrDoubleOrNullSequence::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eNull: {
      rval.setNull();
      return true;
      break;
    }
    case eDouble: {
      rval.set(JS_NumberValue(double(mValue.mDouble.Value())));
      return true;
      break;
    }
    case eDoubleOrNullSequence: {

      uint32_t length = mValue.mDoubleOrNullSequence.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (mValue.mDoubleOrNullSequence.Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.set(JS_NumberValue(double(mValue.mDoubleOrNullSequence.Value()[sequenceIdx0].Value())));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      rval.setObject(*returnArray);
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningDoubleOrNullOrDoubleOrNullSequence::TraceUnion(JSTracer* trc)
{
}

OwningDoubleOrNullOrDoubleOrNullSequence&
OwningDoubleOrNullOrDoubleOrNullSequence::operator=(const OwningDoubleOrNullOrDoubleOrNullSequence& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eNull: {
      MOZ_ASSERT(mType == eUninitialized);
      mType = eNull;
      break;
    }
    case eDouble: {
      SetAsDouble() = aOther.GetAsDouble();
      break;
    }
    case eDoubleOrNullSequence: {
      SetAsDoubleOrNullSequence() = aOther.GetAsDoubleOrNullSequence();
      break;
    }
  }
  return *this;
}



BaseComputedKeyframe::BaseComputedKeyframe()
  : BaseKeyframe(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
BaseComputedKeyframe::InitIds(JSContext* cx, BaseComputedKeyframeAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->computedOffset_id.init(cx, "computedOffset")) {
    return false;
  }
  return true;
}

bool
BaseComputedKeyframe::Init(const char* sourceDescription, bool passedToJSImpl)
{
  // We init the parent's members first
  if (!BaseKeyframe::Init(nullptr, JS::NullHandleValue)) {
    return false;
  }

  return true;
}

bool
BaseComputedKeyframe::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  BaseComputedKeyframeAtoms* atomsCache = GetAtomCache<BaseComputedKeyframeAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  // Per spec, we define the parent's members first
  if (!BaseKeyframe::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());

  if (mComputedOffset.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      double const & currentValue = mComputedOffset.InternalValue();
      temp.set(JS_NumberValue(double(currentValue)));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->computedOffset_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
BaseComputedKeyframe::TraceDictionary(JSTracer* trc)
{
  BaseKeyframe::TraceDictionary(trc);
}

BaseComputedKeyframe&
BaseComputedKeyframe::operator=(const BaseComputedKeyframe& aOther)
{
  BaseKeyframe::operator=(aOther);
  mComputedOffset.Reset();
  if (aOther.mComputedOffset.WasPassed()) {
    mComputedOffset.Construct(aOther.mComputedOffset.Value());
  }
  return *this;
}

bool
BaseComputedKeyframe::operator==(const BaseComputedKeyframe& aOther) const
{
  if (mComputedOffset != aOther.mComputedOffset) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



BasePropertyIndexedKeyframe::BasePropertyIndexedKeyframe()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
BasePropertyIndexedKeyframe::InitIds(JSContext* cx, BasePropertyIndexedKeyframeAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->offset_id.init(cx, "offset") ||
      !atomsCache->easing_id.init(cx, "easing") ||
      !atomsCache->composite_id.init(cx, "composite")) {
    return false;
  }
  return true;
}

bool
BasePropertyIndexedKeyframe::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  BasePropertyIndexedKeyframeAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<BasePropertyIndexedKeyframeAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->composite_id, temp.ptr())) {
      return false;
    }
  }
  mComposite.Uninit();
  if (!(!isNull && !temp->isUndefined())) {
    mComposite.RawSetAsCompositeOperationOrAutoSequence();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (temp.ref().isObject()) {
        done = (failed = !mComposite.TrySetToCompositeOperationOrAutoSequence(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext;
      }
      if (!done) {
        do {
          done = (failed = !mComposite.TrySetToCompositeOperationOrAuto(cx, temp.ref(), tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'composite' member of BasePropertyIndexedKeyframe", "sequence<CompositeOperationOrAuto>");
        return false;
      }
    }
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->easing_id, temp.ptr())) {
      return false;
    }
  }
  mEasing.Uninit();
  if (!(!isNull && !temp->isUndefined())) {
    mEasing.RawSetAsUTF8StringSequence();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (temp.ref().isObject()) {
        done = (failed = !mEasing.TrySetToUTF8StringSequence(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext;
      }
      if (!done) {
        do {
          done = (failed = !mEasing.TrySetToUTF8String(cx, temp.ref(), tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'easing' member of BasePropertyIndexedKeyframe", "sequence<USVString>");
        return false;
      }
    }
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->offset_id, temp.ptr())) {
      return false;
    }
  }
  mOffset.Uninit();
  if (!(!isNull && !temp->isUndefined())) {
    mOffset.RawSetAsDoubleOrNullSequence();
  } else {
    if (temp.ref().isNullOrUndefined()) {
      mOffset.SetNull();
    } else {
      {
        bool done = false, failed = false, tryNext;
        if (temp.ref().isObject()) {
          done = (failed = !mOffset.TrySetToDoubleOrNullSequence(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext;
        }
        if (!done) {
          do {
            done = (failed = !mOffset.TrySetToDouble(cx, temp.ref(), tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'offset' member of BasePropertyIndexedKeyframe", "sequence<double?>");
          return false;
        }
      }
    }
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
BasePropertyIndexedKeyframe::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
BasePropertyIndexedKeyframe::TraceDictionary(JSTracer* trc)
{
}

BasePropertyIndexedKeyframe&
BasePropertyIndexedKeyframe::operator=(const BasePropertyIndexedKeyframe& aOther)
{
  DictionaryBase::operator=(aOther);
  mComposite = aOther.mComposite;
  mEasing = aOther.mEasing;
  mOffset = aOther.mOffset;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
