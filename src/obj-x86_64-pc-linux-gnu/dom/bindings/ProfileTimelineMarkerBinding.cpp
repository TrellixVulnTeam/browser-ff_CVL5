/* THIS FILE IS AUTOGENERATED FROM ProfileTimelineMarker.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "GeckoProfiler.h"
#include "ProfileTimelineMarkerBinding.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace ProfileTimelineMessagePortOperationTypeValues {
extern const EnumEntry strings[3] = {
  {"serializeData", 13},
  {"deserializeData", 15},
  { nullptr, 0 }
};
} // namespace ProfileTimelineMessagePortOperationTypeValues

bool
ToJSValue(JSContext* aCx, ProfileTimelineMessagePortOperationType aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(ProfileTimelineMessagePortOperationTypeValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, ProfileTimelineMessagePortOperationTypeValues::strings[uint32_t(aArgument)].value,
                      ProfileTimelineMessagePortOperationTypeValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace ProfileTimelineWorkerOperationTypeValues {
extern const EnumEntry strings[5] = {
  {"serializeDataOffMainThread", 26},
  {"serializeDataOnMainThread", 25},
  {"deserializeDataOffMainThread", 28},
  {"deserializeDataOnMainThread", 27},
  { nullptr, 0 }
};
} // namespace ProfileTimelineWorkerOperationTypeValues

bool
ToJSValue(JSContext* aCx, ProfileTimelineWorkerOperationType aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(ProfileTimelineWorkerOperationTypeValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, ProfileTimelineWorkerOperationTypeValues::strings[uint32_t(aArgument)].value,
                      ProfileTimelineWorkerOperationTypeValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}



ProfileTimelineLayerRect::ProfileTimelineLayerRect()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
ProfileTimelineLayerRect::InitIds(JSContext* cx, ProfileTimelineLayerRectAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->y_id.init(cx, "y") ||
      !atomsCache->x_id.init(cx, "x") ||
      !atomsCache->width_id.init(cx, "width") ||
      !atomsCache->height_id.init(cx, "height")) {
    return false;
  }
  return true;
}

bool
ProfileTimelineLayerRect::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mHeight = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWidth = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mX = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mY = 0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ProfileTimelineLayerRect::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ProfileTimelineLayerRectAtoms* atomsCache = GetAtomCache<ProfileTimelineLayerRectAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mHeight;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->height_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mWidth;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->width_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mX;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->x_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mY;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->y_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
ProfileTimelineLayerRect::TraceDictionary(JSTracer* trc)
{
}

ProfileTimelineLayerRect&
ProfileTimelineLayerRect::operator=(const ProfileTimelineLayerRect& aOther)
{
  DictionaryBase::operator=(aOther);
  mHeight = aOther.mHeight;
  mWidth = aOther.mWidth;
  mX = aOther.mX;
  mY = aOther.mY;
  return *this;
}

bool
ProfileTimelineLayerRect::operator==(const ProfileTimelineLayerRect& aOther) const
{
  if (mHeight != aOther.mHeight) {
      return false;
  }
  if (mWidth != aOther.mWidth) {
      return false;
  }
  if (mX != aOther.mX) {
      return false;
  }
  if (mY != aOther.mY) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



ProfileTimelineStackFrame::ProfileTimelineStackFrame()
  : mAsyncParent(nullptr),
    mParent(nullptr)
{
  // Safe to pass a null context if we pass a null value
  Init();
}


bool
ProfileTimelineStackFrame::InitIds(JSContext* cx, ProfileTimelineStackFrameAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->source_id.init(cx, "source") ||
      !atomsCache->parent_id.init(cx, "parent") ||
      !atomsCache->line_id.init(cx, "line") ||
      !atomsCache->functionDisplayName_id.init(cx, "functionDisplayName") ||
      !atomsCache->column_id.init(cx, "column") ||
      !atomsCache->asyncParent_id.init(cx, "asyncParent") ||
      !atomsCache->asyncCause_id.init(cx, "asyncCause")) {
    return false;
  }
  return true;
}

bool
ProfileTimelineStackFrame::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAsyncParent = nullptr;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mColumn = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mParent = nullptr;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ProfileTimelineStackFrame::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ProfileTimelineStackFrameAtoms* atomsCache = GetAtomCache<ProfileTimelineStackFrameAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mAsyncCause.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mAsyncCause.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->asyncCause_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mAsyncParent;
    if (currentValue) {
                  JS::ExposeObjectToActiveJS(currentValue);
                }
                temp.setObjectOrNull(currentValue);
    if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->asyncParent_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mColumn;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->column_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mFunctionDisplayName.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mFunctionDisplayName.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->functionDisplayName_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mLine.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mLine.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->line_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mParent;
    if (currentValue) {
                  JS::ExposeObjectToActiveJS(currentValue);
                }
                temp.setObjectOrNull(currentValue);
    if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->parent_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mSource.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mSource.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->source_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
ProfileTimelineStackFrame::TraceDictionary(JSTracer* trc)
{
  if (mAsyncParent) {
    JS::UnsafeTraceRoot(trc, &mAsyncParent, "ProfileTimelineStackFrame.mAsyncParent");
  }

  if (mParent) {
    JS::UnsafeTraceRoot(trc, &mParent, "ProfileTimelineStackFrame.mParent");
  }
}

namespace binding_detail {
} // namespace binding_detail



ProfileTimelineMarker::ProfileTimelineMarker()
  : mEndStack(nullptr),
    mStack(nullptr)
{
  // Safe to pass a null context if we pass a null value
  Init();
}


bool
ProfileTimelineMarker::InitIds(JSContext* cx, ProfileTimelineMarkerAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->workerOperation_id.init(cx, "workerOperation") ||
      !atomsCache->unixTime_id.init(cx, "unixTime") ||
      !atomsCache->type_id.init(cx, "type") ||
      !atomsCache->start_id.init(cx, "start") ||
      !atomsCache->stack_id.init(cx, "stack") ||
      !atomsCache->rectangles_id.init(cx, "rectangles") ||
      !atomsCache->processType_id.init(cx, "processType") ||
      !atomsCache->name_id.init(cx, "name") ||
      !atomsCache->messagePortOperation_id.init(cx, "messagePortOperation") ||
      !atomsCache->isOffMainThread_id.init(cx, "isOffMainThread") ||
      !atomsCache->isAnimationOnly_id.init(cx, "isAnimationOnly") ||
      !atomsCache->eventPhase_id.init(cx, "eventPhase") ||
      !atomsCache->endStack_id.init(cx, "endStack") ||
      !atomsCache->end_id.init(cx, "end") ||
      !atomsCache->causeName_id.init(cx, "causeName")) {
    return false;
  }
  return true;
}

bool
ProfileTimelineMarker::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mEnd = 0.0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mEndStack = nullptr;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mName.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStack = nullptr;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStart = 0.0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ProfileTimelineMarker::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ProfileTimelineMarkerAtoms* atomsCache = GetAtomCache<ProfileTimelineMarkerAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mCauseName.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mCauseName.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->causeName_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mEnd;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->end_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mEndStack;
    if (currentValue) {
                  JS::ExposeObjectToActiveJS(currentValue);
                }
                temp.setObjectOrNull(currentValue);
    if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->endStack_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mEventPhase.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint16_t const & currentValue = mEventPhase.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->eventPhase_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mIsAnimationOnly.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mIsAnimationOnly.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->isAnimationOnly_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mIsOffMainThread.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mIsOffMainThread.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->isOffMainThread_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mMessagePortOperation.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      ProfileTimelineMessagePortOperationType const & currentValue = mMessagePortOperation.InternalValue();
      if (!ToJSValue(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->messagePortOperation_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mName;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->name_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mProcessType.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint16_t const & currentValue = mProcessType.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->processType_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mRectangles.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<ProfileTimelineLayerRect> const & currentValue = mRectangles.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->rectangles_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    JSObject* const & currentValue = mStack;
    if (currentValue) {
                  JS::ExposeObjectToActiveJS(currentValue);
                }
                temp.setObjectOrNull(currentValue);
    if (!MaybeWrapObjectOrNullValue(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->stack_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mStart;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->start_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mType.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mType.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->type_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mUnixTime.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint64_t const & currentValue = mUnixTime.InternalValue();
      temp.set(JS_NumberValue(double(currentValue)));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->unixTime_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mWorkerOperation.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      ProfileTimelineWorkerOperationType const & currentValue = mWorkerOperation.InternalValue();
      if (!ToJSValue(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->workerOperation_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

void
ProfileTimelineMarker::TraceDictionary(JSTracer* trc)
{
  if (mEndStack) {
    JS::UnsafeTraceRoot(trc, &mEndStack, "ProfileTimelineMarker.mEndStack");
  }

  if (mStack) {
    JS::UnsafeTraceRoot(trc, &mStack, "ProfileTimelineMarker.mStack");
  }
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
