/* THIS FILE IS AUTOGENERATED FROM ChromeUtils.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "ChromeUtilsBinding.h"
#include "GeckoProfiler.h"
#include "JSProcessActorBinding.h"
#include "JSWindowActorBinding.h"
#include "WindowBinding.h"
#include "WrapperFactory.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "jsfriendapi.h"
#include "mozilla/Atomics.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/devtools/HeapSnapshot.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/ChromeUtils.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/MozQueryInterface.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/UnionTypes.h"
#include "mozilla/dom/WebIDLPrefs.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsIDOMProcessChild.h"
#include "nsIDOMProcessParent.h"
#include "nsIPrincipal.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace WebIDLProcTypeValues {
extern const EnumEntry strings[21] = {
  {"web", 3},
  {"webIsolated", 11},
  {"file", 4},
  {"extension", 9},
  {"privilegedabout", 15},
  {"privilegedmozilla", 17},
  {"webLargeAllocation", 18},
  {"withCoopCoep", 12},
  {"browser", 7},
  {"plugin", 6},
  {"ipdlUnitTest", 12},
  {"gmpPlugin", 9},
  {"gpu", 3},
  {"vr", 2},
  {"rdd", 3},
  {"socket", 6},
  {"remoteSandboxBroker", 19},
  {"forkServer", 10},
  {"preallocated", 12},
  {"unknown", 7},
  { nullptr, 0 }
};
} // namespace WebIDLProcTypeValues

bool
ToJSValue(JSContext* aCx, WebIDLProcType aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(WebIDLProcTypeValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, WebIDLProcTypeValues::strings[uint32_t(aArgument)].value,
                      WebIDLProcTypeValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace Base64URLDecodePaddingValues {
extern const EnumEntry strings[4] = {
  {"require", 7},
  {"ignore", 6},
  {"reject", 6},
  { nullptr, 0 }
};
} // namespace Base64URLDecodePaddingValues

bool
ToJSValue(JSContext* aCx, Base64URLDecodePadding aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(Base64URLDecodePaddingValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, Base64URLDecodePaddingValues::strings[uint32_t(aArgument)].value,
                      Base64URLDecodePaddingValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace PopupBlockerStateValues {
extern const EnumEntry strings[6] = {
  {"openAllowed", 11},
  {"openControlled", 14},
  {"openBlocked", 11},
  {"openAbused", 10},
  {"openOverridden", 14},
  { nullptr, 0 }
};
} // namespace PopupBlockerStateValues

bool
ToJSValue(JSContext* aCx, PopupBlockerState aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(PopupBlockerStateValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, PopupBlockerStateValues::strings[uint32_t(aArgument)].value,
                      PopupBlockerStateValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}



Base64URLDecodeOptions::Base64URLDecodeOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
Base64URLDecodeOptions::InitIds(JSContext* cx, Base64URLDecodeOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->padding_id.init(cx, "padding")) {
    return false;
  }
  return true;
}

bool
Base64URLDecodeOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  Base64URLDecodeOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<Base64URLDecodeOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->padding_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), Base64URLDecodePaddingValues::strings, "Base64URLDecodePadding", "'padding' member of Base64URLDecodeOptions", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mPadding = static_cast<Base64URLDecodePadding>(index);
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'padding' member of Base64URLDecodeOptions");
  }
  return true;
}

bool
Base64URLDecodeOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
Base64URLDecodeOptions::TraceDictionary(JSTracer* trc)
{
}

Base64URLDecodeOptions&
Base64URLDecodeOptions::operator=(const Base64URLDecodeOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mPadding = aOther.mPadding;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



Base64URLEncodeOptions::Base64URLEncodeOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
Base64URLEncodeOptions::InitIds(JSContext* cx, Base64URLEncodeOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->pad_id.init(cx, "pad")) {
    return false;
  }
  return true;
}

bool
Base64URLEncodeOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  Base64URLEncodeOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<Base64URLEncodeOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->pad_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'pad' member of Base64URLEncodeOptions", &mPad)) {
      return false;
    }
    mIsAnyMemberPresent = true;
  } else if (cx) {
    // Don't error out if we have no cx.  In that
    // situation the caller is default-constructing us and we'll
    // just assume they know what they're doing.
    return cx.ThrowErrorMessage<MSG_MISSING_REQUIRED_DICTIONARY_MEMBER>("'pad' member of Base64URLEncodeOptions");
  }
  return true;
}

bool
Base64URLEncodeOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
Base64URLEncodeOptions::TraceDictionary(JSTracer* trc)
{
}

Base64URLEncodeOptions&
Base64URLEncodeOptions::operator=(const Base64URLEncodeOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mPad = aOther.mPad;
  return *this;
}

bool
Base64URLEncodeOptions::operator==(const Base64URLEncodeOptions& aOther) const
{
  if (mPad != aOther.mPad) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



CategoryDispatchDictionary::CategoryDispatchDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
CategoryDispatchDictionary::InitIds(JSContext* cx, CategoryDispatchDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->count_id.init(cx, "count") ||
      !atomsCache->category_id.init(cx, "category")) {
    return false;
  }
  return true;
}

bool
CategoryDispatchDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mCategory = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCount = 0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
CategoryDispatchDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  CategoryDispatchDictionaryAtoms* atomsCache = GetAtomCache<CategoryDispatchDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint16_t const & currentValue = mCategory;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->category_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint16_t const & currentValue = mCount;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->count_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
CategoryDispatchDictionary::TraceDictionary(JSTracer* trc)
{
}

CategoryDispatchDictionary&
CategoryDispatchDictionary::operator=(const CategoryDispatchDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mCategory = aOther.mCategory;
  mCount = aOther.mCount;
  return *this;
}

bool
CategoryDispatchDictionary::operator==(const CategoryDispatchDictionary& aOther) const
{
  if (mCategory != aOther.mCategory) {
      return false;
  }
  if (mCount != aOther.mCount) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



CompileScriptOptionsDictionary::CompileScriptOptionsDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
CompileScriptOptionsDictionary::InitIds(JSContext* cx, CompileScriptOptionsDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->lazilyParse_id.init(cx, "lazilyParse") ||
      !atomsCache->hasReturnValue_id.init(cx, "hasReturnValue") ||
      !atomsCache->charset_id.init(cx, "charset")) {
    return false;
  }
  return true;
}

bool
CompileScriptOptionsDictionary::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  CompileScriptOptionsDictionaryAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<CompileScriptOptionsDictionaryAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->charset_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mCharset)) {
      return false;
    }
  } else {
    mCharset.AssignLiteral(u"utf-8");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->hasReturnValue_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'hasReturnValue' member of CompileScriptOptionsDictionary", &mHasReturnValue)) {
      return false;
    }
  } else {
    mHasReturnValue = false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->lazilyParse_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'lazilyParse' member of CompileScriptOptionsDictionary", &mLazilyParse)) {
      return false;
    }
  } else {
    mLazilyParse = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
CompileScriptOptionsDictionary::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
CompileScriptOptionsDictionary::TraceDictionary(JSTracer* trc)
{
}

CompileScriptOptionsDictionary&
CompileScriptOptionsDictionary::operator=(const CompileScriptOptionsDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mCharset = aOther.mCharset;
  mHasReturnValue = aOther.mHasReturnValue;
  mLazilyParse = aOther.mLazilyParse;
  return *this;
}

bool
CompileScriptOptionsDictionary::operator==(const CompileScriptOptionsDictionary& aOther) const
{
  if (mCharset != aOther.mCharset) {
      return false;
  }
  if (mHasReturnValue != aOther.mHasReturnValue) {
      return false;
  }
  if (mLazilyParse != aOther.mLazilyParse) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



HeapSnapshotBoundaries::HeapSnapshotBoundaries()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}


bool
HeapSnapshotBoundaries::InitIds(JSContext* cx, HeapSnapshotBoundariesAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->runtime_id.init(cx, "runtime") ||
      !atomsCache->globals_id.init(cx, "globals") ||
      !atomsCache->debugger_id.init(cx, "debugger")) {
    return false;
  }
  return true;
}

bool
HeapSnapshotBoundaries::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  HeapSnapshotBoundariesAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<HeapSnapshotBoundariesAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->debugger_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mDebugger.Construct();
    if (temp.ref().isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((passedToJSImpl) && !CallerSubsumes(temp.ref())) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("'debugger' member of HeapSnapshotBoundaries");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      (mDebugger.Value()) = &temp.ref().toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'debugger' member of HeapSnapshotBoundaries");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->globals_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mGlobals.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'globals' member of HeapSnapshotBoundaries");
        return false;
      }
      Sequence<JSObject*> &arr = (mGlobals.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JSObject*& slot = *slotPtr;
        if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((passedToJSImpl) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of 'globals' member of HeapSnapshotBoundaries");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = &temp.toObject();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of 'globals' member of HeapSnapshotBoundaries");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("'globals' member of HeapSnapshotBoundaries");
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->runtime_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mRuntime.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'runtime' member of HeapSnapshotBoundaries", &(mRuntime.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
HeapSnapshotBoundaries::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
HeapSnapshotBoundaries::TraceDictionary(JSTracer* trc)
{
  if (mDebugger.WasPassed()) {
    JS::UnsafeTraceRoot(trc, &mDebugger.Value(), "HeapSnapshotBoundaries.mDebugger");
  }

  if (mGlobals.WasPassed()) {
    DoTraceSequence(trc, mGlobals.Value());
  }
}

namespace binding_detail {
} // namespace binding_detail



IOActivityDataDictionary::IOActivityDataDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
IOActivityDataDictionary::InitIds(JSContext* cx, IOActivityDataDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->tx_id.init(cx, "tx") ||
      !atomsCache->rx_id.init(cx, "rx") ||
      !atomsCache->location_id.init(cx, "location")) {
    return false;
  }
  return true;
}

bool
IOActivityDataDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mLocation.AssignLiteral("");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mRx = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mTx = 0ULL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
IOActivityDataDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  IOActivityDataDictionaryAtoms* atomsCache = GetAtomCache<IOActivityDataDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mLocation;
    if (!NonVoidByteStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->location_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mRx;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->rx_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mTx;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->tx_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
IOActivityDataDictionary::TraceDictionary(JSTracer* trc)
{
}

IOActivityDataDictionary&
IOActivityDataDictionary::operator=(const IOActivityDataDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mLocation = aOther.mLocation;
  mRx = aOther.mRx;
  mTx = aOther.mTx;
  return *this;
}

bool
IOActivityDataDictionary::operator==(const IOActivityDataDictionary& aOther) const
{
  if (mLocation != aOther.mLocation) {
      return false;
  }
  if (mRx != aOther.mRx) {
      return false;
  }
  if (mTx != aOther.mTx) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



MediaMemoryInfoDictionary::MediaMemoryInfoDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaMemoryInfoDictionary::InitIds(JSContext* cx, MediaMemoryInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoSize_id.init(cx, "videoSize") ||
      !atomsCache->resourcesSize_id.init(cx, "resourcesSize") ||
      !atomsCache->audioSize_id.init(cx, "audioSize")) {
    return false;
  }
  return true;
}

bool
MediaMemoryInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioSize = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mResourcesSize = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoSize = 0ULL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaMemoryInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaMemoryInfoDictionaryAtoms* atomsCache = GetAtomCache<MediaMemoryInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mAudioSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mResourcesSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->resourcesSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mVideoSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaMemoryInfoDictionary::TraceDictionary(JSTracer* trc)
{
}

MediaMemoryInfoDictionary&
MediaMemoryInfoDictionary::operator=(const MediaMemoryInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioSize = aOther.mAudioSize;
  mResourcesSize = aOther.mResourcesSize;
  mVideoSize = aOther.mVideoSize;
  return *this;
}

bool
MediaMemoryInfoDictionary::operator==(const MediaMemoryInfoDictionary& aOther) const
{
  if (mAudioSize != aOther.mAudioSize) {
      return false;
  }
  if (mResourcesSize != aOther.mResourcesSize) {
      return false;
  }
  if (mVideoSize != aOther.mVideoSize) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



OriginAttributesDictionary::OriginAttributesDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
OriginAttributesDictionary::InitIds(JSContext* cx, OriginAttributesDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->userContextId_id.init(cx, "userContextId") ||
      !atomsCache->privateBrowsingId_id.init(cx, "privateBrowsingId") ||
      !atomsCache->partitionKey_id.init(cx, "partitionKey") ||
      !atomsCache->inIsolatedMozBrowser_id.init(cx, "inIsolatedMozBrowser") ||
      !atomsCache->geckoViewSessionContextId_id.init(cx, "geckoViewSessionContextId") ||
      !atomsCache->firstPartyDomain_id.init(cx, "firstPartyDomain")) {
    return false;
  }
  return true;
}

bool
OriginAttributesDictionary::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  OriginAttributesDictionaryAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<OriginAttributesDictionaryAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->firstPartyDomain_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mFirstPartyDomain)) {
      return false;
    }
  } else {
    mFirstPartyDomain.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->geckoViewSessionContextId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mGeckoViewSessionContextId)) {
      return false;
    }
  } else {
    mGeckoViewSessionContextId.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->inIsolatedMozBrowser_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'inIsolatedMozBrowser' member of OriginAttributesDictionary", &mInIsolatedMozBrowser)) {
      return false;
    }
  } else {
    mInIsolatedMozBrowser = false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->partitionKey_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mPartitionKey)) {
      return false;
    }
  } else {
    mPartitionKey.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->privateBrowsingId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, temp.ref(), "'privateBrowsingId' member of OriginAttributesDictionary", &mPrivateBrowsingId)) {
      return false;
    }
  } else {
    mPrivateBrowsingId = 0U;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->userContextId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, temp.ref(), "'userContextId' member of OriginAttributesDictionary", &mUserContextId)) {
      return false;
    }
  } else {
    mUserContextId = 0U;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
OriginAttributesDictionary::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
OriginAttributesDictionary::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
OriginAttributesDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  OriginAttributesDictionaryAtoms* atomsCache = GetAtomCache<OriginAttributesDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mFirstPartyDomain;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->firstPartyDomain_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mGeckoViewSessionContextId;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->geckoViewSessionContextId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mInIsolatedMozBrowser;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->inIsolatedMozBrowser_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mPartitionKey;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->partitionKey_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint32_t const & currentValue = mPrivateBrowsingId;
    temp.setNumber(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->privateBrowsingId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint32_t const & currentValue = mUserContextId;
    temp.setNumber(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->userContextId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
OriginAttributesDictionary::TraceDictionary(JSTracer* trc)
{
}

OriginAttributesDictionary&
OriginAttributesDictionary::operator=(const OriginAttributesDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mFirstPartyDomain = aOther.mFirstPartyDomain;
  mGeckoViewSessionContextId = aOther.mGeckoViewSessionContextId;
  mInIsolatedMozBrowser = aOther.mInIsolatedMozBrowser;
  mPartitionKey = aOther.mPartitionKey;
  mPrivateBrowsingId = aOther.mPrivateBrowsingId;
  mUserContextId = aOther.mUserContextId;
  return *this;
}

bool
OriginAttributesDictionary::operator==(const OriginAttributesDictionary& aOther) const
{
  if (mFirstPartyDomain != aOther.mFirstPartyDomain) {
      return false;
  }
  if (mGeckoViewSessionContextId != aOther.mGeckoViewSessionContextId) {
      return false;
  }
  if (mInIsolatedMozBrowser != aOther.mInIsolatedMozBrowser) {
      return false;
  }
  if (mPartitionKey != aOther.mPartitionKey) {
      return false;
  }
  if (mPrivateBrowsingId != aOther.mPrivateBrowsingId) {
      return false;
  }
  if (mUserContextId != aOther.mUserContextId) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



OriginAttributesPatternDictionary::OriginAttributesPatternDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
OriginAttributesPatternDictionary::InitIds(JSContext* cx, OriginAttributesPatternDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->userContextId_id.init(cx, "userContextId") ||
      !atomsCache->privateBrowsingId_id.init(cx, "privateBrowsingId") ||
      !atomsCache->partitionKey_id.init(cx, "partitionKey") ||
      !atomsCache->inIsolatedMozBrowser_id.init(cx, "inIsolatedMozBrowser") ||
      !atomsCache->geckoViewSessionContextId_id.init(cx, "geckoViewSessionContextId") ||
      !atomsCache->firstPartyDomain_id.init(cx, "firstPartyDomain")) {
    return false;
  }
  return true;
}

bool
OriginAttributesPatternDictionary::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  OriginAttributesPatternDictionaryAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<OriginAttributesPatternDictionaryAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->firstPartyDomain_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mFirstPartyDomain.Construct();
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, (mFirstPartyDomain.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->geckoViewSessionContextId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mGeckoViewSessionContextId.Construct();
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, (mGeckoViewSessionContextId.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->inIsolatedMozBrowser_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mInIsolatedMozBrowser.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'inIsolatedMozBrowser' member of OriginAttributesPatternDictionary", &(mInIsolatedMozBrowser.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->partitionKey_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPartitionKey.Construct();
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, (mPartitionKey.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->privateBrowsingId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPrivateBrowsingId.Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, temp.ref(), "'privateBrowsingId' member of OriginAttributesPatternDictionary", &(mPrivateBrowsingId.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->userContextId_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mUserContextId.Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, temp.ref(), "'userContextId' member of OriginAttributesPatternDictionary", &(mUserContextId.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
OriginAttributesPatternDictionary::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

bool
OriginAttributesPatternDictionary::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
OriginAttributesPatternDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  OriginAttributesPatternDictionaryAtoms* atomsCache = GetAtomCache<OriginAttributesPatternDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mFirstPartyDomain.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mFirstPartyDomain.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->firstPartyDomain_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mGeckoViewSessionContextId.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mGeckoViewSessionContextId.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->geckoViewSessionContextId_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mInIsolatedMozBrowser.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mInIsolatedMozBrowser.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->inIsolatedMozBrowser_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mPartitionKey.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mPartitionKey.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->partitionKey_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mPrivateBrowsingId.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint32_t const & currentValue = mPrivateBrowsingId.InternalValue();
      temp.setNumber(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->privateBrowsingId_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mUserContextId.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint32_t const & currentValue = mUserContextId.InternalValue();
      temp.setNumber(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->userContextId_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  return true;
}

bool
OriginAttributesPatternDictionary::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSObject* scope = UnprivilegedJunkScopeOrWorkerGlobal(fallible);
  if (!scope) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  JSAutoRealm ar(cx, scope);
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
OriginAttributesPatternDictionary::TraceDictionary(JSTracer* trc)
{
}

OriginAttributesPatternDictionary&
OriginAttributesPatternDictionary::operator=(const OriginAttributesPatternDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mFirstPartyDomain.Reset();
  if (aOther.mFirstPartyDomain.WasPassed()) {
    mFirstPartyDomain.Construct(aOther.mFirstPartyDomain.Value());
  }
  mGeckoViewSessionContextId.Reset();
  if (aOther.mGeckoViewSessionContextId.WasPassed()) {
    mGeckoViewSessionContextId.Construct(aOther.mGeckoViewSessionContextId.Value());
  }
  mInIsolatedMozBrowser.Reset();
  if (aOther.mInIsolatedMozBrowser.WasPassed()) {
    mInIsolatedMozBrowser.Construct(aOther.mInIsolatedMozBrowser.Value());
  }
  mPartitionKey.Reset();
  if (aOther.mPartitionKey.WasPassed()) {
    mPartitionKey.Construct(aOther.mPartitionKey.Value());
  }
  mPrivateBrowsingId.Reset();
  if (aOther.mPrivateBrowsingId.WasPassed()) {
    mPrivateBrowsingId.Construct(aOther.mPrivateBrowsingId.Value());
  }
  mUserContextId.Reset();
  if (aOther.mUserContextId.WasPassed()) {
    mUserContextId.Construct(aOther.mUserContextId.Value());
  }
  return *this;
}

bool
OriginAttributesPatternDictionary::operator==(const OriginAttributesPatternDictionary& aOther) const
{
  if (mFirstPartyDomain != aOther.mFirstPartyDomain) {
      return false;
  }
  if (mGeckoViewSessionContextId != aOther.mGeckoViewSessionContextId) {
      return false;
  }
  if (mInIsolatedMozBrowser != aOther.mInIsolatedMozBrowser) {
      return false;
  }
  if (mPartitionKey != aOther.mPartitionKey) {
      return false;
  }
  if (mPrivateBrowsingId != aOther.mPrivateBrowsingId) {
      return false;
  }
  if (mUserContextId != aOther.mUserContextId) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



ProfilerMarkerOptions::ProfilerMarkerOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
ProfilerMarkerOptions::InitIds(JSContext* cx, ProfilerMarkerOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->startTime_id.init(cx, "startTime") ||
      !atomsCache->category_id.init(cx, "category") ||
      !atomsCache->captureStack_id.init(cx, "captureStack")) {
    return false;
  }
  return true;
}

bool
ProfilerMarkerOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  ProfilerMarkerOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ProfilerMarkerOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->captureStack_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'captureStack' member of ProfilerMarkerOptions", &mCaptureStack)) {
      return false;
    }
  } else {
    mCaptureStack = false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->category_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToByteString(cx, temp.ref(), false, "'category' member of ProfilerMarkerOptions", mCategory)) {
      return false;
    }
  } else {
    mCategory.AssignLiteral("JavaScript");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->startTime_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<double, eDefault>(cx, temp.ref(), "'startTime' member of ProfilerMarkerOptions", &mStartTime)) {
      return false;
    } else if (!mozilla::IsFinite(mStartTime)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("'startTime' member of ProfilerMarkerOptions");
      return false;
    }
  } else {
    mStartTime = 0.0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ProfilerMarkerOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
ProfilerMarkerOptions::TraceDictionary(JSTracer* trc)
{
}

ProfilerMarkerOptions&
ProfilerMarkerOptions::operator=(const ProfilerMarkerOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mCaptureStack = aOther.mCaptureStack;
  mCategory = aOther.mCategory;
  mStartTime = aOther.mStartTime;
  return *this;
}

bool
ProfilerMarkerOptions::operator==(const ProfilerMarkerOptions& aOther) const
{
  if (mCaptureStack != aOther.mCaptureStack) {
      return false;
  }
  if (mCategory != aOther.mCategory) {
      return false;
  }
  if (mStartTime != aOther.mStartTime) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



ThreadInfoDictionary::ThreadInfoDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
ThreadInfoDictionary::InitIds(JSContext* cx, ThreadInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->tid_id.init(cx, "tid") ||
      !atomsCache->name_id.init(cx, "name") ||
      !atomsCache->cpuUser_id.init(cx, "cpuUser") ||
      !atomsCache->cpuKernel_id.init(cx, "cpuKernel")) {
    return false;
  }
  return true;
}

bool
ThreadInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mCpuKernel = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCpuUser = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mName.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mTid = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ThreadInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ThreadInfoDictionaryAtoms* atomsCache = GetAtomCache<ThreadInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuKernel;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuKernel_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuUser;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuUser_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mName;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->name_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mTid;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->tid_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
ThreadInfoDictionary::TraceDictionary(JSTracer* trc)
{
}

ThreadInfoDictionary&
ThreadInfoDictionary::operator=(const ThreadInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mCpuKernel = aOther.mCpuKernel;
  mCpuUser = aOther.mCpuUser;
  mName = aOther.mName;
  mTid = aOther.mTid;
  return *this;
}

bool
ThreadInfoDictionary::operator==(const ThreadInfoDictionary& aOther) const
{
  if (mCpuKernel != aOther.mCpuKernel) {
      return false;
  }
  if (mCpuUser != aOther.mCpuUser) {
      return false;
  }
  if (mName != aOther.mName) {
      return false;
  }
  if (mTid != aOther.mTid) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



WindowInfoDictionary::WindowInfoDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
WindowInfoDictionary::InitIds(JSContext* cx, WindowInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->outerWindowId_id.init(cx, "outerWindowId") ||
      !atomsCache->isProcessRoot_id.init(cx, "isProcessRoot") ||
      !atomsCache->isInProcess_id.init(cx, "isInProcess") ||
      !atomsCache->documentURI_id.init(cx, "documentURI") ||
      !atomsCache->documentTitle_id.init(cx, "documentTitle")) {
    return false;
  }
  return true;
}

bool
WindowInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mDocumentTitle.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDocumentURI = nullptr;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsInProcess = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsProcessRoot = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mOuterWindowId = 0ULL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
WindowInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  WindowInfoDictionaryAtoms* atomsCache = GetAtomCache<WindowInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mDocumentTitle;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->documentTitle_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    RefPtr<nsIURI> const & currentValue = mDocumentURI;
    if (!currentValue) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->documentURI_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    if (!WrapObject(cx, currentValue, &NS_GET_IID(nsIURI), &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->documentURI_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsInProcess;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isInProcess_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsProcessRoot;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isProcessRoot_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mOuterWindowId;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->outerWindowId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
WindowInfoDictionary::TraceDictionary(JSTracer* trc)
{
}



WindowInfoDictionary&
WindowInfoDictionary::operator=(const WindowInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mDocumentTitle = aOther.mDocumentTitle;
  mDocumentURI = aOther.mDocumentURI;
  mIsInProcess = aOther.mIsInProcess;
  mIsProcessRoot = aOther.mIsProcessRoot;
  mOuterWindowId = aOther.mOuterWindowId;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



ChildProcInfoDictionary::ChildProcInfoDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
ChildProcInfoDictionary::InitIds(JSContext* cx, ChildProcInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->windows_id.init(cx, "windows") ||
      !atomsCache->type_id.init(cx, "type") ||
      !atomsCache->threads_id.init(cx, "threads") ||
      !atomsCache->residentUniqueSize_id.init(cx, "residentUniqueSize") ||
      !atomsCache->residentSetSize_id.init(cx, "residentSetSize") ||
      !atomsCache->pid_id.init(cx, "pid") ||
      !atomsCache->origin_id.init(cx, "origin") ||
      !atomsCache->filename_id.init(cx, "filename") ||
      !atomsCache->cpuUser_id.init(cx, "cpuUser") ||
      !atomsCache->cpuKernel_id.init(cx, "cpuKernel") ||
      !atomsCache->childID_id.init(cx, "childID")) {
    return false;
  }
  return true;
}

bool
ChildProcInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mChildID = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCpuKernel = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCpuUser = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFilename.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mOrigin.AssignLiteral("");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPid = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mResidentSetSize = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mResidentUniqueSize = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    /* mThreads array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mType = WebIDLProcType::Web;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    /* mWindows array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ChildProcInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ChildProcInfoDictionaryAtoms* atomsCache = GetAtomCache<ChildProcInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mChildID;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->childID_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuKernel;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuKernel_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuUser;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuUser_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mFilename;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->filename_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mOrigin;
    if (!NonVoidUTF8StringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->origin_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mPid;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->pid_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mResidentSetSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->residentSetSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mResidentUniqueSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->residentUniqueSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<ThreadInfoDictionary> const & currentValue = mThreads;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->threads_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    WebIDLProcType const & currentValue = mType;
    if (!ToJSValue(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->type_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<WindowInfoDictionary> const & currentValue = mWindows;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->windows_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
ChildProcInfoDictionary::TraceDictionary(JSTracer* trc)
{
}



ChildProcInfoDictionary&
ChildProcInfoDictionary::operator=(const ChildProcInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mChildID = aOther.mChildID;
  mCpuKernel = aOther.mCpuKernel;
  mCpuUser = aOther.mCpuUser;
  mFilename = aOther.mFilename;
  mOrigin = aOther.mOrigin;
  mPid = aOther.mPid;
  mResidentSetSize = aOther.mResidentSetSize;
  mResidentUniqueSize = aOther.mResidentUniqueSize;
  mThreads = aOther.mThreads;
  mType = aOther.mType;
  mWindows = aOther.mWindows;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MemoryInfoDictionary::MemoryInfoDictionary()
  : mMedia(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MemoryInfoDictionary::InitIds(JSContext* cx, MemoryInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->media_id.init(cx, "media") ||
      !atomsCache->domStyle_id.init(cx, "domStyle") ||
      !atomsCache->domOther_id.init(cx, "domOther") ||
      !atomsCache->domDom_id.init(cx, "domDom") ||
      !atomsCache->GCHeapUsage_id.init(cx, "GCHeapUsage")) {
    return false;
  }
  return true;
}

bool
MemoryInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mGCHeapUsage = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDomDom = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDomOther = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDomStyle = 0ULL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MemoryInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MemoryInfoDictionaryAtoms* atomsCache = GetAtomCache<MemoryInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mGCHeapUsage;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->GCHeapUsage_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mDomDom;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->domDom_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mDomOther;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->domOther_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mDomStyle;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->domStyle_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaMemoryInfoDictionary const & currentValue = mMedia;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->media_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MemoryInfoDictionary::TraceDictionary(JSTracer* trc)
{
}

MemoryInfoDictionary&
MemoryInfoDictionary::operator=(const MemoryInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mGCHeapUsage = aOther.mGCHeapUsage;
  mDomDom = aOther.mDomDom;
  mDomOther = aOther.mDomOther;
  mDomStyle = aOther.mDomStyle;
  mMedia = aOther.mMedia;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


ProfilerMarkerOptions&
OwningProfilerMarkerOptionsOrDouble::RawSetAsProfilerMarkerOptions()
{
  if (mType == eProfilerMarkerOptions) {
    return mValue.mProfilerMarkerOptions.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eProfilerMarkerOptions;
  return mValue.mProfilerMarkerOptions.SetValue();
}

ProfilerMarkerOptions&
OwningProfilerMarkerOptionsOrDouble::SetAsProfilerMarkerOptions()
{
  if (mType == eProfilerMarkerOptions) {
    return mValue.mProfilerMarkerOptions.Value();
  }
  Uninit();
  mType = eProfilerMarkerOptions;
  return mValue.mProfilerMarkerOptions.SetValue();
}

bool
OwningProfilerMarkerOptionsOrDouble::TrySetToProfilerMarkerOptions(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    ProfilerMarkerOptions& memberSlot = RawSetAsProfilerMarkerOptions();
    if (!IsConvertibleToDictionary(value)) {
      DestroyProfilerMarkerOptions();
      tryNext = true;
      return true;
    }
    if (!memberSlot.Init(cx, value, "ProfilerMarkerOptions branch of (ProfilerMarkerOptions or double)", passedToJSImpl)) {
      return false;
    }
  }
  return true;
}

bool
OwningProfilerMarkerOptionsOrDouble::TrySetToProfilerMarkerOptions(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToProfilerMarkerOptions(cx, value, tryNext, passedToJSImpl);
}

void
OwningProfilerMarkerOptionsOrDouble::DestroyProfilerMarkerOptions()
{
  MOZ_ASSERT(IsProfilerMarkerOptions(), "Wrong type!");
  mValue.mProfilerMarkerOptions.Destroy();
  mType = eUninitialized;
}




double&
OwningProfilerMarkerOptionsOrDouble::RawSetAsDouble()
{
  if (mType == eDouble) {
    return mValue.mDouble.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eDouble;
  return mValue.mDouble.SetValue();
}

double&
OwningProfilerMarkerOptionsOrDouble::SetAsDouble()
{
  if (mType == eDouble) {
    return mValue.mDouble.Value();
  }
  Uninit();
  mType = eDouble;
  return mValue.mDouble.SetValue();
}

bool
OwningProfilerMarkerOptionsOrDouble::TrySetToDouble(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    double& memberSlot = RawSetAsDouble();
    if (!ValueToPrimitive<double, eDefault>(cx, value, "Double branch of (ProfilerMarkerOptions or double)", &memberSlot)) {
      return false;
    } else if (!mozilla::IsFinite(memberSlot)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Double branch of (ProfilerMarkerOptions or double)");
      return false;
    }
  }
  return true;
}

bool
OwningProfilerMarkerOptionsOrDouble::TrySetToDouble(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToDouble(cx, value, tryNext, passedToJSImpl);
}

void
OwningProfilerMarkerOptionsOrDouble::DestroyDouble()
{
  MOZ_ASSERT(IsDouble(), "Wrong type!");
  mValue.mDouble.Destroy();
  mType = eUninitialized;
}




void
OwningProfilerMarkerOptionsOrDouble::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eProfilerMarkerOptions: {
      DestroyProfilerMarkerOptions();
      break;
    }
    case eDouble: {
      DestroyDouble();
      break;
    }
  }
}

void
OwningProfilerMarkerOptionsOrDouble::TraceUnion(JSTracer* trc)
{
}

OwningProfilerMarkerOptionsOrDouble&
OwningProfilerMarkerOptionsOrDouble::operator=(const OwningProfilerMarkerOptionsOrDouble& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eProfilerMarkerOptions: {
      SetAsProfilerMarkerOptions() = aOther.GetAsProfilerMarkerOptions();
      break;
    }
    case eDouble: {
      SetAsDouble() = aOther.GetAsDouble();
      break;
    }
  }
  return *this;
}



ParentProcInfoDictionary::ParentProcInfoDictionary()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
ParentProcInfoDictionary::InitIds(JSContext* cx, ParentProcInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->type_id.init(cx, "type") ||
      !atomsCache->threads_id.init(cx, "threads") ||
      !atomsCache->residentUniqueSize_id.init(cx, "residentUniqueSize") ||
      !atomsCache->residentSetSize_id.init(cx, "residentSetSize") ||
      !atomsCache->pid_id.init(cx, "pid") ||
      !atomsCache->filename_id.init(cx, "filename") ||
      !atomsCache->cpuUser_id.init(cx, "cpuUser") ||
      !atomsCache->cpuKernel_id.init(cx, "cpuKernel") ||
      !atomsCache->children_id.init(cx, "children")) {
    return false;
  }
  return true;
}

bool
ParentProcInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    /* mChildren array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCpuKernel = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCpuUser = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFilename.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPid = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mResidentSetSize = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mResidentUniqueSize = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    /* mThreads array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mType = WebIDLProcType::Browser;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ParentProcInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  ParentProcInfoDictionaryAtoms* atomsCache = GetAtomCache<ParentProcInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<ChildProcInfoDictionary> const & currentValue = mChildren;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->children_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuKernel;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuKernel_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCpuUser;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cpuUser_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mFilename;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->filename_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mPid;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->pid_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mResidentSetSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->residentSetSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mResidentUniqueSize;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->residentUniqueSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<ThreadInfoDictionary> const & currentValue = mThreads;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->threads_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    WebIDLProcType const & currentValue = mType;
    if (!ToJSValue(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->type_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
ParentProcInfoDictionary::TraceDictionary(JSTracer* trc)
{
}



ParentProcInfoDictionary&
ParentProcInfoDictionary::operator=(const ParentProcInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mChildren = aOther.mChildren;
  mCpuKernel = aOther.mCpuKernel;
  mCpuUser = aOther.mCpuUser;
  mFilename = aOther.mFilename;
  mPid = aOther.mPid;
  mResidentSetSize = aOther.mResidentSetSize;
  mResidentUniqueSize = aOther.mResidentUniqueSize;
  mThreads = aOther.mThreads;
  mType = aOther.mType;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



PerformanceInfoDictionary::PerformanceInfoDictionary()
  : mMemoryInfo(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
PerformanceInfoDictionary::InitIds(JSContext* cx, PerformanceInfoDictionaryAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->windowId_id.init(cx, "windowId") ||
      !atomsCache->pid_id.init(cx, "pid") ||
      !atomsCache->memoryInfo_id.init(cx, "memoryInfo") ||
      !atomsCache->items_id.init(cx, "items") ||
      !atomsCache->isWorker_id.init(cx, "isWorker") ||
      !atomsCache->isTopLevel_id.init(cx, "isTopLevel") ||
      !atomsCache->host_id.init(cx, "host") ||
      !atomsCache->duration_id.init(cx, "duration") ||
      !atomsCache->counterId_id.init(cx, "counterId")) {
    return false;
  }
  return true;
}

bool
PerformanceInfoDictionary::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mCounterId = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDuration = 0ULL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHost.AssignLiteral("");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsTopLevel = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsWorker = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    /* mItems array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPid = 0U;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWindowId = 0ULL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
PerformanceInfoDictionary::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  PerformanceInfoDictionaryAtoms* atomsCache = GetAtomCache<PerformanceInfoDictionaryAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mCounterId;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->counterId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mDuration;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->duration_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsCString const & currentValue = mHost;
    if (!NonVoidByteStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->host_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsTopLevel;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isTopLevel_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsWorker;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isWorker_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<CategoryDispatchDictionary> const & currentValue = mItems;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->items_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MemoryInfoDictionary const & currentValue = mMemoryInfo;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->memoryInfo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint32_t const & currentValue = mPid;
    temp.setNumber(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->pid_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint64_t const & currentValue = mWindowId;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->windowId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
PerformanceInfoDictionary::TraceDictionary(JSTracer* trc)
{
}

PerformanceInfoDictionary&
PerformanceInfoDictionary::operator=(const PerformanceInfoDictionary& aOther)
{
  DictionaryBase::operator=(aOther);
  mCounterId = aOther.mCounterId;
  mDuration = aOther.mDuration;
  mHost = aOther.mHost;
  mIsTopLevel = aOther.mIsTopLevel;
  mIsWorker = aOther.mIsWorker;
  mItems = aOther.mItems;
  mMemoryInfo = aOther.mMemoryInfo;
  mPid = aOther.mPid;
  mWindowId = aOther.mWindowId;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


namespace ChromeUtils_Binding {

MOZ_CAN_RUN_SCRIPT static bool
getObjectNodeId(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.getObjectNodeId");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "getObjectNodeId", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.getObjectNodeId", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  uint64_t result(mozilla::dom::ChromeUtils::GetObjectNodeId(global, arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
saveHeapSnapshot(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.saveHeapSnapshot");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "saveHeapSnapshot", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  RootedDictionary<binding_detail::FastHeapSnapshotBoundaries> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  FastErrorResult rv;
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::SaveHeapSnapshot(global, Constify(arg0), result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::SaveHeapSnapshot(global, Constify(arg0), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.saveHeapSnapshot"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
saveHeapSnapshotGetId(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.saveHeapSnapshotGetId");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "saveHeapSnapshotGetId", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  RootedDictionary<binding_detail::FastHeapSnapshotBoundaries> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  FastErrorResult rv;
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::SaveHeapSnapshotGetId(global, Constify(arg0), result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::SaveHeapSnapshotGetId(global, Constify(arg0), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.saveHeapSnapshotGetId"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
readHeapSnapshot(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "readHeapSnapshot", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.readHeapSnapshot", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::devtools::HeapSnapshot>(mozilla::dom::ChromeUtils::ReadHeapSnapshot(global, NonNullHelper(Constify(arg0)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.readHeapSnapshot"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
nondeterministicGetWeakMapKeys(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "nondeterministicGetWeakMapKeys", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.nondeterministicGetWeakMapKeys", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::NondeterministicGetWeakMapKeys(global, arg0, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::NondeterministicGetWeakMapKeys(global, arg0, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.nondeterministicGetWeakMapKeys"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
nondeterministicGetWeakSetKeys(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "nondeterministicGetWeakSetKeys", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.nondeterministicGetWeakSetKeys", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::NondeterministicGetWeakSetKeys(global, arg0, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::NondeterministicGetWeakSetKeys(global, arg0, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.nondeterministicGetWeakSetKeys"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
base64URLEncode(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.base64URLEncode");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "base64URLEncode", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.base64URLEncode", 2)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  ArrayBufferViewOrArrayBuffer arg0;
  ArrayBufferViewOrArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBufferView(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBufferView, ArrayBuffer");
      return false;
    }
  }
  binding_detail::FastBase64URLEncodeOptions arg1;
  if (!arg1.Init(cx, args[1], "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::Base64URLEncode(global, Constify(arg0), Constify(arg1), result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::Base64URLEncode(global, Constify(arg0), Constify(arg1), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.base64URLEncode"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidByteStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
base64URLDecode(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.base64URLDecode");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "base64URLDecode", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.base64URLDecode", 2)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
    return false;
  }
  binding_detail::FastBase64URLDecodeOptions arg1;
  if (!arg1.Init(cx, args[1], "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::Base64URLDecode(global, Constify(arg0), Constify(arg1), &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::Base64URLDecode(global, Constify(arg0), Constify(arg1), &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.base64URLDecode"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
releaseAssert(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "releaseAssert", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.releaseAssert", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg1;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
      return false;
    }
  } else {
    arg1.AssignLiteral(u"<no message>");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::ReleaseAssert(global, arg0, NonNullHelper(Constify(arg1))))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::ReleaseAssert(global, arg0, NonNullHelper(Constify(arg1)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
clearStyleSheetCache(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.clearStyleSheetCache");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "clearStyleSheetCache", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  nsIPrincipal* arg0;
  RefPtr<nsIPrincipal> arg0_holder;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<nsIPrincipal>(cx, source, getter_AddRefs(arg0_holder)))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Principal");
        return false;
      }
      MOZ_ASSERT(arg0_holder);
      arg0 = arg0_holder;
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::ClearStyleSheetCache(global, MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::ClearStyleSheetCache(global, MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
addProfilerMarker(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.addProfilerMarker");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "addProfilerMarker", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.addProfilerMarker", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  ProfilerMarkerOptionsOrDouble arg1;
  ProfilerMarkerOptionsOrDoubleArgument arg1_holder(arg1);
  if (!(args.hasDefined(1))) {
    if (!arg1.RawSetAsProfilerMarkerOptions().Init(cx, JS::NullHandleValue, "Member of (ProfilerMarkerOptions or double)")) {
      return false;
    }
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (!done) {
        done = (failed = !arg1_holder.TrySetToProfilerMarkerOptions(cx, args[1], tryNext, false)) || !tryNext;
      }
      if (!done) {
        do {
          done = (failed = !arg1_holder.TrySetToDouble(cx, args[1], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 2", "ProfilerMarkerOptions");
        return false;
      }
    }
  }
  Optional<nsACString> arg2;
  binding_detail::FakeString<char> arg2_holder;
  if (args.hasDefined(2)) {
    if (!ConvertJSValueToString(cx, args[2], eStringify, eStringify, arg2_holder)) {
      return false;
    }
    arg2 = &arg2_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::AddProfilerMarker(global, Constify(arg0), Constify(arg1), Constify(arg2)))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::AddProfilerMarker(global, Constify(arg0), Constify(arg1), Constify(arg2));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
originAttributesToSuffix(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.originAttributesToSuffix");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "originAttributesToSuffix", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FastOriginAttributesDictionary arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::OriginAttributesToSuffix(global, Constify(arg0), result))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::OriginAttributesToSuffix(global, Constify(arg0), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidByteStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
originAttributesMatchPattern(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.originAttributesMatchPattern");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "originAttributesMatchPattern", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FastOriginAttributesDictionary arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  binding_detail::FastOriginAttributesPatternDictionary arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  bool result(mozilla::dom::ChromeUtils::OriginAttributesMatchPattern(global, Constify(arg0), Constify(arg1)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
createOriginAttributesFromOrigin(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "createOriginAttributesFromOrigin", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.createOriginAttributesFromOrigin", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  OriginAttributesDictionary result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::CreateOriginAttributesFromOrigin(global, NonNullHelper(Constify(arg0)), result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::CreateOriginAttributesFromOrigin(global, NonNullHelper(Constify(arg0)), result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.createOriginAttributesFromOrigin"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
fillNonDefaultOriginAttributes(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.fillNonDefaultOriginAttributes");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "fillNonDefaultOriginAttributes", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FastOriginAttributesDictionary arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  OriginAttributesDictionary result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::FillNonDefaultOriginAttributes(global, Constify(arg0), result))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::FillNonDefaultOriginAttributes(global, Constify(arg0), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
isOriginAttributesEqual(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.isOriginAttributesEqual");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "isOriginAttributesEqual", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FastOriginAttributesDictionary arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  binding_detail::FastOriginAttributesDictionary arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  bool result(mozilla::dom::ChromeUtils::IsOriginAttributesEqual(global, Constify(arg0), Constify(arg1)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
compileScript(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.compileScript");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "compileScript", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.compileScript", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastCompileScriptOptionsDictionary arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::ChromeUtils::CompileScript(global, NonNullHelper(Constify(arg0)), Constify(arg1), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.compileScript"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo compileScript_methodinfo = {
  { (JSJitGetterOp)compileScript },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_OBJECT, false, false,
  false, false, 0
};

MOZ_CAN_RUN_SCRIPT static bool
generateQI(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.generateQI");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "generateQI", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.generateQI", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JS::Value> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::MozQueryInterface>(mozilla::dom::ChromeUtils::GenerateQI(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.generateQI"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
waiveXrays(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "waiveXrays", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.waiveXrays", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::WaiveXrays(global, arg0, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::WaiveXrays(global, arg0, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.waiveXrays"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
unwaiveXrays(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "unwaiveXrays", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.unwaiveXrays", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::UnwaiveXrays(global, arg0, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::UnwaiveXrays(global, arg0, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.unwaiveXrays"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
getClassName(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.getClassName");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "getClassName", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.getClassName", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  bool arg1;
  if (args.hasDefined(1)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[1], "Argument 2", &arg1)) {
      return false;
    }
  } else {
    arg1 = true;
  }
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::GetClassName(global, arg0, arg1, result))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::GetClassName(global, arg0, arg1, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
shallowClone(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.shallowClone");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "shallowClone", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.shallowClone", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  JS::Rooted<JSObject*> arg1(cx);
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      arg1 = &args[1].toObject();
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::ShallowClone(global, arg0, arg1, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::ShallowClone(global, arg0, arg1, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.shallowClone"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
idleDispatch(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.idleDispatch");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "idleDispatch", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.idleDispatch", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  RootedCallback<OwningNonNull<binding_detail::FastIdleRequestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastIdleRequestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  binding_detail::FastIdleRequestOptions arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::IdleDispatch(global, MOZ_KnownLive(NonNullHelper(arg0)), Constify(arg1), rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::IdleDispatch(global, MOZ_KnownLive(NonNullHelper(arg0)), Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.idleDispatch"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
import(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.import");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "import", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.import", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  Optional<JS::Handle<JSObject*>> arg1;
  if (args.hasDefined(1)) {
    arg1.Construct(cx);
    if (args[1].isObject()) {
      arg1.Value() = &args[1].toObject();
    } else if (args[1].isNullOrUndefined()) {
      arg1.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::Import(global, NonNullHelper(Constify(arg0)), Constify(arg1), &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::Import(global, NonNullHelper(Constify(arg0)), Constify(arg1), &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.import"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
defineModuleGetter(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.defineModuleGetter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "defineModuleGetter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.defineModuleGetter", 3)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  binding_detail::FakeString<char16_t> arg1;
  if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg2;
  if (!ConvertJSValueToString(cx, args[2], eStringify, eStringify, arg2)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::DefineModuleGetter(global, arg0, NonNullHelper(Constify(arg1)), NonNullHelper(Constify(arg2)), rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::DefineModuleGetter(global, arg0, NonNullHelper(Constify(arg1)), NonNullHelper(Constify(arg2)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.defineModuleGetter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
getCallerLocation(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.getCallerLocation");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "getCallerLocation", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.getCallerLocation", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  nsIPrincipal* arg0;
  RefPtr<nsIPrincipal> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<nsIPrincipal>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Principal");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::GetCallerLocation(global, MOZ_KnownLive(NonNullHelper(arg0)), &result))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::GetCallerLocation(global, MOZ_KnownLive(NonNullHelper(arg0)), &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
createError(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.createError");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "createError", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.createError", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  JS::Rooted<JSObject*> arg1(cx);
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      arg1 = &args[1].toObject();
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::CreateError(global, NonNullHelper(Constify(arg0)), arg1, &result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::CreateError(global, NonNullHelper(Constify(arg0)), arg1, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.createError"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
requestPerformanceMetrics(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "requestPerformanceMetrics", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::ChromeUtils::RequestPerformanceMetrics(global, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.requestPerformanceMetrics"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo requestPerformanceMetrics_methodinfo = {
  { (JSJitGetterOp)requestPerformanceMetrics },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_OBJECT, false, false,
  false, false, 0
};

MOZ_CAN_RUN_SCRIPT static bool
setPerfStatsCollectionMask(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "setPerfStatsCollectionMask", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.setPerfStatsCollectionMask", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::SetPerfStatsCollectionMask(global, arg0))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::SetPerfStatsCollectionMask(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
collectPerfStats(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "collectPerfStats", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::ChromeUtils::CollectPerfStats(global, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.collectPerfStats"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo collectPerfStats_methodinfo = {
  { (JSJitGetterOp)collectPerfStats },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_OBJECT, false, false,
  false, false, 0
};

MOZ_CAN_RUN_SCRIPT static bool
requestIOActivity(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "requestIOActivity", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::ChromeUtils::RequestIOActivity(global, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.requestIOActivity"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo requestIOActivity_methodinfo = {
  { (JSJitGetterOp)requestIOActivity },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_OBJECT, false, false,
  false, false, 0
};

MOZ_CAN_RUN_SCRIPT static bool
requestProcInfo(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "requestProcInfo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::ChromeUtils::RequestProcInfo(global, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.requestProcInfo"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo requestProcInfo_methodinfo = {
  { (JSJitGetterOp)requestProcInfo },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_OBJECT, false, false,
  false, false, 0
};

MOZ_CAN_RUN_SCRIPT static bool
hasReportingHeaderForOrigin(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "hasReportingHeaderForOrigin", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.hasReportingHeaderForOrigin", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  bool result(mozilla::dom::ChromeUtils::HasReportingHeaderForOrigin(global, NonNullHelper(Constify(arg0)), rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.hasReportingHeaderForOrigin"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
getPopupControlState(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "getPopupControlState", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  PopupBlockerState result(mozilla::dom::ChromeUtils::GetPopupControlState(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
lastExternalProtocolIframeAllowed(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "lastExternalProtocolIframeAllowed", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  double result(mozilla::dom::ChromeUtils::LastExternalProtocolIframeAllowed(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
resetLastExternalProtocolIframeAllowed(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "resetLastExternalProtocolIframeAllowed", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::ResetLastExternalProtocolIframeAllowed(global))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::ResetLastExternalProtocolIframeAllowed(global);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
registerWindowActor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.registerWindowActor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "registerWindowActor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.registerWindowActor", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastWindowActorOptions arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::RegisterWindowActor(global, Constify(arg0), Constify(arg1), rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::RegisterWindowActor(global, Constify(arg0), Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.registerWindowActor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
unregisterWindowActor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "unregisterWindowActor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.unregisterWindowActor", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::UnregisterWindowActor(global, Constify(arg0)))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::UnregisterWindowActor(global, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
registerProcessActor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "ChromeUtils.registerProcessActor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "registerProcessActor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.registerProcessActor", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastProcessActorOptions arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::RegisterProcessActor(global, Constify(arg0), Constify(arg1), rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::RegisterProcessActor(global, Constify(arg0), Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.registerProcessActor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
unregisterProcessActor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "unregisterProcessActor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.unregisterProcessActor", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::UnregisterProcessActor(global, Constify(arg0)))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::UnregisterProcessActor(global, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
isClassifierBlockingErrorCode(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "isClassifierBlockingErrorCode", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "ChromeUtils.isClassifierBlockingErrorCode", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  bool result(mozilla::dom::ChromeUtils::IsClassifierBlockingErrorCode(global, arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
privateNoteIntentionalCrash(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "privateNoteIntentionalCrash", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::PrivateNoteIntentionalCrash(global, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::PrivateNoteIntentionalCrash(global, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.privateNoteIntentionalCrash"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
get_domProcessChild(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "domProcessChild", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  auto result(StrongOrRawPtr<nsIDOMProcessChild>(mozilla::dom::ChromeUtils::GetDomProcessChild(global)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, &NS_GET_IID(nsIDOMProcessChild), args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
getAllDOMProcesses(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "ChromeUtils", "getAllDOMProcesses", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  FastErrorResult rv;
  nsTArray<StrongPtrForMember<nsIDOMProcessParent>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::ChromeUtils::GetAllDOMProcesses(global, result, rv))>, "Should be returning void here");
  mozilla::dom::ChromeUtils::GetAllDOMProcesses(global, result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "ChromeUtils.getAllDOMProcesses"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapObject(cx, result[sequenceIdx0], &NS_GET_IID(nsIDOMProcessParent), &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("getObjectNodeId", getObjectNodeId, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("saveHeapSnapshot", saveHeapSnapshot, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("saveHeapSnapshotGetId", saveHeapSnapshotGetId, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("readHeapSnapshot", readHeapSnapshot, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("nondeterministicGetWeakMapKeys", nondeterministicGetWeakMapKeys, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("nondeterministicGetWeakSetKeys", nondeterministicGetWeakSetKeys, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("base64URLEncode", base64URLEncode, nullptr, 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("base64URLDecode", base64URLDecode, nullptr, 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("releaseAssert", releaseAssert, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clearStyleSheetCache", clearStyleSheetCache, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("addProfilerMarker", addProfilerMarker, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("originAttributesToSuffix", originAttributesToSuffix, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("originAttributesMatchPattern", originAttributesMatchPattern, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createOriginAttributesFromOrigin", createOriginAttributesFromOrigin, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("fillNonDefaultOriginAttributes", fillNonDefaultOriginAttributes, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isOriginAttributesEqual", isOriginAttributesEqual, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("compileScript", StaticMethodPromiseWrapper, &compileScript_methodinfo, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("generateQI", generateQI, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("waiveXrays", waiveXrays, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("unwaiveXrays", unwaiveXrays, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getClassName", getClassName, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("shallowClone", shallowClone, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("idleDispatch", idleDispatch, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("import", import, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("defineModuleGetter", defineModuleGetter, nullptr, 3, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getCallerLocation", getCallerLocation, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createError", createError, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("requestPerformanceMetrics", StaticMethodPromiseWrapper, &requestPerformanceMetrics_methodinfo, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setPerfStatsCollectionMask", setPerfStatsCollectionMask, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("collectPerfStats", StaticMethodPromiseWrapper, &collectPerfStats_methodinfo, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("requestIOActivity", StaticMethodPromiseWrapper, &requestIOActivity_methodinfo, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("requestProcInfo", StaticMethodPromiseWrapper, &requestProcInfo_methodinfo, 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sStaticMethods_disablers12 = {
  WebIDLPrefIndex::NoPref, false, GlobalNames::DedicatedWorkerGlobalScope | GlobalNames::ServiceWorkerGlobalScope | GlobalNames::SharedWorkerGlobalScope, nullptr
};

static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { &sStaticMethods_disablers12, &sStaticMethods_specs[12] },
  { nullptr, nullptr }
};

static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(21 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeStaticMethods_specs[] = {
  JS_FNSPEC("hasReportingHeaderForOrigin", hasReportingHeaderForOrigin, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getPopupControlState", getPopupControlState, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("lastExternalProtocolIframeAllowed", lastExternalProtocolIframeAllowed, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("resetLastExternalProtocolIframeAllowed", resetLastExternalProtocolIframeAllowed, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("registerWindowActor", registerWindowActor, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("unregisterWindowActor", unregisterWindowActor, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("registerProcessActor", registerProcessActor, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("unregisterProcessActor", unregisterProcessActor, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isClassifierBlockingErrorCode", isClassifierBlockingErrorCode, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("privateNoteIntentionalCrash", privateNoteIntentionalCrash, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getAllDOMProcesses", getAllDOMProcesses, nullptr, 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sChromeStaticMethods_disablers0 = {
  WebIDLPrefIndex::NoPref, false, GlobalNames::DedicatedWorkerGlobalScope | GlobalNames::ServiceWorkerGlobalScope | GlobalNames::SharedWorkerGlobalScope, nullptr
};

static const Prefable<const JSFunctionSpec> sChromeStaticMethods[] = {
  { &sChromeStaticMethods_disablers0, &sChromeStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(11 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeStaticAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("domProcessChild", JSPROP_ENUMERATE, get_domProcessChild, nullptr, nullptr, nullptr),
  JS_PS_END
};

static const PrefableDisablers sChromeStaticAttributes_disablers0 = {
  WebIDLPrefIndex::NoPref, false, GlobalNames::DedicatedWorkerGlobalScope | GlobalNames::ServiceWorkerGlobalScope | GlobalNames::SharedWorkerGlobalScope, nullptr
};

static const Prefable<const JSPropertySpec> sChromeStaticAttributes[] = {
  { &sChromeStaticAttributes_disablers0, &sChromeStaticAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[32];
static PropertyInfo sNativeProperties_propertyInfos[32];

static const NativePropertiesN<1> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  -1,
  32,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(32 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static uint16_t sChromeOnlyNativeProperties_sortedPropertyIndices[12];
static PropertyInfo sChromeOnlyNativeProperties_propertyInfos[12];

static const NativePropertiesN<2> sChromeOnlyNativeProperties = {
  true,  0 /* sChromeStaticMethods */,
  true,  1 /* sChromeStaticAttributes */,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  -1,
  12,
  sChromeOnlyNativeProperties_sortedPropertyIndices,
  {
    { sChromeStaticMethods, &sChromeOnlyNativeProperties_propertyInfos[0] },
    { sChromeStaticAttributes, &sChromeOnlyNativeProperties_propertyInfos[11] }
  }
};
static_assert(12 < 1ull << (CHAR_BIT * sizeof(sChromeOnlyNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Object",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterface,
  false,
  prototypes::id::_ID_Count,
  0,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return nsContentUtils::ThreadsafeIsSystemCaller(aCx);
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::_ID_Count,
  constructors::id::ChromeUtils,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    if (!InitIds(aCx, sChromeOnlyNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = nullptr;
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::ChromeUtils);
  dom::CreateInterfaceObjects(aCx, aGlobal, nullptr,
                              nullptr, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              sChromeOnlyNativeProperties.Upcast(),
                              "ChromeUtils", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              true);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace ChromeUtils_Binding



namespace MozQueryInterface_Binding {

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::MozQueryInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::MozQueryInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::MozQueryInterface>(self);
  }
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "MozQueryInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::MozQueryInterface,
  PrototypeTraits<prototypes::id::MozQueryInterface>::Depth,
  sNativePropertyHooks,
  "function MozQueryInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

MOZ_CAN_RUN_SCRIPT static bool
_legacycaller(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  mozilla::dom::MozQueryInterface* self;
  JS::Rooted<JS::Value> rootSelf(cx, JS::ObjectValue(*obj));
  {
    // Our JSContext should be in the right global to do unwrapping in.
    nsresult rv = UnwrapObject<prototypes::id::MozQueryInterface, mozilla::dom::MozQueryInterface>(&rootSelf, self, cx);
    if (NS_FAILED(rv)) {
      MOZ_CRASH("Unexpected object in '_legacycaller' hook");
      return false;
    }
  }
  if (!args.requireAtLeast(cx, "MozQueryInterface legacy caller", 1)) {
    return false;
  }
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->LegacyCall(cx, args.thisv(), arg0, &result, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->LegacyCall(cx, args.thisv(), arg0, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "MozQueryInterface legacy caller"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "MozQueryInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::MozQueryInterface,
  PrototypeTraits<prototypes::id::MozQueryInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return nsContentUtils::ThreadsafeIsSystemCaller(aCx);
}

static const JSClassOps sClassOps = {
  nullptr, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  _legacycaller, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  nullptr /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "MozQueryInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::MozQueryInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::MozQueryInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::MozQueryInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::MozQueryInterface>::Get(),
  nullptr,
  nullptr
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::MozQueryInterface* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  MOZ_ASSERT(static_cast<mozilla::dom::MozQueryInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::MozQueryInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::MozQueryInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));

  JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::MozQueryInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }



  creator.InitializationSucceeded();
  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::MozQueryInterface,
  constructors::id::MozQueryInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::MozQueryInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::MozQueryInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "MozQueryInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace MozQueryInterface_Binding



} // namespace dom
} // namespace mozilla
