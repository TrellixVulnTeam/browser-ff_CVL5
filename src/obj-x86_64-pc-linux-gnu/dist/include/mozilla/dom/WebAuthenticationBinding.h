/* THIS FILE IS AUTOGENERATED FROM WebAuthentication.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_WebAuthenticationBinding_h
#define mozilla_dom_WebAuthenticationBinding_h

#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ArrayUtils.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/Span.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrototypeList.h"
#include "mozilla/dom/Record.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/UnionTypes.h"

namespace mozilla {
namespace dom {

class ArrayBufferViewOrArrayBuffer;
struct AuthenticationExtensionsClientInputs;
struct AuthenticationExtensionsClientInputsAtoms;
struct AuthenticationExtensionsClientOutputsAtoms;
class AuthenticatorAssertionResponse;
struct AuthenticatorAssertionResponseAtoms;
class AuthenticatorAttestationResponse;
struct AuthenticatorAttestationResponseAtoms;
class AuthenticatorResponse;
struct AuthenticatorResponseAtoms;
struct AuthenticatorSelectionCriteria;
struct AuthenticatorSelectionCriteriaAtoms;
struct CollectedClientDataAtoms;
struct NativePropertyHooks;
class OwningArrayBufferViewOrArrayBuffer;
class ProtoAndIfaceCache;
class PublicKeyCredential;
struct PublicKeyCredentialAtoms;
struct PublicKeyCredentialCreationOptionsAtoms;
struct PublicKeyCredentialDescriptor;
struct PublicKeyCredentialDescriptorAtoms;
struct PublicKeyCredentialEntityAtoms;
struct PublicKeyCredentialParameters;
struct PublicKeyCredentialParametersAtoms;
struct PublicKeyCredentialRequestOptionsAtoms;
struct PublicKeyCredentialRpEntity;
struct PublicKeyCredentialRpEntityAtoms;
struct PublicKeyCredentialUserEntity;
struct PublicKeyCredentialUserEntityAtoms;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class AuthenticatorAttachment : uint8_t {
  Platform,
  Cross_platform,
  EndGuard_
};

namespace AuthenticatorAttachmentValues {
extern const EnumEntry strings[3];

static constexpr size_t Count = 2;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(AuthenticatorAttachment::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(AuthenticatorAttachment stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace AuthenticatorAttachmentValues

bool
ToJSValue(JSContext* aCx, AuthenticatorAttachment aArgument, JS::MutableHandle<JS::Value> aValue);


enum class AttestationConveyancePreference : uint8_t {
  None,
  Indirect,
  Direct,
  EndGuard_
};

namespace AttestationConveyancePreferenceValues {
extern const EnumEntry strings[4];

static constexpr size_t Count = 3;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(AttestationConveyancePreference::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(AttestationConveyancePreference stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace AttestationConveyancePreferenceValues

bool
ToJSValue(JSContext* aCx, AttestationConveyancePreference aArgument, JS::MutableHandle<JS::Value> aValue);


enum class UserVerificationRequirement : uint8_t {
  Required,
  Preferred,
  Discouraged,
  EndGuard_
};

namespace UserVerificationRequirementValues {
extern const EnumEntry strings[4];

static constexpr size_t Count = 3;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(UserVerificationRequirement::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(UserVerificationRequirement stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace UserVerificationRequirementValues

bool
ToJSValue(JSContext* aCx, UserVerificationRequirement aArgument, JS::MutableHandle<JS::Value> aValue);


enum class PublicKeyCredentialType : uint8_t {
  Public_key,
  EndGuard_
};

namespace PublicKeyCredentialTypeValues {
extern const EnumEntry strings[2];

static constexpr size_t Count = 1;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(PublicKeyCredentialType::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(PublicKeyCredentialType stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace PublicKeyCredentialTypeValues

bool
ToJSValue(JSContext* aCx, PublicKeyCredentialType aArgument, JS::MutableHandle<JS::Value> aValue);


enum class AuthenticatorTransport : uint8_t {
  Usb,
  Nfc,
  Ble,
  Internal,
  EndGuard_
};

namespace AuthenticatorTransportValues {
extern const EnumEntry strings[5];

static constexpr size_t Count = 4;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(AuthenticatorTransport::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(AuthenticatorTransport stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace AuthenticatorTransportValues

bool
ToJSValue(JSContext* aCx, AuthenticatorTransport aArgument, JS::MutableHandle<JS::Value> aValue);


struct AuthenticationExtensionsClientInputs : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mAppid;
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mHmacCreateSecret;

  AuthenticationExtensionsClientInputs();

  explicit inline AuthenticationExtensionsClientInputs(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline AuthenticationExtensionsClientInputs(const AuthenticationExtensionsClientInputs& aOther)
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  AuthenticationExtensionsClientInputs&
  operator=(const AuthenticationExtensionsClientInputs& aOther);

  bool
  operator==(const AuthenticationExtensionsClientInputs& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, AuthenticationExtensionsClientInputsAtoms* atomsCache);
};

namespace binding_detail {
struct FastAuthenticationExtensionsClientInputs : public AuthenticationExtensionsClientInputs
{
  inline FastAuthenticationExtensionsClientInputs()
    : AuthenticationExtensionsClientInputs(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct AuthenticationExtensionsClientOutputs : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mAppid;
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mHmacCreateSecret;

  AuthenticationExtensionsClientOutputs();

  explicit inline AuthenticationExtensionsClientOutputs(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline AuthenticationExtensionsClientOutputs(const AuthenticationExtensionsClientOutputs& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  AuthenticationExtensionsClientOutputs&
  operator=(const AuthenticationExtensionsClientOutputs& aOther);

  bool
  operator==(const AuthenticationExtensionsClientOutputs& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, AuthenticationExtensionsClientOutputsAtoms* atomsCache);
};

namespace binding_detail {
struct FastAuthenticationExtensionsClientOutputs : public AuthenticationExtensionsClientOutputs
{
  inline FastAuthenticationExtensionsClientOutputs()
    : AuthenticationExtensionsClientOutputs(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct AuthenticatorSelectionCriteria : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<AuthenticatorAttachment> mAuthenticatorAttachment;
  MOZ_INIT_OUTSIDE_CTOR bool mRequireResidentKey;
  MOZ_INIT_OUTSIDE_CTOR UserVerificationRequirement mUserVerification;

  AuthenticatorSelectionCriteria();

  explicit inline AuthenticatorSelectionCriteria(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline AuthenticatorSelectionCriteria(const AuthenticatorSelectionCriteria& aOther)
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  AuthenticatorSelectionCriteria&
  operator=(const AuthenticatorSelectionCriteria& aOther);

private:
  static bool
  InitIds(JSContext* cx, AuthenticatorSelectionCriteriaAtoms* atomsCache);
};

namespace binding_detail {
struct FastAuthenticatorSelectionCriteria : public AuthenticatorSelectionCriteria
{
  inline FastAuthenticatorSelectionCriteria()
    : AuthenticatorSelectionCriteria(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialDescriptor : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR OwningArrayBufferViewOrArrayBuffer mId;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<nsString>> mTransports;
  MOZ_INIT_OUTSIDE_CTOR PublicKeyCredentialType mType;

  PublicKeyCredentialDescriptor();

  explicit inline PublicKeyCredentialDescriptor(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  PublicKeyCredentialDescriptor(const PublicKeyCredentialDescriptor&) = delete;
  PublicKeyCredentialDescriptor& operator=(const PublicKeyCredentialDescriptor&) = delete;

  static bool
  InitIds(JSContext* cx, PublicKeyCredentialDescriptorAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastPublicKeyCredentialDescriptor : public PublicKeyCredentialDescriptor
{
  inline FastPublicKeyCredentialDescriptor()
    : PublicKeyCredentialDescriptor(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialEntity : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mIcon;
  MOZ_INIT_OUTSIDE_CTOR nsString mName;

  PublicKeyCredentialEntity();

  explicit inline PublicKeyCredentialEntity(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline PublicKeyCredentialEntity(const PublicKeyCredentialEntity& aOther)
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  PublicKeyCredentialEntity&
  operator=(const PublicKeyCredentialEntity& aOther);

  bool
  operator==(const PublicKeyCredentialEntity& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, PublicKeyCredentialEntityAtoms* atomsCache);
};

namespace binding_detail {
struct FastPublicKeyCredentialEntity : public PublicKeyCredentialEntity
{
  inline FastPublicKeyCredentialEntity()
    : PublicKeyCredentialEntity(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialParameters : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR int32_t mAlg;
  MOZ_INIT_OUTSIDE_CTOR PublicKeyCredentialType mType;

  PublicKeyCredentialParameters();

  explicit inline PublicKeyCredentialParameters(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline PublicKeyCredentialParameters(const PublicKeyCredentialParameters& aOther)
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  PublicKeyCredentialParameters&
  operator=(const PublicKeyCredentialParameters& aOther);

private:
  static bool
  InitIds(JSContext* cx, PublicKeyCredentialParametersAtoms* atomsCache);
};

namespace binding_detail {
struct FastPublicKeyCredentialParameters : public PublicKeyCredentialParameters
{
  inline FastPublicKeyCredentialParameters()
    : PublicKeyCredentialParameters(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct CollectedClientData : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Record<nsString, nsString>> mAuthenticatorExtensions;
  MOZ_INIT_OUTSIDE_CTOR nsString mChallenge;
  MOZ_INIT_OUTSIDE_CTOR AuthenticationExtensionsClientInputs mClientExtensions;
  MOZ_INIT_OUTSIDE_CTOR nsString mHashAlgorithm;
  MOZ_INIT_OUTSIDE_CTOR nsString mOrigin;
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mTokenBindingId;
  MOZ_INIT_OUTSIDE_CTOR nsString mType;

  CollectedClientData();

  explicit inline CollectedClientData(const FastDictionaryInitializer& )
    : mClientExtensions(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  CollectedClientData(const CollectedClientData&) = delete;
  CollectedClientData& operator=(const CollectedClientData&) = delete;

  static bool
  InitIds(JSContext* cx, CollectedClientDataAtoms* atomsCache);

public:
  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  bool
  ToJSON(nsAString& aJSON) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastCollectedClientData : public CollectedClientData
{
  inline FastCollectedClientData()
    : CollectedClientData(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialRequestOptions : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Sequence<PublicKeyCredentialDescriptor> mAllowCredentials;
  MOZ_INIT_OUTSIDE_CTOR OwningArrayBufferViewOrArrayBuffer mChallenge;
  MOZ_INIT_OUTSIDE_CTOR AuthenticationExtensionsClientInputs mExtensions;
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mRpId;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint32_t> mTimeout;
  MOZ_INIT_OUTSIDE_CTOR UserVerificationRequirement mUserVerification;

  PublicKeyCredentialRequestOptions();

  explicit inline PublicKeyCredentialRequestOptions(const FastDictionaryInitializer& )
    : mExtensions(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  PublicKeyCredentialRequestOptions(const PublicKeyCredentialRequestOptions&) = delete;
  PublicKeyCredentialRequestOptions& operator=(const PublicKeyCredentialRequestOptions&) = delete;

  static bool
  InitIds(JSContext* cx, PublicKeyCredentialRequestOptionsAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastPublicKeyCredentialRequestOptions : public PublicKeyCredentialRequestOptions
{
  inline FastPublicKeyCredentialRequestOptions()
    : PublicKeyCredentialRequestOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialRpEntity : public PublicKeyCredentialEntity
{
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mId;

  PublicKeyCredentialRpEntity();

  explicit inline PublicKeyCredentialRpEntity(const FastDictionaryInitializer& )
    : PublicKeyCredentialEntity(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline PublicKeyCredentialRpEntity(const PublicKeyCredentialRpEntity& aOther)
    : PublicKeyCredentialEntity(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  PublicKeyCredentialRpEntity&
  operator=(const PublicKeyCredentialRpEntity& aOther);

  bool
  operator==(const PublicKeyCredentialRpEntity& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, PublicKeyCredentialRpEntityAtoms* atomsCache);
};

namespace binding_detail {
struct FastPublicKeyCredentialRpEntity : public PublicKeyCredentialRpEntity
{
  inline FastPublicKeyCredentialRpEntity()
    : PublicKeyCredentialRpEntity(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialUserEntity : public PublicKeyCredentialEntity
{
  MOZ_INIT_OUTSIDE_CTOR nsString mDisplayName;
  MOZ_INIT_OUTSIDE_CTOR OwningArrayBufferViewOrArrayBuffer mId;

  PublicKeyCredentialUserEntity();

  explicit inline PublicKeyCredentialUserEntity(const FastDictionaryInitializer& )
    : PublicKeyCredentialEntity(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  PublicKeyCredentialUserEntity(const PublicKeyCredentialUserEntity&) = delete;
  PublicKeyCredentialUserEntity& operator=(const PublicKeyCredentialUserEntity&) = delete;

  static bool
  InitIds(JSContext* cx, PublicKeyCredentialUserEntityAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastPublicKeyCredentialUserEntity : public PublicKeyCredentialUserEntity
{
  inline FastPublicKeyCredentialUserEntity()
    : PublicKeyCredentialUserEntity(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct PublicKeyCredentialCreationOptions : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR AttestationConveyancePreference mAttestation;
  MOZ_INIT_OUTSIDE_CTOR AuthenticatorSelectionCriteria mAuthenticatorSelection;
  MOZ_INIT_OUTSIDE_CTOR OwningArrayBufferViewOrArrayBuffer mChallenge;
  MOZ_INIT_OUTSIDE_CTOR Sequence<PublicKeyCredentialDescriptor> mExcludeCredentials;
  MOZ_INIT_OUTSIDE_CTOR AuthenticationExtensionsClientInputs mExtensions;
  MOZ_INIT_OUTSIDE_CTOR Sequence<PublicKeyCredentialParameters> mPubKeyCredParams;
  MOZ_INIT_OUTSIDE_CTOR PublicKeyCredentialRpEntity mRp;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint32_t> mTimeout;
  MOZ_INIT_OUTSIDE_CTOR PublicKeyCredentialUserEntity mUser;

  PublicKeyCredentialCreationOptions();

  explicit inline PublicKeyCredentialCreationOptions(const FastDictionaryInitializer& )
    : mAuthenticatorSelection(FastDictionaryInitializer()),
      mExtensions(FastDictionaryInitializer()),
      mRp(FastDictionaryInitializer()),
      mUser(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  PublicKeyCredentialCreationOptions(const PublicKeyCredentialCreationOptions&) = delete;
  PublicKeyCredentialCreationOptions& operator=(const PublicKeyCredentialCreationOptions&) = delete;

  static bool
  InitIds(JSContext* cx, PublicKeyCredentialCreationOptionsAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastPublicKeyCredentialCreationOptions : public PublicKeyCredentialCreationOptions
{
  inline FastPublicKeyCredentialCreationOptions()
    : PublicKeyCredentialCreationOptions(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


namespace AuthenticatorAssertionResponse_Binding {

  typedef mozilla::dom::AuthenticatorAssertionResponse NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::AuthenticatorAssertionResponse* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::AuthenticatorAssertionResponse,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::AuthenticatorAssertionResponse,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace AuthenticatorAssertionResponse_Binding



namespace AuthenticatorAttestationResponse_Binding {

  typedef mozilla::dom::AuthenticatorAttestationResponse NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::AuthenticatorAttestationResponse* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::AuthenticatorAttestationResponse,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::AuthenticatorAttestationResponse,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace AuthenticatorAttestationResponse_Binding



namespace AuthenticatorResponse_Binding {

  typedef mozilla::dom::AuthenticatorResponse NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::AuthenticatorResponse,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::AuthenticatorResponse,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace AuthenticatorResponse_Binding



namespace PublicKeyCredential_Binding {

  typedef mozilla::dom::PublicKeyCredential NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::PublicKeyCredential* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::PublicKeyCredential,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::PublicKeyCredential,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace PublicKeyCredential_Binding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_WebAuthenticationBinding_h
