/* THIS FILE IS AUTOGENERATED FROM ReferrerPolicy.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_ReferrerPolicyBinding_h
#define mozilla_dom_ReferrerPolicyBinding_h

#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ArrayUtils.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/Span.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/Nullable.h"

namespace mozilla {
namespace dom {

struct NativePropertyHooks;
class ProtoAndIfaceCache;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class ReferrerPolicy : uint8_t {
  _empty,
  No_referrer,
  No_referrer_when_downgrade,
  Origin,
  Origin_when_cross_origin,
  Unsafe_url,
  Same_origin,
  Strict_origin,
  Strict_origin_when_cross_origin,
  EndGuard_
};

namespace ReferrerPolicyValues {
extern const EnumEntry strings[10];

static constexpr size_t Count = 9;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(ReferrerPolicy::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(ReferrerPolicy stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace ReferrerPolicyValues

bool
ToJSValue(JSContext* aCx, ReferrerPolicy aArgument, JS::MutableHandle<JS::Value> aValue);


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_ReferrerPolicyBinding_h
