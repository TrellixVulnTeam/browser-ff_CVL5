/* THIS FILE IS AUTOGENERATED FROM NetDashboard.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_NetDashboardBinding_h
#define mozilla_dom_NetDashboardBinding_h

#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/Nullable.h"

namespace mozilla {
namespace dom {

struct ConnStatusDictAtoms;
struct DNSCacheDictAtoms;
struct DNSLookupDictAtoms;
struct DnsAndSockInfoDict;
struct DnsAndSockInfoDictAtoms;
struct DnsCacheEntry;
struct DnsCacheEntryAtoms;
struct HTTPSRRLookupDictAtoms;
struct HTTPSRecord;
struct HTTPSRecordAtoms;
struct HttpConnDictAtoms;
struct HttpConnInfo;
struct HttpConnInfoAtoms;
struct HttpConnectionElement;
struct HttpConnectionElementAtoms;
struct NativePropertyHooks;
class ProtoAndIfaceCache;
struct RcwnPerfStats;
struct RcwnPerfStatsAtoms;
struct RcwnStatusAtoms;
struct SVCParamAlpn;
struct SVCParamAlpnAtoms;
struct SVCParamAtoms;
struct SVCParamEchConfig;
struct SVCParamEchConfigAtoms;
struct SVCParamIPv4Hint;
struct SVCParamIPv4HintAtoms;
struct SVCParamIPv6Hint;
struct SVCParamIPv6HintAtoms;
struct SVCParamNoDefaultAlpn;
struct SVCParamODoHConfig;
struct SVCParamODoHConfigAtoms;
struct SVCParamPort;
struct SVCParamPortAtoms;
struct SocketElement;
struct SocketElementAtoms;
struct SocketsDictAtoms;
struct WebSocketDictAtoms;
struct WebSocketElement;
struct WebSocketElementAtoms;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

struct ConnStatusDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR nsString mStatus;

  ConnStatusDict();

  explicit inline ConnStatusDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline ConnStatusDict(const ConnStatusDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  ConnStatusDict&
  operator=(const ConnStatusDict& aOther);

  bool
  operator==(const ConnStatusDict& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, ConnStatusDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastConnStatusDict : public ConnStatusDict
{
  inline FastConnStatusDict()
    : ConnStatusDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DNSLookupDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<nsString>> mAddress;
  MOZ_INIT_OUTSIDE_CTOR bool mAnswer;
  MOZ_INIT_OUTSIDE_CTOR nsString mError;

  DNSLookupDict();

  explicit inline DNSLookupDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline DNSLookupDict(const DNSLookupDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  DNSLookupDict&
  operator=(const DNSLookupDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, DNSLookupDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastDNSLookupDict : public DNSLookupDict
{
  inline FastDNSLookupDict()
    : DNSLookupDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DnsAndSockInfoDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR bool mSpeculative;

  DnsAndSockInfoDict();

  explicit inline DnsAndSockInfoDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline DnsAndSockInfoDict(const DnsAndSockInfoDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  DnsAndSockInfoDict&
  operator=(const DnsAndSockInfoDict& aOther);

  bool
  operator==(const DnsAndSockInfoDict& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, DnsAndSockInfoDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastDnsAndSockInfoDict : public DnsAndSockInfoDict
{
  inline FastDnsAndSockInfoDict()
    : DnsAndSockInfoDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DnsCacheEntry : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR double mExpiration;
  MOZ_INIT_OUTSIDE_CTOR nsString mFamily;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<nsString>> mHostaddr;
  MOZ_INIT_OUTSIDE_CTOR nsString mHostname;
  MOZ_INIT_OUTSIDE_CTOR nsString mOriginAttributesSuffix;
  MOZ_INIT_OUTSIDE_CTOR bool mTrr;

  DnsCacheEntry();

  explicit inline DnsCacheEntry(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline DnsCacheEntry(const DnsCacheEntry& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  DnsCacheEntry&
  operator=(const DnsCacheEntry& aOther);

private:
  static bool
  InitIds(JSContext* cx, DnsCacheEntryAtoms* atomsCache);
};

namespace binding_detail {
struct FastDnsCacheEntry : public DnsCacheEntry
{
  inline FastDnsCacheEntry()
    : DnsCacheEntry(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnInfo : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR nsString mProtocolVersion;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mRtt;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mTtl;

  HttpConnInfo();

  explicit inline HttpConnInfo(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline HttpConnInfo(const HttpConnInfo& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  HttpConnInfo&
  operator=(const HttpConnInfo& aOther);

  bool
  operator==(const HttpConnInfo& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, HttpConnInfoAtoms* atomsCache);
};

namespace binding_detail {
struct FastHttpConnInfo : public HttpConnInfo
{
  inline FastHttpConnInfo()
    : HttpConnInfo(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct RcwnPerfStats : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR uint32_t mAvgLong;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mAvgShort;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mStddevLong;

  RcwnPerfStats();

  explicit inline RcwnPerfStats(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline RcwnPerfStats(const RcwnPerfStats& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  RcwnPerfStats&
  operator=(const RcwnPerfStats& aOther);

  bool
  operator==(const RcwnPerfStats& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, RcwnPerfStatsAtoms* atomsCache);
};

namespace binding_detail {
struct FastRcwnPerfStats : public RcwnPerfStats
{
  inline FastRcwnPerfStats()
    : RcwnPerfStats(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParam : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR uint16_t mType;

  SVCParam();

  explicit inline SVCParam(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParam(const SVCParam& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParam&
  operator=(const SVCParam& aOther);

  bool
  operator==(const SVCParam& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SVCParamAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParam : public SVCParam
{
  inline FastSVCParam()
    : SVCParam(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SocketElement : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR bool mActive;
  MOZ_INIT_OUTSIDE_CTOR nsString mHost;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mPort;
  MOZ_INIT_OUTSIDE_CTOR double mReceived;
  MOZ_INIT_OUTSIDE_CTOR double mSent;
  MOZ_INIT_OUTSIDE_CTOR bool mTcp;

  SocketElement();

  explicit inline SocketElement(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SocketElement(const SocketElement& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SocketElement&
  operator=(const SocketElement& aOther);

  bool
  operator==(const SocketElement& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SocketElementAtoms* atomsCache);
};

namespace binding_detail {
struct FastSocketElement : public SocketElement
{
  inline FastSocketElement()
    : SocketElement(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct WebSocketElement : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR bool mEncrypted;
  MOZ_INIT_OUTSIDE_CTOR nsString mHostport;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mMsgreceived;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mMsgsent;
  MOZ_INIT_OUTSIDE_CTOR double mReceivedsize;
  MOZ_INIT_OUTSIDE_CTOR double mSentsize;

  WebSocketElement();

  explicit inline WebSocketElement(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline WebSocketElement(const WebSocketElement& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  WebSocketElement&
  operator=(const WebSocketElement& aOther);

  bool
  operator==(const WebSocketElement& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, WebSocketElementAtoms* atomsCache);
};

namespace binding_detail {
struct FastWebSocketElement : public WebSocketElement
{
  inline FastWebSocketElement()
    : WebSocketElement(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DNSCacheDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<DnsCacheEntry>> mEntries;

  DNSCacheDict();

  explicit inline DNSCacheDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline DNSCacheDict(const DNSCacheDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  DNSCacheDict&
  operator=(const DNSCacheDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, DNSCacheDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastDNSCacheDict : public DNSCacheDict
{
  inline FastDNSCacheDict()
    : DNSCacheDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnectionElement : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<HttpConnInfo>> mActive;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<DnsAndSockInfoDict>> mDnsAndSocks;
  MOZ_INIT_OUTSIDE_CTOR nsString mHost;
  MOZ_INIT_OUTSIDE_CTOR nsString mHttpVersion;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<HttpConnInfo>> mIdle;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mPort;
  MOZ_INIT_OUTSIDE_CTOR bool mSsl;

  HttpConnectionElement();

  explicit inline HttpConnectionElement(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline HttpConnectionElement(const HttpConnectionElement& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  HttpConnectionElement&
  operator=(const HttpConnectionElement& aOther);

private:
  static bool
  InitIds(JSContext* cx, HttpConnectionElementAtoms* atomsCache);
};

namespace binding_detail {
struct FastHttpConnectionElement : public HttpConnectionElement
{
  inline FastHttpConnectionElement()
    : HttpConnectionElement(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct RcwnStatus : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR uint32_t mCacheNotSlowCount;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mCacheSlowCount;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<RcwnPerfStats>> mPerfStats;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mRcwnCacheWonCount;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mRcwnNetWonCount;
  MOZ_INIT_OUTSIDE_CTOR uint32_t mTotalNetworkRequests;

  RcwnStatus();

  explicit inline RcwnStatus(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline RcwnStatus(const RcwnStatus& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  RcwnStatus&
  operator=(const RcwnStatus& aOther);

private:
  static bool
  InitIds(JSContext* cx, RcwnStatusAtoms* atomsCache);
};

namespace binding_detail {
struct FastRcwnStatus : public RcwnStatus
{
  inline FastRcwnStatus()
    : RcwnStatus(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamAlpn : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR nsString mAlpn;

  SVCParamAlpn();

  explicit inline SVCParamAlpn(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamAlpn(const SVCParamAlpn& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamAlpn&
  operator=(const SVCParamAlpn& aOther);

  bool
  operator==(const SVCParamAlpn& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SVCParamAlpnAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamAlpn : public SVCParamAlpn
{
  inline FastSVCParamAlpn()
    : SVCParamAlpn(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamEchConfig : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR nsString mEchConfig;

  SVCParamEchConfig();

  explicit inline SVCParamEchConfig(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamEchConfig(const SVCParamEchConfig& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamEchConfig&
  operator=(const SVCParamEchConfig& aOther);

  bool
  operator==(const SVCParamEchConfig& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SVCParamEchConfigAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamEchConfig : public SVCParamEchConfig
{
  inline FastSVCParamEchConfig()
    : SVCParamEchConfig(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamIPv4Hint : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<nsString>> mAddress;

  SVCParamIPv4Hint();

  explicit inline SVCParamIPv4Hint(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamIPv4Hint(const SVCParamIPv4Hint& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamIPv4Hint&
  operator=(const SVCParamIPv4Hint& aOther);

private:
  static bool
  InitIds(JSContext* cx, SVCParamIPv4HintAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamIPv4Hint : public SVCParamIPv4Hint
{
  inline FastSVCParamIPv4Hint()
    : SVCParamIPv4Hint(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamIPv6Hint : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<nsString>> mAddress;

  SVCParamIPv6Hint();

  explicit inline SVCParamIPv6Hint(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamIPv6Hint(const SVCParamIPv6Hint& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamIPv6Hint&
  operator=(const SVCParamIPv6Hint& aOther);

private:
  static bool
  InitIds(JSContext* cx, SVCParamIPv6HintAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamIPv6Hint : public SVCParamIPv6Hint
{
  inline FastSVCParamIPv6Hint()
    : SVCParamIPv6Hint(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamNoDefaultAlpn : public SVCParam
{
  SVCParamNoDefaultAlpn();

  explicit inline SVCParamNoDefaultAlpn(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamNoDefaultAlpn(const SVCParamNoDefaultAlpn& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamNoDefaultAlpn&
  operator=(const SVCParamNoDefaultAlpn& aOther);

  bool
  operator==(const SVCParamNoDefaultAlpn& aOther) const;
};

namespace binding_detail {
struct FastSVCParamNoDefaultAlpn : public SVCParamNoDefaultAlpn
{
  inline FastSVCParamNoDefaultAlpn()
    : SVCParamNoDefaultAlpn(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamODoHConfig : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR nsString mODoHConfig;

  SVCParamODoHConfig();

  explicit inline SVCParamODoHConfig(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamODoHConfig(const SVCParamODoHConfig& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamODoHConfig&
  operator=(const SVCParamODoHConfig& aOther);

  bool
  operator==(const SVCParamODoHConfig& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SVCParamODoHConfigAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamODoHConfig : public SVCParamODoHConfig
{
  inline FastSVCParamODoHConfig()
    : SVCParamODoHConfig(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SVCParamPort : public SVCParam
{
  MOZ_INIT_OUTSIDE_CTOR uint16_t mPort;

  SVCParamPort();

  explicit inline SVCParamPort(const FastDictionaryInitializer& )
    : SVCParam(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SVCParamPort(const SVCParamPort& aOther)
    : SVCParam(FastDictionaryInitializer())
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SVCParamPort&
  operator=(const SVCParamPort& aOther);

  bool
  operator==(const SVCParamPort& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, SVCParamPortAtoms* atomsCache);
};

namespace binding_detail {
struct FastSVCParamPort : public SVCParamPort
{
  inline FastSVCParamPort()
    : SVCParamPort(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct SocketsDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR double mReceived;
  MOZ_INIT_OUTSIDE_CTOR double mSent;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<SocketElement>> mSockets;

  SocketsDict();

  explicit inline SocketsDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline SocketsDict(const SocketsDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  SocketsDict&
  operator=(const SocketsDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, SocketsDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastSocketsDict : public SocketsDict
{
  inline FastSocketsDict()
    : SocketsDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct WebSocketDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<WebSocketElement>> mWebsockets;

  WebSocketDict();

  explicit inline WebSocketDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline WebSocketDict(const WebSocketDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  WebSocketDict&
  operator=(const WebSocketDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, WebSocketDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastWebSocketDict : public WebSocketDict
{
  inline FastWebSocketDict()
    : WebSocketDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HTTPSRecord : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamODoHConfig> mODoHConfig;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamAlpn> mAlpn;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamEchConfig> mEchConfig;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamIPv4Hint> mIpv4Hint;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamIPv6Hint> mIpv6Hint;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamNoDefaultAlpn> mNoDefaultAlpn;
  MOZ_INIT_OUTSIDE_CTOR Optional<SVCParamPort> mPort;
  MOZ_INIT_OUTSIDE_CTOR uint16_t mPriority;
  MOZ_INIT_OUTSIDE_CTOR nsString mTargetName;

  HTTPSRecord();

  explicit inline HTTPSRecord(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline HTTPSRecord(const HTTPSRecord& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  HTTPSRecord&
  operator=(const HTTPSRecord& aOther);

private:
  static bool
  InitIds(JSContext* cx, HTTPSRecordAtoms* atomsCache);
};

namespace binding_detail {
struct FastHTTPSRecord : public HTTPSRecord
{
  inline FastHTTPSRecord()
    : HTTPSRecord(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HttpConnDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<HttpConnectionElement>> mConnections;

  HttpConnDict();

  explicit inline HttpConnDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline HttpConnDict(const HttpConnDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  HttpConnDict&
  operator=(const HttpConnDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, HttpConnDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastHttpConnDict : public HttpConnDict
{
  inline FastHttpConnDict()
    : HttpConnDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct HTTPSRRLookupDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR bool mAnswer;
  MOZ_INIT_OUTSIDE_CTOR nsString mError;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<HTTPSRecord>> mRecords;

  HTTPSRRLookupDict();

  explicit inline HTTPSRRLookupDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline HTTPSRRLookupDict(const HTTPSRRLookupDict& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  HTTPSRRLookupDict&
  operator=(const HTTPSRRLookupDict& aOther);

private:
  static bool
  InitIds(JSContext* cx, HTTPSRRLookupDictAtoms* atomsCache);
};

namespace binding_detail {
struct FastHTTPSRRLookupDict : public HTTPSRRLookupDict
{
  inline FastHTTPSRRLookupDict()
    : HTTPSRRLookupDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_NetDashboardBinding_h
