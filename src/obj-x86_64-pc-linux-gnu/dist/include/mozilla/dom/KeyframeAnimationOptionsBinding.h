/* THIS FILE IS AUTOGENERATED FROM KeyframeAnimationOptions.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_KeyframeAnimationOptionsBinding_h
#define mozilla_dom_KeyframeAnimationOptionsBinding_h

#include "AnimatableBinding.h"
#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/FakeString.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/UnionMember.h"

namespace mozilla {
namespace dom {

struct NativePropertyHooks;
class ProtoAndIfaceCache;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

class UnrestrictedDoubleOrKeyframeAnimationOptions
{
  friend class UnrestrictedDoubleOrKeyframeAnimationOptionsArgument;
  enum Type
  {
    eUninitialized,
    eUnrestrictedDouble,
    eKeyframeAnimationOptions
  };

  union Value
  {
    UnionMember<double > mUnrestrictedDouble;
    UnionMember<binding_detail::FastKeyframeAnimationOptions > mKeyframeAnimationOptions;

  };

  Type mType;
  Value mValue;

  UnrestrictedDoubleOrKeyframeAnimationOptions(const UnrestrictedDoubleOrKeyframeAnimationOptions&) = delete;
  UnrestrictedDoubleOrKeyframeAnimationOptions& operator=(const UnrestrictedDoubleOrKeyframeAnimationOptions&) = delete;
public:
  explicit inline UnrestrictedDoubleOrKeyframeAnimationOptions()
    : mType(eUninitialized)
  {
  }

  inline ~UnrestrictedDoubleOrKeyframeAnimationOptions()
  {
    Uninit();
  }

  inline double&
  RawSetAsUnrestrictedDouble()
  {
    if (mType == eUnrestrictedDouble) {
      return mValue.mUnrestrictedDouble.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eUnrestrictedDouble;
    return mValue.mUnrestrictedDouble.SetValue();
  }

  inline double&
  SetAsUnrestrictedDouble()
  {
    if (mType == eUnrestrictedDouble) {
      return mValue.mUnrestrictedDouble.Value();
    }
    Uninit();
    mType = eUnrestrictedDouble;
    return mValue.mUnrestrictedDouble.SetValue();
  }

  inline bool
  IsUnrestrictedDouble() const
  {
    return mType == eUnrestrictedDouble;
  }

  inline double&
  GetAsUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline double
  GetAsUnrestrictedDouble() const
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  RawSetAsKeyframeAnimationOptions()
  {
    if (mType == eKeyframeAnimationOptions) {
      return mValue.mKeyframeAnimationOptions.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eKeyframeAnimationOptions;
    return mValue.mKeyframeAnimationOptions.SetValue();
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  SetAsKeyframeAnimationOptions()
  {
    if (mType == eKeyframeAnimationOptions) {
      return mValue.mKeyframeAnimationOptions.Value();
    }
    Uninit();
    mType = eKeyframeAnimationOptions;
    return mValue.mKeyframeAnimationOptions.SetValue();
  }

  inline bool
  IsKeyframeAnimationOptions() const
  {
    return mType == eKeyframeAnimationOptions;
  }

  inline binding_detail::FastKeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline const KeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions() const
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eUnrestrictedDouble: {
        DestroyUnrestrictedDouble();
        break;
      }
      case eKeyframeAnimationOptions: {
        DestroyKeyframeAnimationOptions();
        break;
      }
    }
  }

private:
  inline void
  DestroyUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    mValue.mUnrestrictedDouble.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    mValue.mKeyframeAnimationOptions.Destroy();
    mType = eUninitialized;
  }
};


class OwningUnrestrictedDoubleOrKeyframeAnimationOptions : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aUnion);
  enum Type
  {
    eUninitialized,
    eUnrestrictedDouble,
    eKeyframeAnimationOptions
  };

  union Value
  {
    UnionMember<double > mUnrestrictedDouble;
    UnionMember<KeyframeAnimationOptions > mKeyframeAnimationOptions;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningUnrestrictedDoubleOrKeyframeAnimationOptions()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningUnrestrictedDoubleOrKeyframeAnimationOptions(const OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningUnrestrictedDoubleOrKeyframeAnimationOptions()
  {
    Uninit();
  }

  double&
  RawSetAsUnrestrictedDouble();

  double&
  SetAsUnrestrictedDouble();

  bool
  TrySetToUnrestrictedDouble(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsUnrestrictedDouble() const
  {
    return mType == eUnrestrictedDouble;
  }

  inline double&
  GetAsUnrestrictedDouble()
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  inline double const &
  GetAsUnrestrictedDouble() const
  {
    MOZ_ASSERT(IsUnrestrictedDouble(), "Wrong type!");
    return mValue.mUnrestrictedDouble.Value();
  }

  KeyframeAnimationOptions&
  RawSetAsKeyframeAnimationOptions();

  KeyframeAnimationOptions&
  SetAsKeyframeAnimationOptions();

  bool
  TrySetToKeyframeAnimationOptions(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToKeyframeAnimationOptions(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsKeyframeAnimationOptions() const
  {
    return mType == eKeyframeAnimationOptions;
  }

  inline KeyframeAnimationOptions&
  GetAsKeyframeAnimationOptions()
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  inline KeyframeAnimationOptions const &
  GetAsKeyframeAnimationOptions() const
  {
    MOZ_ASSERT(IsKeyframeAnimationOptions(), "Wrong type!");
    return mValue.mKeyframeAnimationOptions.Value();
  }

  void
  Uninit();

  void
  TraceUnion(JSTracer* trc);

  OwningUnrestrictedDoubleOrKeyframeAnimationOptions&
  operator=(const OwningUnrestrictedDoubleOrKeyframeAnimationOptions& aOther);

private:
  void
  DestroyUnrestrictedDouble();

  void
  DestroyKeyframeAnimationOptions();
};


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_KeyframeAnimationOptionsBinding_h
