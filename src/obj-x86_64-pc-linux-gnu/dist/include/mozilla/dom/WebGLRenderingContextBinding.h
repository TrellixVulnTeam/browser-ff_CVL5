/* THIS FILE IS AUTOGENERATED FROM WebGLRenderingContext.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_WebGLRenderingContextBinding_h
#define mozilla_dom_WebGLRenderingContextBinding_h

#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "js/Value.h"
#include "mozilla/ArrayUtils.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/Span.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/FakeString.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrototypeList.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionMember.h"

namespace mozilla {

class ClientWebGLContext;
struct ClientWebGLContextAtoms;
class ClientWebGLExtensionBlendMinMax;
struct ClientWebGLExtensionBlendMinMaxAtoms;
class ClientWebGLExtensionColorBufferFloat;
struct ClientWebGLExtensionColorBufferFloatAtoms;
class ClientWebGLExtensionColorBufferHalfFloat;
struct ClientWebGLExtensionColorBufferHalfFloatAtoms;
class ClientWebGLExtensionCompressedTextureASTC;
struct ClientWebGLExtensionCompressedTextureASTCAtoms;
class ClientWebGLExtensionCompressedTextureBPTC;
struct ClientWebGLExtensionCompressedTextureBPTCAtoms;
class ClientWebGLExtensionCompressedTextureES3;
struct ClientWebGLExtensionCompressedTextureES3Atoms;
class ClientWebGLExtensionCompressedTextureETC1;
struct ClientWebGLExtensionCompressedTextureETC1Atoms;
class ClientWebGLExtensionCompressedTexturePVRTC;
struct ClientWebGLExtensionCompressedTexturePVRTCAtoms;
class ClientWebGLExtensionCompressedTextureRGTC;
struct ClientWebGLExtensionCompressedTextureRGTCAtoms;
class ClientWebGLExtensionCompressedTextureS3TC;
struct ClientWebGLExtensionCompressedTextureS3TCAtoms;
class ClientWebGLExtensionCompressedTextureS3TC_SRGB;
struct ClientWebGLExtensionCompressedTextureS3TC_SRGBAtoms;
class ClientWebGLExtensionDebugRendererInfo;
struct ClientWebGLExtensionDebugRendererInfoAtoms;
class ClientWebGLExtensionDebugShaders;
struct ClientWebGLExtensionDebugShadersAtoms;
class ClientWebGLExtensionDepthTexture;
struct ClientWebGLExtensionDepthTextureAtoms;
class ClientWebGLExtensionDisjointTimerQuery;
struct ClientWebGLExtensionDisjointTimerQueryAtoms;
class ClientWebGLExtensionDrawBuffers;
struct ClientWebGLExtensionDrawBuffersAtoms;
class ClientWebGLExtensionElementIndexUint;
struct ClientWebGLExtensionElementIndexUintAtoms;
class ClientWebGLExtensionExplicitPresent;
struct ClientWebGLExtensionExplicitPresentAtoms;
class ClientWebGLExtensionFBORenderMipmap;
struct ClientWebGLExtensionFBORenderMipmapAtoms;
class ClientWebGLExtensionFloatBlend;
struct ClientWebGLExtensionFloatBlendAtoms;
class ClientWebGLExtensionFragDepth;
struct ClientWebGLExtensionFragDepthAtoms;
class ClientWebGLExtensionInstancedArrays;
struct ClientWebGLExtensionInstancedArraysAtoms;
class ClientWebGLExtensionLoseContext;
struct ClientWebGLExtensionLoseContextAtoms;
class ClientWebGLExtensionMOZDebug;
struct ClientWebGLExtensionMOZDebugAtoms;
class ClientWebGLExtensionSRGB;
struct ClientWebGLExtensionSRGBAtoms;
class ClientWebGLExtensionShaderTextureLod;
struct ClientWebGLExtensionShaderTextureLodAtoms;
class ClientWebGLExtensionStandardDerivatives;
struct ClientWebGLExtensionStandardDerivativesAtoms;
class ClientWebGLExtensionTextureFilterAnisotropic;
struct ClientWebGLExtensionTextureFilterAnisotropicAtoms;
class ClientWebGLExtensionTextureFloat;
struct ClientWebGLExtensionTextureFloatAtoms;
class ClientWebGLExtensionTextureFloatLinear;
struct ClientWebGLExtensionTextureFloatLinearAtoms;
class ClientWebGLExtensionTextureHalfFloat;
struct ClientWebGLExtensionTextureHalfFloatAtoms;
class ClientWebGLExtensionTextureHalfFloatLinear;
struct ClientWebGLExtensionTextureHalfFloatLinearAtoms;
class ClientWebGLExtensionTextureNorm16;
struct ClientWebGLExtensionTextureNorm16Atoms;
class ClientWebGLExtensionVertexArray;
struct ClientWebGLExtensionVertexArrayAtoms;
class WebGLActiveInfoJS;
struct WebGLActiveInfoJSAtoms;
class WebGLBufferJS;
struct WebGLBufferJSAtoms;
class WebGLFramebufferJS;
struct WebGLFramebufferJSAtoms;
class WebGLProgramJS;
struct WebGLProgramJSAtoms;
class WebGLQueryJS;
struct WebGLQueryJSAtoms;
class WebGLRenderbufferJS;
struct WebGLRenderbufferJSAtoms;
class WebGLShaderJS;
struct WebGLShaderJSAtoms;
class WebGLShaderPrecisionFormatJS;
struct WebGLShaderPrecisionFormatJSAtoms;
class WebGLTextureJS;
struct WebGLTextureJSAtoms;
class WebGLUniformLocationJS;
struct WebGLUniformLocationJSAtoms;
class WebGLVertexArrayJS;
struct WebGLVertexArrayJSAtoms;

namespace dom {

class HTMLCanvasElement;
struct NativePropertyHooks;
class OffscreenCanvas;
class OwningHTMLCanvasElementOrOffscreenCanvas;
class ProtoAndIfaceCache;
struct WebGLContextAttributesAtoms;

} // namespace dom

} // namespace mozilla

namespace mozilla {
namespace dom {

enum class WebGLPowerPreference : uint8_t {
  Default,
  Low_power,
  High_performance,
  EndGuard_
};

namespace WebGLPowerPreferenceValues {
extern const EnumEntry strings[4];

static constexpr size_t Count = 3;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(WebGLPowerPreference::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(WebGLPowerPreference stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace WebGLPowerPreferenceValues

bool
ToJSValue(JSContext* aCx, WebGLPowerPreference aArgument, JS::MutableHandle<JS::Value> aValue);


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningHTMLCanvasElementOrOffscreenCanvas& aUnion, const char* aName, uint32_t aFlags = 0);


void
ImplCycleCollectionUnlink(OwningHTMLCanvasElementOrOffscreenCanvas& aUnion);


class HTMLCanvasElementOrOffscreenCanvas
{
  friend class HTMLCanvasElementOrOffscreenCanvasArgument;
  enum Type
  {
    eUninitialized,
    eHTMLCanvasElement,
    eOffscreenCanvas
  };

  union Value
  {
    UnionMember<NonNull<mozilla::dom::HTMLCanvasElement> > mHTMLCanvasElement;
    UnionMember<NonNull<mozilla::dom::OffscreenCanvas> > mOffscreenCanvas;

  };

  Type mType;
  Value mValue;

  HTMLCanvasElementOrOffscreenCanvas(const HTMLCanvasElementOrOffscreenCanvas&) = delete;
  HTMLCanvasElementOrOffscreenCanvas& operator=(const HTMLCanvasElementOrOffscreenCanvas&) = delete;
public:
  explicit inline HTMLCanvasElementOrOffscreenCanvas()
    : mType(eUninitialized)
  {
  }

  inline ~HTMLCanvasElementOrOffscreenCanvas()
  {
    Uninit();
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  RawSetAsHTMLCanvasElement()
  {
    if (mType == eHTMLCanvasElement) {
      return mValue.mHTMLCanvasElement.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eHTMLCanvasElement;
    return mValue.mHTMLCanvasElement.SetValue();
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  SetAsHTMLCanvasElement()
  {
    if (mType == eHTMLCanvasElement) {
      return mValue.mHTMLCanvasElement.Value();
    }
    Uninit();
    mType = eHTMLCanvasElement;
    return mValue.mHTMLCanvasElement.SetValue();
  }

  inline bool
  IsHTMLCanvasElement() const
  {
    return mType == eHTMLCanvasElement;
  }

  inline NonNull<mozilla::dom::HTMLCanvasElement>&
  GetAsHTMLCanvasElement()
  {
    MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
    return mValue.mHTMLCanvasElement.Value();
  }

  inline mozilla::dom::HTMLCanvasElement&
  GetAsHTMLCanvasElement() const
  {
    MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
    return mValue.mHTMLCanvasElement.Value();
  }

  inline NonNull<mozilla::dom::OffscreenCanvas>&
  RawSetAsOffscreenCanvas()
  {
    if (mType == eOffscreenCanvas) {
      return mValue.mOffscreenCanvas.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eOffscreenCanvas;
    return mValue.mOffscreenCanvas.SetValue();
  }

  inline NonNull<mozilla::dom::OffscreenCanvas>&
  SetAsOffscreenCanvas()
  {
    if (mType == eOffscreenCanvas) {
      return mValue.mOffscreenCanvas.Value();
    }
    Uninit();
    mType = eOffscreenCanvas;
    return mValue.mOffscreenCanvas.SetValue();
  }

  inline bool
  IsOffscreenCanvas() const
  {
    return mType == eOffscreenCanvas;
  }

  inline NonNull<mozilla::dom::OffscreenCanvas>&
  GetAsOffscreenCanvas()
  {
    MOZ_ASSERT(IsOffscreenCanvas(), "Wrong type!");
    return mValue.mOffscreenCanvas.Value();
  }

  inline mozilla::dom::OffscreenCanvas&
  GetAsOffscreenCanvas() const
  {
    MOZ_ASSERT(IsOffscreenCanvas(), "Wrong type!");
    return mValue.mOffscreenCanvas.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eHTMLCanvasElement: {
        DestroyHTMLCanvasElement();
        break;
      }
      case eOffscreenCanvas: {
        DestroyOffscreenCanvas();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyHTMLCanvasElement()
  {
    MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
    mValue.mHTMLCanvasElement.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyOffscreenCanvas()
  {
    MOZ_ASSERT(IsOffscreenCanvas(), "Wrong type!");
    mValue.mOffscreenCanvas.Destroy();
    mType = eUninitialized;
  }
};


class OwningHTMLCanvasElementOrOffscreenCanvas : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningHTMLCanvasElementOrOffscreenCanvas& aUnion);
  enum Type
  {
    eUninitialized,
    eHTMLCanvasElement,
    eOffscreenCanvas
  };

  union Value
  {
    UnionMember<OwningNonNull<mozilla::dom::HTMLCanvasElement> > mHTMLCanvasElement;
    UnionMember<OwningNonNull<mozilla::dom::OffscreenCanvas> > mOffscreenCanvas;

  };

  Type mType;
  Value mValue;

public:
  explicit inline OwningHTMLCanvasElementOrOffscreenCanvas()
    : mType(eUninitialized)
  {
  }

  explicit inline OwningHTMLCanvasElementOrOffscreenCanvas(const OwningHTMLCanvasElementOrOffscreenCanvas& aOther)
    : mType(eUninitialized)
  {
    *this = aOther;
  }

  inline ~OwningHTMLCanvasElementOrOffscreenCanvas()
  {
    Uninit();
  }

  OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  RawSetAsHTMLCanvasElement();

  OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  SetAsHTMLCanvasElement();

  bool
  TrySetToHTMLCanvasElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToHTMLCanvasElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsHTMLCanvasElement() const
  {
    return mType == eHTMLCanvasElement;
  }

  inline OwningNonNull<mozilla::dom::HTMLCanvasElement>&
  GetAsHTMLCanvasElement()
  {
    MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
    return mValue.mHTMLCanvasElement.Value();
  }

  inline OwningNonNull<mozilla::dom::HTMLCanvasElement> const &
  GetAsHTMLCanvasElement() const
  {
    MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
    return mValue.mHTMLCanvasElement.Value();
  }

  OwningNonNull<mozilla::dom::OffscreenCanvas>&
  RawSetAsOffscreenCanvas();

  OwningNonNull<mozilla::dom::OffscreenCanvas>&
  SetAsOffscreenCanvas();

  bool
  TrySetToOffscreenCanvas(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToOffscreenCanvas(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsOffscreenCanvas() const
  {
    return mType == eOffscreenCanvas;
  }

  inline OwningNonNull<mozilla::dom::OffscreenCanvas>&
  GetAsOffscreenCanvas()
  {
    MOZ_ASSERT(IsOffscreenCanvas(), "Wrong type!");
    return mValue.mOffscreenCanvas.Value();
  }

  inline OwningNonNull<mozilla::dom::OffscreenCanvas> const &
  GetAsOffscreenCanvas() const
  {
    MOZ_ASSERT(IsOffscreenCanvas(), "Wrong type!");
    return mValue.mOffscreenCanvas.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

  OwningHTMLCanvasElementOrOffscreenCanvas&
  operator=(const OwningHTMLCanvasElementOrOffscreenCanvas& aOther);

private:
  void
  DestroyHTMLCanvasElement();

  void
  DestroyOffscreenCanvas();
};


class MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence
{
  friend class MaybeSharedFloat32ArrayOrUnrestrictedFloatSequenceArgument;
  enum Type
  {
    eUninitialized,
    eFloat32Array,
    eUnrestrictedFloatSequence
  };

  union Value
  {
    UnionMember<RootedSpiderMonkeyInterface<Float32Array> > mFloat32Array;
    UnionMember<binding_detail::AutoSequence<float> > mUnrestrictedFloatSequence;

  };

  Type mType;
  Value mValue;

  MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence(const MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence&) = delete;
  MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence& operator=(const MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence&) = delete;
public:
  explicit inline MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence()
    : mType(eUninitialized)
  {
  }

  inline ~MaybeSharedFloat32ArrayOrUnrestrictedFloatSequence()
  {
    Uninit();
  }

  inline RootedSpiderMonkeyInterface<Float32Array>&
  RawSetAsFloat32Array(JSContext* cx)
  {
    if (mType == eFloat32Array) {
      return mValue.mFloat32Array.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eFloat32Array;
    return mValue.mFloat32Array.SetValue(cx);
  }

  inline RootedSpiderMonkeyInterface<Float32Array>&
  SetAsFloat32Array(JSContext* cx)
  {
    if (mType == eFloat32Array) {
      return mValue.mFloat32Array.Value();
    }
    Uninit();
    mType = eFloat32Array;
    return mValue.mFloat32Array.SetValue(cx);
  }

  inline bool
  IsFloat32Array() const
  {
    return mType == eFloat32Array;
  }

  inline RootedSpiderMonkeyInterface<Float32Array>&
  GetAsFloat32Array()
  {
    MOZ_ASSERT(IsFloat32Array(), "Wrong type!");
    return mValue.mFloat32Array.Value();
  }

  inline Float32Array const &
  GetAsFloat32Array() const
  {
    MOZ_ASSERT(IsFloat32Array(), "Wrong type!");
    return mValue.mFloat32Array.Value();
  }

  inline binding_detail::AutoSequence<float>&
  RawSetAsUnrestrictedFloatSequence()
  {
    if (mType == eUnrestrictedFloatSequence) {
      return mValue.mUnrestrictedFloatSequence.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eUnrestrictedFloatSequence;
    return mValue.mUnrestrictedFloatSequence.SetValue();
  }

  inline binding_detail::AutoSequence<float>&
  SetAsUnrestrictedFloatSequence()
  {
    if (mType == eUnrestrictedFloatSequence) {
      return mValue.mUnrestrictedFloatSequence.Value();
    }
    Uninit();
    mType = eUnrestrictedFloatSequence;
    return mValue.mUnrestrictedFloatSequence.SetValue();
  }

  inline bool
  IsUnrestrictedFloatSequence() const
  {
    return mType == eUnrestrictedFloatSequence;
  }

  inline binding_detail::AutoSequence<float>&
  GetAsUnrestrictedFloatSequence()
  {
    MOZ_ASSERT(IsUnrestrictedFloatSequence(), "Wrong type!");
    return mValue.mUnrestrictedFloatSequence.Value();
  }

  inline const Sequence<float>&
  GetAsUnrestrictedFloatSequence() const
  {
    MOZ_ASSERT(IsUnrestrictedFloatSequence(), "Wrong type!");
    return mValue.mUnrestrictedFloatSequence.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eFloat32Array: {
        DestroyFloat32Array();
        break;
      }
      case eUnrestrictedFloatSequence: {
        DestroyUnrestrictedFloatSequence();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyFloat32Array()
  {
    MOZ_ASSERT(IsFloat32Array(), "Wrong type!");
    mValue.mFloat32Array.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyUnrestrictedFloatSequence()
  {
    MOZ_ASSERT(IsUnrestrictedFloatSequence(), "Wrong type!");
    mValue.mUnrestrictedFloatSequence.Destroy();
    mType = eUninitialized;
  }
};


class OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence& aUnion);
  enum Type
  {
    eUninitialized,
    eFloat32Array,
    eUnrestrictedFloatSequence
  };

  union Value
  {
    UnionMember<Float32Array > mFloat32Array;
    UnionMember<Sequence<float> > mUnrestrictedFloatSequence;

  };

  Type mType;
  Value mValue;

  OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence(const OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence&) = delete;
  OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence& operator=(const OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence&) = delete;
public:
  explicit inline OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence()
    : mType(eUninitialized)
  {
  }

  inline ~OwningMaybeSharedFloat32ArrayOrUnrestrictedFloatSequence()
  {
    Uninit();
  }

  Float32Array&
  RawSetAsFloat32Array();

  Float32Array&
  SetAsFloat32Array();

  bool
  TrySetToFloat32Array(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToFloat32Array(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsFloat32Array() const
  {
    return mType == eFloat32Array;
  }

  inline Float32Array&
  GetAsFloat32Array()
  {
    MOZ_ASSERT(IsFloat32Array(), "Wrong type!");
    return mValue.mFloat32Array.Value();
  }

  inline Float32Array const &
  GetAsFloat32Array() const
  {
    MOZ_ASSERT(IsFloat32Array(), "Wrong type!");
    return mValue.mFloat32Array.Value();
  }

  Sequence<float>&
  RawSetAsUnrestrictedFloatSequence();

  Sequence<float>&
  SetAsUnrestrictedFloatSequence();

  bool
  TrySetToUnrestrictedFloatSequence(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToUnrestrictedFloatSequence(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsUnrestrictedFloatSequence() const
  {
    return mType == eUnrestrictedFloatSequence;
  }

  inline Sequence<float>&
  GetAsUnrestrictedFloatSequence()
  {
    MOZ_ASSERT(IsUnrestrictedFloatSequence(), "Wrong type!");
    return mValue.mUnrestrictedFloatSequence.Value();
  }

  inline Sequence<float> const &
  GetAsUnrestrictedFloatSequence() const
  {
    MOZ_ASSERT(IsUnrestrictedFloatSequence(), "Wrong type!");
    return mValue.mUnrestrictedFloatSequence.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

private:
  void
  DestroyFloat32Array();

  void
  DestroyUnrestrictedFloatSequence();
};


class MaybeSharedInt32ArrayOrLongSequence
{
  friend class MaybeSharedInt32ArrayOrLongSequenceArgument;
  enum Type
  {
    eUninitialized,
    eInt32Array,
    eLongSequence
  };

  union Value
  {
    UnionMember<RootedSpiderMonkeyInterface<Int32Array> > mInt32Array;
    UnionMember<binding_detail::AutoSequence<int32_t> > mLongSequence;

  };

  Type mType;
  Value mValue;

  MaybeSharedInt32ArrayOrLongSequence(const MaybeSharedInt32ArrayOrLongSequence&) = delete;
  MaybeSharedInt32ArrayOrLongSequence& operator=(const MaybeSharedInt32ArrayOrLongSequence&) = delete;
public:
  explicit inline MaybeSharedInt32ArrayOrLongSequence()
    : mType(eUninitialized)
  {
  }

  inline ~MaybeSharedInt32ArrayOrLongSequence()
  {
    Uninit();
  }

  inline RootedSpiderMonkeyInterface<Int32Array>&
  RawSetAsInt32Array(JSContext* cx)
  {
    if (mType == eInt32Array) {
      return mValue.mInt32Array.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eInt32Array;
    return mValue.mInt32Array.SetValue(cx);
  }

  inline RootedSpiderMonkeyInterface<Int32Array>&
  SetAsInt32Array(JSContext* cx)
  {
    if (mType == eInt32Array) {
      return mValue.mInt32Array.Value();
    }
    Uninit();
    mType = eInt32Array;
    return mValue.mInt32Array.SetValue(cx);
  }

  inline bool
  IsInt32Array() const
  {
    return mType == eInt32Array;
  }

  inline RootedSpiderMonkeyInterface<Int32Array>&
  GetAsInt32Array()
  {
    MOZ_ASSERT(IsInt32Array(), "Wrong type!");
    return mValue.mInt32Array.Value();
  }

  inline Int32Array const &
  GetAsInt32Array() const
  {
    MOZ_ASSERT(IsInt32Array(), "Wrong type!");
    return mValue.mInt32Array.Value();
  }

  inline binding_detail::AutoSequence<int32_t>&
  RawSetAsLongSequence()
  {
    if (mType == eLongSequence) {
      return mValue.mLongSequence.Value();
    }
    MOZ_ASSERT(mType == eUninitialized);
    mType = eLongSequence;
    return mValue.mLongSequence.SetValue();
  }

  inline binding_detail::AutoSequence<int32_t>&
  SetAsLongSequence()
  {
    if (mType == eLongSequence) {
      return mValue.mLongSequence.Value();
    }
    Uninit();
    mType = eLongSequence;
    return mValue.mLongSequence.SetValue();
  }

  inline bool
  IsLongSequence() const
  {
    return mType == eLongSequence;
  }

  inline binding_detail::AutoSequence<int32_t>&
  GetAsLongSequence()
  {
    MOZ_ASSERT(IsLongSequence(), "Wrong type!");
    return mValue.mLongSequence.Value();
  }

  inline const Sequence<int32_t>&
  GetAsLongSequence() const
  {
    MOZ_ASSERT(IsLongSequence(), "Wrong type!");
    return mValue.mLongSequence.Value();
  }

  inline void
  Uninit()
  {
    switch (mType) {
      case eUninitialized: {
        break;
      }
      case eInt32Array: {
        DestroyInt32Array();
        break;
      }
      case eLongSequence: {
        DestroyLongSequence();
        break;
      }
    }
  }

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

private:
  inline void
  DestroyInt32Array()
  {
    MOZ_ASSERT(IsInt32Array(), "Wrong type!");
    mValue.mInt32Array.Destroy();
    mType = eUninitialized;
  }

  inline void
  DestroyLongSequence()
  {
    MOZ_ASSERT(IsLongSequence(), "Wrong type!");
    mValue.mLongSequence.Destroy();
    mType = eUninitialized;
  }
};


class OwningMaybeSharedInt32ArrayOrLongSequence : public AllOwningUnionBase
{
  friend void ImplCycleCollectionUnlink(OwningMaybeSharedInt32ArrayOrLongSequence& aUnion);
  enum Type
  {
    eUninitialized,
    eInt32Array,
    eLongSequence
  };

  union Value
  {
    UnionMember<Int32Array > mInt32Array;
    UnionMember<Sequence<int32_t> > mLongSequence;

  };

  Type mType;
  Value mValue;

  OwningMaybeSharedInt32ArrayOrLongSequence(const OwningMaybeSharedInt32ArrayOrLongSequence&) = delete;
  OwningMaybeSharedInt32ArrayOrLongSequence& operator=(const OwningMaybeSharedInt32ArrayOrLongSequence&) = delete;
public:
  explicit inline OwningMaybeSharedInt32ArrayOrLongSequence()
    : mType(eUninitialized)
  {
  }

  inline ~OwningMaybeSharedInt32ArrayOrLongSequence()
  {
    Uninit();
  }

  Int32Array&
  RawSetAsInt32Array();

  Int32Array&
  SetAsInt32Array();

  bool
  TrySetToInt32Array(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToInt32Array(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsInt32Array() const
  {
    return mType == eInt32Array;
  }

  inline Int32Array&
  GetAsInt32Array()
  {
    MOZ_ASSERT(IsInt32Array(), "Wrong type!");
    return mValue.mInt32Array.Value();
  }

  inline Int32Array const &
  GetAsInt32Array() const
  {
    MOZ_ASSERT(IsInt32Array(), "Wrong type!");
    return mValue.mInt32Array.Value();
  }

  Sequence<int32_t>&
  RawSetAsLongSequence();

  Sequence<int32_t>&
  SetAsLongSequence();

  bool
  TrySetToLongSequence(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  bool
  TrySetToLongSequence(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl = false);

  inline bool
  IsLongSequence() const
  {
    return mType == eLongSequence;
  }

  inline Sequence<int32_t>&
  GetAsLongSequence()
  {
    MOZ_ASSERT(IsLongSequence(), "Wrong type!");
    return mValue.mLongSequence.Value();
  }

  inline Sequence<int32_t> const &
  GetAsLongSequence() const
  {
    MOZ_ASSERT(IsLongSequence(), "Wrong type!");
    return mValue.mLongSequence.Value();
  }

  void
  Uninit();

  bool
  ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceUnion(JSTracer* trc);

private:
  void
  DestroyInt32Array();

  void
  DestroyLongSequence();
};


struct WebGLContextAttributes : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mAlpha;
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mAntialias;
  MOZ_INIT_OUTSIDE_CTOR bool mDepth;
  MOZ_INIT_OUTSIDE_CTOR bool mFailIfMajorPerformanceCaveat;
  MOZ_INIT_OUTSIDE_CTOR WebGLPowerPreference mPowerPreference;
  MOZ_INIT_OUTSIDE_CTOR bool mPremultipliedAlpha;
  MOZ_INIT_OUTSIDE_CTOR bool mPreserveDrawingBuffer;
  MOZ_INIT_OUTSIDE_CTOR bool mStencil;
  MOZ_INIT_OUTSIDE_CTOR bool mXrCompatible;

  WebGLContextAttributes();

  explicit inline WebGLContextAttributes(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline WebGLContextAttributes(const WebGLContextAttributes& aOther)
  {
    *this = aOther;
  }

  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  WebGLContextAttributes&
  operator=(const WebGLContextAttributes& aOther);

private:
  static bool
  InitIds(JSContext* cx, WebGLContextAttributesAtoms* atomsCache);
};

namespace binding_detail {
struct FastWebGLContextAttributes : public WebGLContextAttributes
{
  inline FastWebGLContextAttributes()
    : WebGLContextAttributes(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


namespace ANGLE_instanced_arrays_Binding {

  typedef mozilla::ClientWebGLExtensionInstancedArrays NativeType;

  static const uint32_t VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 35070;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionInstancedArrays* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::ANGLE_instanced_arrays,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace ANGLE_instanced_arrays_Binding



namespace EXT_blend_minmax_Binding {

  typedef mozilla::ClientWebGLExtensionBlendMinMax NativeType;

  static const uint32_t MIN_EXT = 32775;
  static const uint32_t MAX_EXT = 32776;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionBlendMinMax* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_blend_minmax,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_blend_minmax_Binding



namespace EXT_color_buffer_half_float_Binding {

  typedef mozilla::ClientWebGLExtensionColorBufferHalfFloat NativeType;

  static const uint32_t RGBA16F_EXT = 34842;
  static const uint32_t RGB16F_EXT = 34843;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297;
  static const uint32_t UNSIGNED_NORMALIZED_EXT = 35863;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionColorBufferHalfFloat* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_color_buffer_half_float,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_color_buffer_half_float_Binding



namespace EXT_disjoint_timer_query_Binding {

  typedef mozilla::ClientWebGLExtensionDisjointTimerQuery NativeType;

  static const uint32_t QUERY_COUNTER_BITS_EXT = 34916;
  static const uint32_t CURRENT_QUERY_EXT = 34917;
  static const uint32_t QUERY_RESULT_EXT = 34918;
  static const uint32_t QUERY_RESULT_AVAILABLE_EXT = 34919;
  static const uint32_t TIME_ELAPSED_EXT = 35007;
  static const uint32_t TIMESTAMP_EXT = 36392;
  static const uint32_t GPU_DISJOINT_EXT = 36795;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionDisjointTimerQuery* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_disjoint_timer_query,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_disjoint_timer_query_Binding



namespace EXT_float_blend_Binding {

  typedef mozilla::ClientWebGLExtensionFloatBlend NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionFloatBlend* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_float_blend,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_float_blend_Binding



namespace EXT_frag_depth_Binding {

  typedef mozilla::ClientWebGLExtensionFragDepth NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionFragDepth* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_frag_depth,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_frag_depth_Binding



namespace EXT_sRGB_Binding {

  typedef mozilla::ClientWebGLExtensionSRGB NativeType;

  static const uint32_t SRGB_EXT = 35904;
  static const uint32_t SRGB_ALPHA_EXT = 35906;
  static const uint32_t SRGB8_ALPHA8_EXT = 35907;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 33296;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionSRGB* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_sRGB,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_sRGB_Binding



namespace EXT_shader_texture_lod_Binding {

  typedef mozilla::ClientWebGLExtensionShaderTextureLod NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionShaderTextureLod* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_shader_texture_lod,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_shader_texture_lod_Binding



namespace EXT_texture_compression_bptc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureBPTC NativeType;

  static const uint32_t COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492;
  static const uint32_t COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493;
  static const uint32_t COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494;
  static const uint32_t COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureBPTC* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_texture_compression_bptc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_texture_compression_bptc_Binding



namespace EXT_texture_compression_rgtc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureRGTC NativeType;

  static const uint32_t COMPRESSED_RED_RGTC1_EXT = 36283;
  static const uint32_t COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284;
  static const uint32_t COMPRESSED_RED_GREEN_RGTC2_EXT = 36285;
  static const uint32_t COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureRGTC* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_texture_compression_rgtc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_texture_compression_rgtc_Binding



namespace EXT_texture_filter_anisotropic_Binding {

  typedef mozilla::ClientWebGLExtensionTextureFilterAnisotropic NativeType;

  static const uint32_t TEXTURE_MAX_ANISOTROPY_EXT = 34046;
  static const uint32_t MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureFilterAnisotropic* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_texture_filter_anisotropic,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_texture_filter_anisotropic_Binding



namespace EXT_texture_norm16_Binding {

  typedef mozilla::ClientWebGLExtensionTextureNorm16 NativeType;

  static const uint32_t R16_EXT = 33322;
  static const uint32_t RG16_EXT = 33324;
  static const uint32_t RGB16_EXT = 32852;
  static const uint32_t RGBA16_EXT = 32859;
  static const uint32_t R16_SNORM_EXT = 36760;
  static const uint32_t RG16_SNORM_EXT = 36761;
  static const uint32_t RGB16_SNORM_EXT = 36762;
  static const uint32_t RGBA16_SNORM_EXT = 36763;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureNorm16* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::EXT_texture_norm16,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace EXT_texture_norm16_Binding



namespace MOZ_debug_Binding {

  typedef mozilla::ClientWebGLExtensionMOZDebug NativeType;

  static const uint32_t EXTENSIONS = 7939;
  static const uint32_t WSI_INFO = 65536;
  static const uint32_t UNPACK_REQUIRE_FASTPATH = 65537;
  static const uint32_t DOES_INDEX_VALIDATION = 65538;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionMOZDebug* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::MOZ_debug,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace MOZ_debug_Binding



namespace OES_element_index_uint_Binding {

  typedef mozilla::ClientWebGLExtensionElementIndexUint NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionElementIndexUint* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_element_index_uint,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_element_index_uint_Binding



namespace OES_fbo_render_mipmap_Binding {

  typedef mozilla::ClientWebGLExtensionFBORenderMipmap NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionFBORenderMipmap* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_fbo_render_mipmap,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_fbo_render_mipmap_Binding



namespace OES_standard_derivatives_Binding {

  typedef mozilla::ClientWebGLExtensionStandardDerivatives NativeType;

  static const uint32_t FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 35723;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionStandardDerivatives* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_standard_derivatives,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_standard_derivatives_Binding



namespace OES_texture_float_Binding {

  typedef mozilla::ClientWebGLExtensionTextureFloat NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureFloat* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_texture_float,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_texture_float_Binding



namespace OES_texture_float_linear_Binding {

  typedef mozilla::ClientWebGLExtensionTextureFloatLinear NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureFloatLinear* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_texture_float_linear,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_texture_float_linear_Binding



namespace OES_texture_half_float_Binding {

  typedef mozilla::ClientWebGLExtensionTextureHalfFloat NativeType;

  static const uint32_t HALF_FLOAT_OES = 36193;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureHalfFloat* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_texture_half_float,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_texture_half_float_Binding



namespace OES_texture_half_float_linear_Binding {

  typedef mozilla::ClientWebGLExtensionTextureHalfFloatLinear NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionTextureHalfFloatLinear* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_texture_half_float_linear,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_texture_half_float_linear_Binding



namespace OES_vertex_array_object_Binding {

  typedef mozilla::ClientWebGLExtensionVertexArray NativeType;

  static const uint32_t VERTEX_ARRAY_BINDING_OES = 34229;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionVertexArray* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OES_vertex_array_object,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace OES_vertex_array_object_Binding



namespace WEBGL_color_buffer_float_Binding {

  typedef mozilla::ClientWebGLExtensionColorBufferFloat NativeType;

  static const uint32_t RGBA32F_EXT = 34836;
  static const uint32_t RGB32F_EXT = 34837;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297;
  static const uint32_t UNSIGNED_NORMALIZED_EXT = 35863;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionColorBufferFloat* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_color_buffer_float,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_color_buffer_float_Binding



namespace WEBGL_compressed_texture_astc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureASTC NativeType;

  static const uint32_t COMPRESSED_RGBA_ASTC_4x4_KHR = 37808;
  static const uint32_t COMPRESSED_RGBA_ASTC_5x4_KHR = 37809;
  static const uint32_t COMPRESSED_RGBA_ASTC_5x5_KHR = 37810;
  static const uint32_t COMPRESSED_RGBA_ASTC_6x5_KHR = 37811;
  static const uint32_t COMPRESSED_RGBA_ASTC_6x6_KHR = 37812;
  static const uint32_t COMPRESSED_RGBA_ASTC_8x5_KHR = 37813;
  static const uint32_t COMPRESSED_RGBA_ASTC_8x6_KHR = 37814;
  static const uint32_t COMPRESSED_RGBA_ASTC_8x8_KHR = 37815;
  static const uint32_t COMPRESSED_RGBA_ASTC_10x5_KHR = 37816;
  static const uint32_t COMPRESSED_RGBA_ASTC_10x6_KHR = 37817;
  static const uint32_t COMPRESSED_RGBA_ASTC_10x8_KHR = 37818;
  static const uint32_t COMPRESSED_RGBA_ASTC_10x10_KHR = 37819;
  static const uint32_t COMPRESSED_RGBA_ASTC_12x10_KHR = 37820;
  static const uint32_t COMPRESSED_RGBA_ASTC_12x12_KHR = 37821;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureASTC* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_astc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_astc_Binding



namespace WEBGL_compressed_texture_etc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureES3 NativeType;

  static const uint32_t COMPRESSED_R11_EAC = 37488;
  static const uint32_t COMPRESSED_SIGNED_R11_EAC = 37489;
  static const uint32_t COMPRESSED_RG11_EAC = 37490;
  static const uint32_t COMPRESSED_SIGNED_RG11_EAC = 37491;
  static const uint32_t COMPRESSED_RGB8_ETC2 = 37492;
  static const uint32_t COMPRESSED_SRGB8_ETC2 = 37493;
  static const uint32_t COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
  static const uint32_t COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
  static const uint32_t COMPRESSED_RGBA8_ETC2_EAC = 37496;
  static const uint32_t COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureES3* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_etc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_etc_Binding



namespace WEBGL_compressed_texture_etc1_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureETC1 NativeType;

  static const uint32_t COMPRESSED_RGB_ETC1_WEBGL = 36196;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureETC1* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_etc1,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_etc1_Binding



namespace WEBGL_compressed_texture_pvrtc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTexturePVRTC NativeType;

  static const uint32_t COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
  static const uint32_t COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
  static const uint32_t COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
  static const uint32_t COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTexturePVRTC* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_pvrtc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_pvrtc_Binding



namespace WEBGL_compressed_texture_s3tc_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureS3TC NativeType;

  static const uint32_t COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
  static const uint32_t COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
  static const uint32_t COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
  static const uint32_t COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureS3TC* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_s3tc,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_s3tc_Binding



namespace WEBGL_compressed_texture_s3tc_srgb_Binding {

  typedef mozilla::ClientWebGLExtensionCompressedTextureS3TC_SRGB NativeType;

  static const uint32_t COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
  static const uint32_t COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
  static const uint32_t COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
  static const uint32_t COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionCompressedTextureS3TC_SRGB* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_compressed_texture_s3tc_srgb,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_compressed_texture_s3tc_srgb_Binding



namespace WEBGL_debug_renderer_info_Binding {

  typedef mozilla::ClientWebGLExtensionDebugRendererInfo NativeType;

  static const uint32_t UNMASKED_VENDOR_WEBGL = 37445;
  static const uint32_t UNMASKED_RENDERER_WEBGL = 37446;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionDebugRendererInfo* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_debug_renderer_info,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_debug_renderer_info_Binding



namespace WEBGL_debug_shaders_Binding {

  typedef mozilla::ClientWebGLExtensionDebugShaders NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionDebugShaders* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_debug_shaders,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_debug_shaders_Binding



namespace WEBGL_depth_texture_Binding {

  typedef mozilla::ClientWebGLExtensionDepthTexture NativeType;

  static const uint32_t UNSIGNED_INT_24_8_WEBGL = 34042;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionDepthTexture* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_depth_texture,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_depth_texture_Binding



namespace WEBGL_draw_buffers_Binding {

  typedef mozilla::ClientWebGLExtensionDrawBuffers NativeType;

  static const uint32_t COLOR_ATTACHMENT0_WEBGL = 36064;
  static const uint32_t COLOR_ATTACHMENT1_WEBGL = 36065;
  static const uint32_t COLOR_ATTACHMENT2_WEBGL = 36066;
  static const uint32_t COLOR_ATTACHMENT3_WEBGL = 36067;
  static const uint32_t COLOR_ATTACHMENT4_WEBGL = 36068;
  static const uint32_t COLOR_ATTACHMENT5_WEBGL = 36069;
  static const uint32_t COLOR_ATTACHMENT6_WEBGL = 36070;
  static const uint32_t COLOR_ATTACHMENT7_WEBGL = 36071;
  static const uint32_t COLOR_ATTACHMENT8_WEBGL = 36072;
  static const uint32_t COLOR_ATTACHMENT9_WEBGL = 36073;
  static const uint32_t COLOR_ATTACHMENT10_WEBGL = 36074;
  static const uint32_t COLOR_ATTACHMENT11_WEBGL = 36075;
  static const uint32_t COLOR_ATTACHMENT12_WEBGL = 36076;
  static const uint32_t COLOR_ATTACHMENT13_WEBGL = 36077;
  static const uint32_t COLOR_ATTACHMENT14_WEBGL = 36078;
  static const uint32_t COLOR_ATTACHMENT15_WEBGL = 36079;
  static const uint32_t DRAW_BUFFER0_WEBGL = 34853;
  static const uint32_t DRAW_BUFFER1_WEBGL = 34854;
  static const uint32_t DRAW_BUFFER2_WEBGL = 34855;
  static const uint32_t DRAW_BUFFER3_WEBGL = 34856;
  static const uint32_t DRAW_BUFFER4_WEBGL = 34857;
  static const uint32_t DRAW_BUFFER5_WEBGL = 34858;
  static const uint32_t DRAW_BUFFER6_WEBGL = 34859;
  static const uint32_t DRAW_BUFFER7_WEBGL = 34860;
  static const uint32_t DRAW_BUFFER8_WEBGL = 34861;
  static const uint32_t DRAW_BUFFER9_WEBGL = 34862;
  static const uint32_t DRAW_BUFFER10_WEBGL = 34863;
  static const uint32_t DRAW_BUFFER11_WEBGL = 34864;
  static const uint32_t DRAW_BUFFER12_WEBGL = 34865;
  static const uint32_t DRAW_BUFFER13_WEBGL = 34866;
  static const uint32_t DRAW_BUFFER14_WEBGL = 34867;
  static const uint32_t DRAW_BUFFER15_WEBGL = 34868;
  static const uint32_t MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
  static const uint32_t MAX_DRAW_BUFFERS_WEBGL = 34852;
  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionDrawBuffers* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_draw_buffers,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_draw_buffers_Binding



namespace WEBGL_explicit_present_Binding {

  typedef mozilla::ClientWebGLExtensionExplicitPresent NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionExplicitPresent* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_explicit_present,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_explicit_present_Binding



namespace WEBGL_lose_context_Binding {

  typedef mozilla::ClientWebGLExtensionLoseContext NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLExtensionLoseContext* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WEBGL_lose_context,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace WEBGL_lose_context_Binding



namespace WebGLActiveInfo_Binding {

  typedef mozilla::WebGLActiveInfoJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLActiveInfoJS* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLActiveInfo,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLActiveInfo,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLActiveInfo_Binding



namespace WebGLBuffer_Binding {

  typedef mozilla::WebGLBufferJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLBufferJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLBuffer,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLBuffer,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLBuffer_Binding



namespace WebGLFramebuffer_Binding {

  typedef mozilla::WebGLFramebufferJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLFramebufferJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLFramebuffer,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLFramebuffer,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLFramebuffer_Binding



namespace WebGLProgram_Binding {

  typedef mozilla::WebGLProgramJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLProgramJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLProgram,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLProgram,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLProgram_Binding



namespace WebGLQuery_Binding {

  typedef mozilla::WebGLQueryJS NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLQueryJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLQuery,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLQuery,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLQuery_Binding



namespace WebGLRenderbuffer_Binding {

  typedef mozilla::WebGLRenderbufferJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLRenderbufferJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLRenderbuffer,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLRenderbuffer,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLRenderbuffer_Binding



namespace WebGLRenderingContext_Binding {

  typedef mozilla::ClientWebGLContext NativeType;

  static const uint32_t DEPTH_BUFFER_BIT = 256;
  static const uint32_t STENCIL_BUFFER_BIT = 1024;
  static const uint32_t COLOR_BUFFER_BIT = 16384;
  static const uint32_t POINTS = 0;
  static const uint32_t LINES = 1;
  static const uint32_t LINE_LOOP = 2;
  static const uint32_t LINE_STRIP = 3;
  static const uint32_t TRIANGLES = 4;
  static const uint32_t TRIANGLE_STRIP = 5;
  static const uint32_t TRIANGLE_FAN = 6;
  static const uint32_t ZERO = 0;
  static const uint32_t ONE = 1;
  static const uint32_t SRC_COLOR = 768;
  static const uint32_t ONE_MINUS_SRC_COLOR = 769;
  static const uint32_t SRC_ALPHA = 770;
  static const uint32_t ONE_MINUS_SRC_ALPHA = 771;
  static const uint32_t DST_ALPHA = 772;
  static const uint32_t ONE_MINUS_DST_ALPHA = 773;
  static const uint32_t DST_COLOR = 774;
  static const uint32_t ONE_MINUS_DST_COLOR = 775;
  static const uint32_t SRC_ALPHA_SATURATE = 776;
  static const uint32_t FUNC_ADD = 32774;
  static const uint32_t BLEND_EQUATION = 32777;
  static const uint32_t BLEND_EQUATION_RGB = 32777;
  static const uint32_t BLEND_EQUATION_ALPHA = 34877;
  static const uint32_t FUNC_SUBTRACT = 32778;
  static const uint32_t FUNC_REVERSE_SUBTRACT = 32779;
  static const uint32_t BLEND_DST_RGB = 32968;
  static const uint32_t BLEND_SRC_RGB = 32969;
  static const uint32_t BLEND_DST_ALPHA = 32970;
  static const uint32_t BLEND_SRC_ALPHA = 32971;
  static const uint32_t CONSTANT_COLOR = 32769;
  static const uint32_t ONE_MINUS_CONSTANT_COLOR = 32770;
  static const uint32_t CONSTANT_ALPHA = 32771;
  static const uint32_t ONE_MINUS_CONSTANT_ALPHA = 32772;
  static const uint32_t BLEND_COLOR = 32773;
  static const uint32_t ARRAY_BUFFER = 34962;
  static const uint32_t ELEMENT_ARRAY_BUFFER = 34963;
  static const uint32_t ARRAY_BUFFER_BINDING = 34964;
  static const uint32_t ELEMENT_ARRAY_BUFFER_BINDING = 34965;
  static const uint32_t STREAM_DRAW = 35040;
  static const uint32_t STATIC_DRAW = 35044;
  static const uint32_t DYNAMIC_DRAW = 35048;
  static const uint32_t BUFFER_SIZE = 34660;
  static const uint32_t BUFFER_USAGE = 34661;
  static const uint32_t CURRENT_VERTEX_ATTRIB = 34342;
  static const uint32_t FRONT = 1028;
  static const uint32_t BACK = 1029;
  static const uint32_t FRONT_AND_BACK = 1032;
  static const uint32_t CULL_FACE = 2884;
  static const uint32_t BLEND = 3042;
  static const uint32_t DITHER = 3024;
  static const uint32_t STENCIL_TEST = 2960;
  static const uint32_t DEPTH_TEST = 2929;
  static const uint32_t SCISSOR_TEST = 3089;
  static const uint32_t POLYGON_OFFSET_FILL = 32823;
  static const uint32_t SAMPLE_ALPHA_TO_COVERAGE = 32926;
  static const uint32_t SAMPLE_COVERAGE = 32928;
  static const uint32_t NO_ERROR = 0;
  static const uint32_t INVALID_ENUM = 1280;
  static const uint32_t INVALID_VALUE = 1281;
  static const uint32_t INVALID_OPERATION = 1282;
  static const uint32_t OUT_OF_MEMORY = 1285;
  static const uint32_t CW = 2304;
  static const uint32_t CCW = 2305;
  static const uint32_t LINE_WIDTH = 2849;
  static const uint32_t ALIASED_POINT_SIZE_RANGE = 33901;
  static const uint32_t ALIASED_LINE_WIDTH_RANGE = 33902;
  static const uint32_t CULL_FACE_MODE = 2885;
  static const uint32_t FRONT_FACE = 2886;
  static const uint32_t DEPTH_RANGE = 2928;
  static const uint32_t DEPTH_WRITEMASK = 2930;
  static const uint32_t DEPTH_CLEAR_VALUE = 2931;
  static const uint32_t DEPTH_FUNC = 2932;
  static const uint32_t STENCIL_CLEAR_VALUE = 2961;
  static const uint32_t STENCIL_FUNC = 2962;
  static const uint32_t STENCIL_FAIL = 2964;
  static const uint32_t STENCIL_PASS_DEPTH_FAIL = 2965;
  static const uint32_t STENCIL_PASS_DEPTH_PASS = 2966;
  static const uint32_t STENCIL_REF = 2967;
  static const uint32_t STENCIL_VALUE_MASK = 2963;
  static const uint32_t STENCIL_WRITEMASK = 2968;
  static const uint32_t STENCIL_BACK_FUNC = 34816;
  static const uint32_t STENCIL_BACK_FAIL = 34817;
  static const uint32_t STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
  static const uint32_t STENCIL_BACK_PASS_DEPTH_PASS = 34819;
  static const uint32_t STENCIL_BACK_REF = 36003;
  static const uint32_t STENCIL_BACK_VALUE_MASK = 36004;
  static const uint32_t STENCIL_BACK_WRITEMASK = 36005;
  static const uint32_t VIEWPORT = 2978;
  static const uint32_t SCISSOR_BOX = 3088;
  static const uint32_t COLOR_CLEAR_VALUE = 3106;
  static const uint32_t COLOR_WRITEMASK = 3107;
  static const uint32_t UNPACK_ALIGNMENT = 3317;
  static const uint32_t PACK_ALIGNMENT = 3333;
  static const uint32_t MAX_TEXTURE_SIZE = 3379;
  static const uint32_t MAX_VIEWPORT_DIMS = 3386;
  static const uint32_t SUBPIXEL_BITS = 3408;
  static const uint32_t RED_BITS = 3410;
  static const uint32_t GREEN_BITS = 3411;
  static const uint32_t BLUE_BITS = 3412;
  static const uint32_t ALPHA_BITS = 3413;
  static const uint32_t DEPTH_BITS = 3414;
  static const uint32_t STENCIL_BITS = 3415;
  static const uint32_t POLYGON_OFFSET_UNITS = 10752;
  static const uint32_t POLYGON_OFFSET_FACTOR = 32824;
  static const uint32_t TEXTURE_BINDING_2D = 32873;
  static const uint32_t SAMPLE_BUFFERS = 32936;
  static const uint32_t SAMPLES = 32937;
  static const uint32_t SAMPLE_COVERAGE_VALUE = 32938;
  static const uint32_t SAMPLE_COVERAGE_INVERT = 32939;
  static const uint32_t COMPRESSED_TEXTURE_FORMATS = 34467;
  static const uint32_t DONT_CARE = 4352;
  static const uint32_t FASTEST = 4353;
  static const uint32_t NICEST = 4354;
  static const uint32_t GENERATE_MIPMAP_HINT = 33170;
  static const uint32_t BYTE = 5120;
  static const uint32_t UNSIGNED_BYTE = 5121;
  static const uint32_t SHORT = 5122;
  static const uint32_t UNSIGNED_SHORT = 5123;
  static const uint32_t INT = 5124;
  static const uint32_t UNSIGNED_INT = 5125;
  static const uint32_t FLOAT = 5126;
  static const uint32_t DEPTH_COMPONENT = 6402;
  static const uint32_t ALPHA = 6406;
  static const uint32_t RGB = 6407;
  static const uint32_t RGBA = 6408;
  static const uint32_t LUMINANCE = 6409;
  static const uint32_t LUMINANCE_ALPHA = 6410;
  static const uint32_t UNSIGNED_SHORT_4_4_4_4 = 32819;
  static const uint32_t UNSIGNED_SHORT_5_5_5_1 = 32820;
  static const uint32_t UNSIGNED_SHORT_5_6_5 = 33635;
  static const uint32_t FRAGMENT_SHADER = 35632;
  static const uint32_t VERTEX_SHADER = 35633;
  static const uint32_t MAX_VERTEX_ATTRIBS = 34921;
  static const uint32_t MAX_VERTEX_UNIFORM_VECTORS = 36347;
  static const uint32_t MAX_VARYING_VECTORS = 36348;
  static const uint32_t MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
  static const uint32_t MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
  static const uint32_t MAX_TEXTURE_IMAGE_UNITS = 34930;
  static const uint32_t MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
  static const uint32_t SHADER_TYPE = 35663;
  static const uint32_t DELETE_STATUS = 35712;
  static const uint32_t LINK_STATUS = 35714;
  static const uint32_t VALIDATE_STATUS = 35715;
  static const uint32_t ATTACHED_SHADERS = 35717;
  static const uint32_t ACTIVE_UNIFORMS = 35718;
  static const uint32_t ACTIVE_ATTRIBUTES = 35721;
  static const uint32_t SHADING_LANGUAGE_VERSION = 35724;
  static const uint32_t CURRENT_PROGRAM = 35725;
  static const uint32_t NEVER = 512;
  static const uint32_t LESS = 513;
  static const uint32_t EQUAL = 514;
  static const uint32_t LEQUAL = 515;
  static const uint32_t GREATER = 516;
  static const uint32_t NOTEQUAL = 517;
  static const uint32_t GEQUAL = 518;
  static const uint32_t ALWAYS = 519;
  static const uint32_t KEEP = 7680;
  static const uint32_t REPLACE = 7681;
  static const uint32_t INCR = 7682;
  static const uint32_t DECR = 7683;
  static const uint32_t INVERT = 5386;
  static const uint32_t INCR_WRAP = 34055;
  static const uint32_t DECR_WRAP = 34056;
  static const uint32_t VENDOR = 7936;
  static const uint32_t RENDERER = 7937;
  static const uint32_t VERSION = 7938;
  static const uint32_t NEAREST = 9728;
  static const uint32_t LINEAR = 9729;
  static const uint32_t NEAREST_MIPMAP_NEAREST = 9984;
  static const uint32_t LINEAR_MIPMAP_NEAREST = 9985;
  static const uint32_t NEAREST_MIPMAP_LINEAR = 9986;
  static const uint32_t LINEAR_MIPMAP_LINEAR = 9987;
  static const uint32_t TEXTURE_MAG_FILTER = 10240;
  static const uint32_t TEXTURE_MIN_FILTER = 10241;
  static const uint32_t TEXTURE_WRAP_S = 10242;
  static const uint32_t TEXTURE_WRAP_T = 10243;
  static const uint32_t TEXTURE_2D = 3553;
  static const uint32_t TEXTURE = 5890;
  static const uint32_t TEXTURE_CUBE_MAP = 34067;
  static const uint32_t TEXTURE_BINDING_CUBE_MAP = 34068;
  static const uint32_t TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
  static const uint32_t TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
  static const uint32_t TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
  static const uint32_t TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
  static const uint32_t TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
  static const uint32_t TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
  static const uint32_t MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
  static const uint32_t TEXTURE0 = 33984;
  static const uint32_t TEXTURE1 = 33985;
  static const uint32_t TEXTURE2 = 33986;
  static const uint32_t TEXTURE3 = 33987;
  static const uint32_t TEXTURE4 = 33988;
  static const uint32_t TEXTURE5 = 33989;
  static const uint32_t TEXTURE6 = 33990;
  static const uint32_t TEXTURE7 = 33991;
  static const uint32_t TEXTURE8 = 33992;
  static const uint32_t TEXTURE9 = 33993;
  static const uint32_t TEXTURE10 = 33994;
  static const uint32_t TEXTURE11 = 33995;
  static const uint32_t TEXTURE12 = 33996;
  static const uint32_t TEXTURE13 = 33997;
  static const uint32_t TEXTURE14 = 33998;
  static const uint32_t TEXTURE15 = 33999;
  static const uint32_t TEXTURE16 = 34000;
  static const uint32_t TEXTURE17 = 34001;
  static const uint32_t TEXTURE18 = 34002;
  static const uint32_t TEXTURE19 = 34003;
  static const uint32_t TEXTURE20 = 34004;
  static const uint32_t TEXTURE21 = 34005;
  static const uint32_t TEXTURE22 = 34006;
  static const uint32_t TEXTURE23 = 34007;
  static const uint32_t TEXTURE24 = 34008;
  static const uint32_t TEXTURE25 = 34009;
  static const uint32_t TEXTURE26 = 34010;
  static const uint32_t TEXTURE27 = 34011;
  static const uint32_t TEXTURE28 = 34012;
  static const uint32_t TEXTURE29 = 34013;
  static const uint32_t TEXTURE30 = 34014;
  static const uint32_t TEXTURE31 = 34015;
  static const uint32_t ACTIVE_TEXTURE = 34016;
  static const uint32_t REPEAT = 10497;
  static const uint32_t CLAMP_TO_EDGE = 33071;
  static const uint32_t MIRRORED_REPEAT = 33648;
  static const uint32_t FLOAT_VEC2 = 35664;
  static const uint32_t FLOAT_VEC3 = 35665;
  static const uint32_t FLOAT_VEC4 = 35666;
  static const uint32_t INT_VEC2 = 35667;
  static const uint32_t INT_VEC3 = 35668;
  static const uint32_t INT_VEC4 = 35669;
  static const uint32_t BOOL = 35670;
  static const uint32_t BOOL_VEC2 = 35671;
  static const uint32_t BOOL_VEC3 = 35672;
  static const uint32_t BOOL_VEC4 = 35673;
  static const uint32_t FLOAT_MAT2 = 35674;
  static const uint32_t FLOAT_MAT3 = 35675;
  static const uint32_t FLOAT_MAT4 = 35676;
  static const uint32_t SAMPLER_2D = 35678;
  static const uint32_t SAMPLER_CUBE = 35680;
  static const uint32_t VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
  static const uint32_t VERTEX_ATTRIB_ARRAY_SIZE = 34339;
  static const uint32_t VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
  static const uint32_t VERTEX_ATTRIB_ARRAY_TYPE = 34341;
  static const uint32_t VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
  static const uint32_t VERTEX_ATTRIB_ARRAY_POINTER = 34373;
  static const uint32_t VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
  static const uint32_t IMPLEMENTATION_COLOR_READ_TYPE = 35738;
  static const uint32_t IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
  static const uint32_t COMPILE_STATUS = 35713;
  static const uint32_t LOW_FLOAT = 36336;
  static const uint32_t MEDIUM_FLOAT = 36337;
  static const uint32_t HIGH_FLOAT = 36338;
  static const uint32_t LOW_INT = 36339;
  static const uint32_t MEDIUM_INT = 36340;
  static const uint32_t HIGH_INT = 36341;
  static const uint32_t FRAMEBUFFER = 36160;
  static const uint32_t RENDERBUFFER = 36161;
  static const uint32_t RGBA4 = 32854;
  static const uint32_t RGB5_A1 = 32855;
  static const uint32_t RGB565 = 36194;
  static const uint32_t DEPTH_COMPONENT16 = 33189;
  static const uint32_t STENCIL_INDEX8 = 36168;
  static const uint32_t DEPTH_STENCIL = 34041;
  static const uint32_t RENDERBUFFER_WIDTH = 36162;
  static const uint32_t RENDERBUFFER_HEIGHT = 36163;
  static const uint32_t RENDERBUFFER_INTERNAL_FORMAT = 36164;
  static const uint32_t RENDERBUFFER_RED_SIZE = 36176;
  static const uint32_t RENDERBUFFER_GREEN_SIZE = 36177;
  static const uint32_t RENDERBUFFER_BLUE_SIZE = 36178;
  static const uint32_t RENDERBUFFER_ALPHA_SIZE = 36179;
  static const uint32_t RENDERBUFFER_DEPTH_SIZE = 36180;
  static const uint32_t RENDERBUFFER_STENCIL_SIZE = 36181;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
  static const uint32_t FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
  static const uint32_t COLOR_ATTACHMENT0 = 36064;
  static const uint32_t DEPTH_ATTACHMENT = 36096;
  static const uint32_t STENCIL_ATTACHMENT = 36128;
  static const uint32_t DEPTH_STENCIL_ATTACHMENT = 33306;
  static const uint32_t NONE = 0;
  static const uint32_t FRAMEBUFFER_COMPLETE = 36053;
  static const uint32_t FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
  static const uint32_t FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
  static const uint32_t FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
  static const uint32_t FRAMEBUFFER_UNSUPPORTED = 36061;
  static const uint32_t FRAMEBUFFER_BINDING = 36006;
  static const uint32_t RENDERBUFFER_BINDING = 36007;
  static const uint32_t MAX_RENDERBUFFER_SIZE = 34024;
  static const uint32_t INVALID_FRAMEBUFFER_OPERATION = 1286;
  static const uint32_t UNPACK_FLIP_Y_WEBGL = 37440;
  static const uint32_t UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
  static const uint32_t CONTEXT_LOST_WEBGL = 37442;
  static const uint32_t UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
  static const uint32_t BROWSER_DEFAULT_WEBGL = 37444;
  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::ClientWebGLContext* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLRenderingContext,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLRenderingContext,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLRenderingContext_Binding



namespace WebGLShader_Binding {

  typedef mozilla::WebGLShaderJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLShaderJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLShader,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLShader,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLShader_Binding



namespace WebGLShaderPrecisionFormat_Binding {

  typedef mozilla::WebGLShaderPrecisionFormatJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLShaderPrecisionFormatJS* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLShaderPrecisionFormat,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLShaderPrecisionFormat,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLShaderPrecisionFormat_Binding



namespace WebGLTexture_Binding {

  typedef mozilla::WebGLTextureJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLTextureJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLTexture,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLTexture,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLTexture_Binding



namespace WebGLUniformLocation_Binding {

  typedef mozilla::WebGLUniformLocationJS NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLUniformLocationJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLUniformLocation,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLUniformLocation,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLUniformLocation_Binding



namespace WebGLVertexArrayObject_Binding {

  typedef mozilla::WebGLVertexArrayJS NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::WebGLVertexArrayJS* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::WebGLVertexArrayObject,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::WebGLVertexArrayObject,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace WebGLVertexArrayObject_Binding



} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_WebGLRenderingContextBinding_h
