// -*- mode: C++ -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef mozilla_GleanJSMetricsLookup_h
#define mozilla_GleanJSMetricsLookup_h

#include "mozilla/PerfectHash.h"
#include "mozilla/Maybe.h"
#include "mozilla/glean/bindings/MetricTypes.h"
#include "mozilla/glean/fog_ffi_generated.h"

#define GLEAN_INDEX_BITS (32)
#define GLEAN_ID_BITS (27)
#define GLEAN_TYPE_ID(id) ((id) >> GLEAN_ID_BITS)
#define GLEAN_METRIC_ID(id) ((id) & ((1ULL << GLEAN_ID_BITS) - 1))
#define GLEAN_OFFSET(entry) (entry & ((1ULL << GLEAN_INDEX_BITS) - 1))

namespace mozilla::glean {

// The category lookup table's entry type
using category_entry_t = uint32_t;
// The metric lookup table's entry type
using metric_entry_t = uint64_t;

static_assert(GLEAN_INDEX_BITS + GLEAN_ID_BITS < sizeof(metric_entry_t) * 8, "Index and ID bits need to fit into an category_entry_t");
static_assert(GLEAN_ID_BITS < sizeof(uint32_t) * 8, "Metric IDs need to fit into less than 32 bit");
static_assert(5 < UINT32_MAX, "Too many metric categories generated.");
static_assert(27 < 134217728, "Too many metrics generated.");
static_assert(13 < 32, "Too many different metric types.");

static already_AddRefed<nsISupports> NewMetricFromId(uint32_t id) {
  uint32_t typeId = GLEAN_TYPE_ID(id);
  uint32_t metricId = GLEAN_METRIC_ID(id);

  switch (typeId) {
    case 1: /* timespan */
    {
      return MakeAndAddRef<GleanTimespan>(metricId);
    }
    case 2: /* counter */
    {
      return MakeAndAddRef<GleanCounter>(metricId);
    }
    case 3: /* uuid */
    {
      return MakeAndAddRef<GleanUuid>(metricId);
    }
    case 4: /* string */
    {
      return MakeAndAddRef<GleanString>(metricId);
    }
    case 5: /* boolean */
    {
      return MakeAndAddRef<GleanBoolean>(metricId);
    }
    case 6: /* string_list */
    {
      return MakeAndAddRef<GleanStringList>(metricId);
    }
    case 7: /* datetime */
    {
      return MakeAndAddRef<GleanDatetime>(metricId);
    }
    case 8: /* memory_distribution */
    {
      return MakeAndAddRef<GleanMemoryDistribution>(metricId);
    }
    case 9: /* timing_distribution */
    {
      return MakeAndAddRef<GleanTimingDistribution>(metricId);
    }
    case 10: /* labeled_counter */
    {
      return MakeAndAddRef<GleanLabeled>(metricId, 10);
    }
    case 11: /* labeled_boolean */
    {
      return MakeAndAddRef<GleanLabeled>(metricId, 11);
    }
    case 12: /* labeled_string */
    {
      return MakeAndAddRef<GleanLabeled>(metricId, 12);
    }
    case 13: /* event */
    {
      return MakeAndAddRef<GleanEvent>(metricId);
    }
    default:
    MOZ_ASSERT_UNREACHABLE("Invalid type ID reached when trying to instantiate a new metric");
    return nullptr;
  }
}

static already_AddRefed<nsISupports> NewSubMetricFromIds(uint32_t aParentTypeId, uint32_t aParentMetricId, const nsACString& aLabel) {
  switch (aParentTypeId) {
    case 10: { /* labeled_counter */
      return MakeAndAddRef<GleanCounter>(impl::fog_labeled_counter_get(aParentMetricId, &aLabel));
    }
    case 11: { /* labeled_boolean */
      return MakeAndAddRef<GleanBoolean>(impl::fog_labeled_boolean_get(aParentMetricId, &aLabel));
    }
    case 12: { /* labeled_string */
      return MakeAndAddRef<GleanString>(impl::fog_labeled_string_get(aParentMetricId, &aLabel));
    }
    default: {
      MOZ_ASSERT_UNREACHABLE("Invalid type ID for submetric.");
      return nullptr;
    }
  }
}

static Maybe<uint32_t> category_result_check(const nsACString& aKey, category_entry_t entry);
static Maybe<uint32_t> metric_result_check(const nsACString& aKey, metric_entry_t entry);

#if defined(_MSC_VER) && !defined(__clang__)
const char gCategoryStringTable[] = {
#else
constexpr char gCategoryStringTable[] = {
#endif
  /*     0 - "fog" */ 'f', 'o', 'g', '\0',
  /*     4 - "fogIpc" */ 'f', 'o', 'g', 'I', 'p', 'c', '\0',
  /*    11 - "fogValidation" */ 'f', 'o', 'g', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'i', 'o', 'n', '\0',
  /*    25 - "testOnly" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '\0',
  /*    34 - "testOnlyIpc" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '\0',
};


static_assert(sizeof(gCategoryStringTable) < UINT32_MAX, "Category string table is too large.");

const category_entry_t sCategoryByNameLookupEntries[] = {
  0,
  4,
  11,
  25,
  34
};



static Maybe<uint32_t>
CategoryByNameLookup(const nsACString& aKey)
{
  static const uint8_t BASES[] = {
       0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   1,
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   5,   0,   0,   0,   0,   0,   0,   0,   6,
  };
  

  const char* bytes = aKey.BeginReading();
  size_t length = aKey.Length();
  auto& entry = mozilla::perfecthash::Lookup(bytes, length, BASES,
                                             sCategoryByNameLookupEntries);
  return category_result_check(aKey, entry);
}


#if defined(_MSC_VER) && !defined(__clang__)
const char gMetricStringTable[] = {
#else
constexpr char gMetricStringTable[] = {
#endif
  /*     0 - "fog.initialization" */ 'f', 'o', 'g', '.', 'i', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n', '\0',
  /*    19 - "fogIpc.replayFailures" */ 'f', 'o', 'g', 'I', 'p', 'c', '.', 'r', 'e', 'p', 'l', 'a', 'y', 'F', 'a', 'i', 'l', 'u', 'r', 'e', 's', '\0',
  /*    41 - "fogValidation.legacyTelemetryClientId" */ 'f', 'o', 'g', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'i', 'o', 'n', '.', 'l', 'e', 'g', 'a', 'c', 'y', 'T', 'e', 'l', 'e', 'm', 'e', 't', 'r', 'y', 'C', 'l', 'i', 'e', 'n', 't', 'I', 'd', '\0',
  /*    79 - "fogValidation.osVersion" */ 'f', 'o', 'g', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'i', 'o', 'n', '.', 'o', 's', 'V', 'e', 'r', 's', 'i', 'o', 'n', '\0',
  /*   103 - "fogValidation.profileDiskIsSsd" */ 'f', 'o', 'g', 'V', 'a', 'l', 'i', 'd', 'a', 't', 'i', 'o', 'n', '.', 'p', 'r', 'o', 'f', 'i', 'l', 'e', 'D', 'i', 's', 'k', 'I', 's', 'S', 's', 'd', '\0',
  /*   134 - "testOnly.badCode" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'b', 'a', 'd', 'C', 'o', 'd', 'e', '\0',
  /*   151 - "testOnly.canWeTimeIt" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'c', 'a', 'n', 'W', 'e', 'T', 'i', 'm', 'e', 'I', 't', '\0',
  /*   172 - "testOnly.cheesyString" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'c', 'h', 'e', 'e', 's', 'y', 'S', 't', 'r', 'i', 'n', 'g', '\0',
  /*   194 - "testOnly.cheesyStringList" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'c', 'h', 'e', 'e', 's', 'y', 'S', 't', 'r', 'i', 'n', 'g', 'L', 'i', 's', 't', '\0',
  /*   220 - "testOnly.whatADate" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'w', 'h', 'a', 't', 'A', 'D', 'a', 't', 'e', '\0',
  /*   239 - "testOnly.whatIdIt" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'w', 'h', 'a', 't', 'I', 'd', 'I', 't', '\0',
  /*   257 - "testOnly.canWeFlagIt" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'c', 'a', 'n', 'W', 'e', 'F', 'l', 'a', 'g', 'I', 't', '\0',
  /*   278 - "testOnly.doYouRemember" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'd', 'o', 'Y', 'o', 'u', 'R', 'e', 'm', 'e', 'm', 'b', 'e', 'r', '\0',
  /*   301 - "testOnly.whatTimeIsIt" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'w', 'h', 'a', 't', 'T', 'i', 'm', 'e', 'I', 's', 'I', 't', '\0',
  /*   323 - "testOnly.mabelsKitchenCounters" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'm', 'a', 'b', 'e', 'l', 's', 'K', 'i', 't', 'c', 'h', 'e', 'n', 'C', 'o', 'u', 'n', 't', 'e', 'r', 's', '\0',
  /*   354 - "testOnly.mabelsLikeBalloons" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'm', 'a', 'b', 'e', 'l', 's', 'L', 'i', 'k', 'e', 'B', 'a', 'l', 'l', 'o', 'o', 'n', 's', '\0',
  /*   382 - "testOnly.mabelsBalloonStrings" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', '.', 'm', 'a', 'b', 'e', 'l', 's', 'B', 'a', 'l', 'l', 'o', 'o', 'n', 'S', 't', 'r', 'i', 'n', 'g', 's', '\0',
  /*   412 - "testOnlyIpc.aCounter" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'C', 'o', 'u', 'n', 't', 'e', 'r', '\0',
  /*   433 - "testOnlyIpc.aBool" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'B', 'o', 'o', 'l', '\0',
  /*   451 - "testOnlyIpc.aDate" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'D', 'a', 't', 'e', '\0',
  /*   469 - "testOnlyIpc.aString" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'S', 't', 'r', 'i', 'n', 'g', '\0',
  /*   489 - "testOnlyIpc.aMemoryDist" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'M', 'e', 'm', 'o', 'r', 'y', 'D', 'i', 's', 't', '\0',
  /*   513 - "testOnlyIpc.aTimingDist" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'T', 'i', 'm', 'i', 'n', 'g', 'D', 'i', 's', 't', '\0',
  /*   537 - "testOnlyIpc.aStringList" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'S', 't', 'r', 'i', 'n', 'g', 'L', 'i', 's', 't', '\0',
  /*   561 - "testOnlyIpc.anEvent" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'n', 'E', 'v', 'e', 'n', 't', '\0',
  /*   581 - "testOnlyIpc.noExtraEvent" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'n', 'o', 'E', 'x', 't', 'r', 'a', 'E', 'v', 'e', 'n', 't', '\0',
  /*   606 - "testOnlyIpc.aUuid" */ 't', 'e', 's', 't', 'O', 'n', 'l', 'y', 'I', 'p', 'c', '.', 'a', 'U', 'u', 'i', 'd', '\0',
};


static_assert(sizeof(gMetricStringTable) < 4294967296, "Metric string table is too large.");

const metric_entry_t sMetricByNameLookupEntries[] = {
  5764607587458744643,
  6917529100655526270,
  1152921581916258716,
  2305843099408007637,
  2882303782991954023,
  1729382372874388062,
  5188146830860353837,
  4035225309073637596,
  7493989887318688305,
  2305843026393563215,
  4035225352023310787,
  576460756598390784,
  1729382304154910959,
  2882303813056725249,
  6341068344057135458,
  3458764552475246786,
  576460782368194711,
  5188146869515059713,
  3458764616899756569,
  7493989891613655621,
  4611686074261963030,
  4611686112916668905,
  2305843043573432492,
  2882303843121496497,
  1729382269795172393,
  1152921513196781587,
  1152921530376650886
};



static Maybe<uint32_t>
MetricByNameLookup(const nsACString& aKey)
{
  static const uint8_t BASES[] = {
       0,   0,   1,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,
       0,   0,   1,   2,   0,   0,   0,   0,   1,   0,   0,   3,   0,   1,   1,   0,
       0,   2,   2,   5,   0,   0,   0,   8,   0,   0,   1,   0,   7,   3,   3,   4,
       2,   0,   0,   0,   0,   0,   3,   9,  10,  11,   0,  30,   0,   0,   0,   0,
  };
  

  const char* bytes = aKey.BeginReading();
  size_t length = aKey.Length();
  auto& entry = mozilla::perfecthash::Lookup(bytes, length, BASES,
                                             sMetricByNameLookupEntries);
  return metric_result_check(aKey, entry);
}


/**
 * Get a category's name from the string table.
 */
static const char* GetCategoryName(category_entry_t entry) {
  MOZ_ASSERT(entry < sizeof(gCategoryStringTable), "Entry identifier offset larger than string table");
  return &gCategoryStringTable[entry];
}

/**
 * Get a metric's identifier from the string table.
 */
static const char* GetMetricIdentifier(metric_entry_t entry) {
  uint32_t offset = GLEAN_OFFSET(entry);
  MOZ_ASSERT(offset < sizeof(gMetricStringTable), "Entry identifier offset larger than string table");
  return &gMetricStringTable[offset];
}

/**
 * Check that the found entry is pointing to the right key
 * and return it.
 * Or return `Nothing()` if the entry was not found.
 */
static Maybe<uint32_t> category_result_check(const nsACString& aKey, category_entry_t entry) {
  if (MOZ_UNLIKELY(entry > sizeof(gCategoryStringTable))) {
    return Nothing();
  }
  if (aKey.EqualsASCII(gCategoryStringTable + entry)) {
    return Some(entry);
  }
  return Nothing();
}

/**
 * Check if the found entry index is pointing to the right key
 * and return the corresponding metric ID.
 * Or return `Nothing()` if the entry was not found.
 */
static Maybe<uint32_t> metric_result_check(const nsACString& aKey, uint64_t entry) {
  uint32_t metricId = entry >> GLEAN_INDEX_BITS;
  uint32_t offset = GLEAN_OFFSET(entry);

  if (offset > sizeof(gMetricStringTable)) {
    return Nothing();
  }

  if (aKey.EqualsASCII(gMetricStringTable + offset)) {
    return Some(metricId);
  }

  return Nothing();
}


#undef GLEAN_INDEX_BITS
#undef GLEAN_ID_BITS
#undef GLEAN_TYPE_ID
#undef GLEAN_METRIC_ID
#undef GLEAN_OFFSET

} // namespace mozilla::glean
#endif // mozilla_GleanJSMetricsLookup_h
