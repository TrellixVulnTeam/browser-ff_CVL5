// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */


pub mod fog {
    use crate::private::*;
    use glean::CommonMetricData;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from fog.initialization
    ///
    /// Time the FOG initialization takes.
    pub static initialization: Lazy<TimespanMetric> = Lazy::new(|| {
        TimespanMetric::new(1.into(), CommonMetricData {
            name: "initialization".into(),
            category: "fog".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Nanosecond)
    });

}
pub mod fog_ipc {
    use crate::private::*;
    use glean::CommonMetricData;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from fog.ipc.replay_failures
    ///
    /// The number of times the ipc buffer failed to be replayed in the
    /// parent process.
    pub static replay_failures: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::new(2.into(), CommonMetricData {
            name: "replay_failures".into(),
            category: "fog.ipc".into(),
            send_in_pings: vec!["metrics".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

}
pub mod fog_validation {
    use crate::private::*;
    use glean::CommonMetricData;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from fog_validation.legacy_telemetry_client_id
    ///
    /// The Telemetry client_id. To be sent only in the "fog-validation" ping.
    pub static legacy_telemetry_client_id: Lazy<UuidMetric> = Lazy::new(|| {
        UuidMetric::new(3.into(), CommonMetricData {
            name: "legacy_telemetry_client_id".into(),
            category: "fog_validation".into(),
            send_in_pings: vec!["fog-validation".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from fog_validation.os_version
    ///
    /// The version of the OS running Firefox, as detected by Gecko. To be sent only in
    /// the "fog-validation" ping.
    pub static os_version: Lazy<StringMetric> = Lazy::new(|| {
        StringMetric::new(4.into(), CommonMetricData {
            name: "os_version".into(),
            category: "fog_validation".into(),
            send_in_pings: vec!["fog-validation".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from fog_validation.profile_disk_is_ssd
    ///
    /// True iff the type of the disk the current Firefox profile is stored on is an
    /// SSD. (Windows only).
    pub static profile_disk_is_ssd: Lazy<BooleanMetric> = Lazy::new(|| {
        BooleanMetric::new(5.into(), CommonMetricData {
            name: "profile_disk_is_ssd".into(),
            category: "fog_validation".into(),
            send_in_pings: vec!["fog-validation".into()],
            lifetime: Lifetime::Application,
            disabled: false,
            ..Default::default()
        })
    });

}
pub mod test_only {
    use crate::private::*;
    use glean::CommonMetricData;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test_only.bad_code
    ///
    /// Number of times we encountered bad code.
    /// This is a test-only metric.
    pub static bad_code: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::new(6.into(), CommonMetricData {
            name: "bad_code".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.can_we_time_it
    ///
    /// Test metric for a timespan.
    /// This is a test-only metric.
    pub static can_we_time_it: Lazy<TimespanMetric> = Lazy::new(|| {
        TimespanMetric::new(7.into(), CommonMetricData {
            name: "can_we_time_it".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Nanosecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.cheesy_string
    ///
    /// Only the cheesiest of strings.
    /// This is a test-only metric.
    pub static cheesy_string: Lazy<StringMetric> = Lazy::new(|| {
        StringMetric::new(8.into(), CommonMetricData {
            name: "cheesy_string".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.cheesy_string_list
    ///
    /// Only the cheesiest of strings. In list form!
    /// This is a test-only metric.
    pub static cheesy_string_list: Lazy<StringListMetric> = Lazy::new(|| {
        StringListMetric::new(9.into(), CommonMetricData {
            name: "cheesy_string_list".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.what_a_date
    ///
    /// ...To be writing FOG code. This is a test-only metric.
    pub static what_a_date: Lazy<DatetimeMetric> = Lazy::new(|| {
        DatetimeMetric::new(10.into(), CommonMetricData {
            name: "what_a_date".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Second)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.what_id_it
    ///
    /// Just a UUID.
    /// This is a test-only metric.
    pub static what_id_it: Lazy<UuidMetric> = Lazy::new(|| {
        UuidMetric::new(11.into(), CommonMetricData {
            name: "what_id_it".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.can_we_flag_it
    ///
    /// Test metric for a boolean.
    /// This is a test-only metric.
    pub static can_we_flag_it: Lazy<BooleanMetric> = Lazy::new(|| {
        BooleanMetric::new(12.into(), CommonMetricData {
            name: "can_we_flag_it".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.do_you_remember
    ///
    /// They say it's the second thing to go.
    /// This is a test-only metric.
    pub static do_you_remember: Lazy<MemoryDistributionMetric> = Lazy::new(|| {
        MemoryDistributionMetric::new(13.into(), CommonMetricData {
            name: "do_you_remember".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, MemoryUnit::Megabyte)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.what_time_is_it
    ///
    /// Adheres to at least two of the top ten fallacies programmers believe
    /// about time.
    /// This is a test-only metric.
    pub static what_time_is_it: Lazy<TimingDistributionMetric> = Lazy::new(|| {
        TimingDistributionMetric::new(14.into(), CommonMetricData {
            name: "what_time_is_it".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Microsecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.mabels_kitchen_counters
    ///
    /// Counts Mabels labeled by their kitchen counters.
    /// This is a test-only metric.
    pub static mabels_kitchen_counters: Lazy<LabeledMetric<CounterMetric>> = Lazy::new(|| {
        LabeledMetric::new(15.into(), CommonMetricData {
            name: "mabels_kitchen_counters".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, None)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.mabels_like_balloons
    ///
    /// Does the labeled Mabel like balloons?
    /// This is a test-only metric.
    pub static mabels_like_balloons: Lazy<LabeledMetric<BooleanMetric>> = Lazy::new(|| {
        LabeledMetric::new(16.into(), CommonMetricData {
            name: "mabels_like_balloons".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, None)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.mabels_balloon_strings
    ///
    /// What do the labeled Mabel's liked balloons' strings say?
    /// This is a test-only metric.
    pub static mabels_balloon_strings: Lazy<LabeledMetric<StringMetric>> = Lazy::new(|| {
        LabeledMetric::new(17.into(), CommonMetricData {
            name: "mabels_balloon_strings".into(),
            category: "test_only".into(),
            send_in_pings: vec!["test-ping".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, None)
    });

}
pub mod test_only_ipc {
    use crate::private::*;
    use glean::CommonMetricData;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_counter
    ///
    /// This is a test-only metric.
    /// Just counting things.
    pub static a_counter: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::new(18.into(), CommonMetricData {
            name: "a_counter".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_bool
    ///
    /// This is a test-only metric.
    /// Just flagging things.
    pub static a_bool: Lazy<BooleanMetric> = Lazy::new(|| {
        BooleanMetric::new(19.into(), CommonMetricData {
            name: "a_bool".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_date
    ///
    /// This is a test-only metric.
    /// Just putting things on the calendar.
    pub static a_date: Lazy<DatetimeMetric> = Lazy::new(|| {
        DatetimeMetric::new(20.into(), CommonMetricData {
            name: "a_date".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Second)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_string
    ///
    /// This is a test-only metric.
    /// Just setting some strings.
    pub static a_string: Lazy<StringMetric> = Lazy::new(|| {
        StringMetric::new(21.into(), CommonMetricData {
            name: "a_string".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_memory_dist
    ///
    /// This is a test-only metric.
    /// Just measuring memory.
    pub static a_memory_dist: Lazy<MemoryDistributionMetric> = Lazy::new(|| {
        MemoryDistributionMetric::new(22.into(), CommonMetricData {
            name: "a_memory_dist".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, MemoryUnit::Kilobyte)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_timing_dist
    ///
    /// This is a test-only metric.
    /// Just measuring time.
    pub static a_timing_dist: Lazy<TimingDistributionMetric> = Lazy::new(|| {
        TimingDistributionMetric::new(23.into(), CommonMetricData {
            name: "a_timing_dist".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        }, TimeUnit::Nanosecond)
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_string_list
    ///
    /// This is a test-only metric.
    /// Just appending some strings.
    pub static a_string_list: Lazy<StringListMetric> = Lazy::new(|| {
        StringListMetric::new(24.into(), CommonMetricData {
            name: "a_string_list".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[derive(Clone, Copy, Hash, Eq, PartialEq)]
    pub enum AnEventKeys {
        Extra1,
        Extra2,
    }

    impl ExtraKeys for AnEventKeys {
        const ALLOWED_KEYS: &'static [&'static str] = &["extra1", "extra2"];

        fn index(self) -> i32 {
            self as i32
        }
    }

    /// Convert from an extra key's index to its variant.
    impl std::convert::TryFrom<i32> for AnEventKeys {
        type Error = EventRecordingError;

        fn try_from(value: i32) -> Result<Self, Self::Error> {
          match value {
              0 => Ok(Self::Extra1),
              1 => Ok(Self::Extra2),
              _ => Err(EventRecordingError::InvalidExtraKey),
          }
        }
    }

    /// Convert from an extra key's string representation to its variant.
    impl std::convert::TryFrom<&str> for AnEventKeys {
        type Error = EventRecordingError;

        fn try_from(value: &str) -> Result<Self, Self::Error> {
          match value {
              "extra1" => Ok(Self::Extra1),
              "extra2" => Ok(Self::Extra2),
              _ => Err(EventRecordingError::InvalidExtraKey),
          }
        }
    }

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.an_event
    ///
    /// This is a test-only metric.
    /// Just recording some events.
    pub static an_event: Lazy<EventMetric<AnEventKeys>> = Lazy::new(|| {
        EventMetric::new(25.into(), CommonMetricData {
            name: "an_event".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.no_extra_event
    ///
    /// This is a test-only metric.
    /// Just recording some events without the extra fuss.
    pub static no_extra_event: Lazy<EventMetric<NoExtraKeys>> = Lazy::new(|| {
        EventMetric::new(26.into(), CommonMetricData {
            name: "no_extra_event".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[allow(non_upper_case_globals)]
    /// generated from test_only.ipc.a_uuid
    ///
    /// This is a test-only metric.
    /// Just recording some unique identifiers.
    pub static a_uuid: Lazy<UuidMetric> = Lazy::new(|| {
        UuidMetric::new(27.into(), CommonMetricData {
            name: "a_uuid".into(),
            category: "test_only.ipc".into(),
            send_in_pings: vec!["store1".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

}

#[allow(dead_code)]
pub(crate) mod __glean_metric_maps {
    use std::collections::HashMap;
    use std::convert::TryInto;

    use crate::private::*;
    use once_cell::sync::Lazy;

    pub static TIMESPAN_MAP: Lazy<HashMap<MetricId, &Lazy<TimespanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(1.into(), &super::fog::initialization);
        map.insert(7.into(), &super::test_only::can_we_time_it);
        map
    });

    pub static COUNTER_MAP: Lazy<HashMap<MetricId, &Lazy<CounterMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(3);
        map.insert(2.into(), &super::fog_ipc::replay_failures);
        map.insert(6.into(), &super::test_only::bad_code);
        map.insert(18.into(), &super::test_only_ipc::a_counter);
        map
    });

    pub static UUID_MAP: Lazy<HashMap<MetricId, &Lazy<UuidMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(3);
        map.insert(3.into(), &super::fog_validation::legacy_telemetry_client_id);
        map.insert(11.into(), &super::test_only::what_id_it);
        map.insert(27.into(), &super::test_only_ipc::a_uuid);
        map
    });

    pub static STRING_MAP: Lazy<HashMap<MetricId, &Lazy<StringMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(3);
        map.insert(4.into(), &super::fog_validation::os_version);
        map.insert(8.into(), &super::test_only::cheesy_string);
        map.insert(21.into(), &super::test_only_ipc::a_string);
        map
    });

    pub static BOOLEAN_MAP: Lazy<HashMap<MetricId, &Lazy<BooleanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(3);
        map.insert(5.into(), &super::fog_validation::profile_disk_is_ssd);
        map.insert(12.into(), &super::test_only::can_we_flag_it);
        map.insert(19.into(), &super::test_only_ipc::a_bool);
        map
    });

    pub static STRING_LIST_MAP: Lazy<HashMap<MetricId, &Lazy<StringListMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(9.into(), &super::test_only::cheesy_string_list);
        map.insert(24.into(), &super::test_only_ipc::a_string_list);
        map
    });

    pub static DATETIME_MAP: Lazy<HashMap<MetricId, &Lazy<DatetimeMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(10.into(), &super::test_only::what_a_date);
        map.insert(20.into(), &super::test_only_ipc::a_date);
        map
    });

    pub static MEMORY_DISTRIBUTION_MAP: Lazy<HashMap<MetricId, &Lazy<MemoryDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(13.into(), &super::test_only::do_you_remember);
        map.insert(22.into(), &super::test_only_ipc::a_memory_dist);
        map
    });

    pub static TIMING_DISTRIBUTION_MAP: Lazy<HashMap<MetricId, &Lazy<TimingDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(14.into(), &super::test_only::what_time_is_it);
        map.insert(23.into(), &super::test_only_ipc::a_timing_dist);
        map
    });

    pub static LABELED_COUNTER_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<CounterMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(15.into(), &super::test_only::mabels_kitchen_counters);
        map
    });

    pub static LABELED_BOOLEAN_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<BooleanMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(16.into(), &super::test_only::mabels_like_balloons);
        map
    });

    pub static LABELED_STRING_MAP: Lazy<HashMap<MetricId, &Lazy<LabeledMetric<StringMetric>>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(17.into(), &super::test_only::mabels_balloon_strings);
        map
    });


    /// Helper to get the number of allowed extra keys for a given event metric.
    fn extra_keys_len<K: ExtraKeys>(_event: &EventMetric<K>) -> usize {
        K::ALLOWED_KEYS.len()
    }

    /// Wrapper to record an event based on its metric ID.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `extra`     - An (optional) map of (extra key id, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` type.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` the `extra` map could not be deserialized.
    pub(crate) fn event_record_wrapper(metric_id: u32, extra: HashMap<i32, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          25 => {
              assert!(
                  extra_keys_len(&super::test_only_ipc::an_event) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              // In case of `NoExtraKeys` the whole iterator is impossible, so rustc complains.
              #[allow(unused_variables)]
              let extra: HashMap<_, _> = extra
                  .into_iter()
                  .map(|(k, v)| k.try_into().map(|k| (k, v)))
                  .collect::<Result<HashMap<_, _>, _>>()?;
              super::test_only_ipc::an_event.record(Some(extra));
              Ok(())
          }
          26 => {
              assert!(
                  extra_keys_len(&super::test_only_ipc::no_extra_event) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              // In case of `NoExtraKeys` the whole iterator is impossible, so rustc complains.
              #[allow(unused_variables)]
              let extra: HashMap<_, _> = extra
                  .into_iter()
                  .map(|(k, v)| k.try_into().map(|k| (k, v)))
                  .collect::<Result<HashMap<_, _>, _>>()?;
              super::test_only_ipc::no_extra_event.record(Some(extra));
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to record an event based on its metric ID.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `extra`     - An (optional) map of (string, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` types.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` the `extra` map could not be deserialized.
    pub(crate) fn event_record_wrapper_str(metric_id: u32, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          25 => {
              assert!(
                  extra_keys_len(&super::test_only_ipc::an_event) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              // In case of `NoExtraKeys` the whole iterator is impossible, so rustc complains.
              #[allow(unused_variables)]
              let extra = extra
                  .into_iter()
                  .map(|(k, v)| (&*k).try_into().map(|k| (k, v)))
                  .collect::<Result<HashMap<_, _>, _>>()?;
              super::test_only_ipc::an_event.record(Some(extra));
              Ok(())
          }
          26 => {
              assert!(
                  extra_keys_len(&super::test_only_ipc::no_extra_event) != 0 || extra.is_empty(),
                  "No extra keys allowed, but some were passed"
              );

              // In case of `NoExtraKeys` the whole iterator is impossible, so rustc complains.
              #[allow(unused_variables)]
              let extra = extra
                  .into_iter()
                  .map(|(k, v)| (&*k).try_into().map(|k| (k, v)))
                  .collect::<Result<HashMap<_, _>, _>>()?;
              super::test_only_ipc::no_extra_event.record(Some(extra));
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to get the currently stored events for event metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `storage_name` - the storage name to look into.
    ///
    /// # Returns
    ///
    /// Returns the recorded events or `None` if nothing stored.
    ///
    /// # Panics
    ///
    /// Panics if no event by the given metric ID could be found.
    pub(crate) fn event_test_get_value_wrapper(metric_id: u32, storage_name: &str) -> Option<Vec<RecordedEvent>> {
        match metric_id {
           25 => super::test_only_ipc::an_event.test_get_value(storage_name),
           26 => super::test_only_ipc::no_extra_event.test_get_value(storage_name),
           _ => panic!("No event for metric id {}", metric_id),
        }
    }

    pub(crate) mod submetric_maps {
        use std::sync::{
          atomic::AtomicU32,
          RwLock,
        };
        use super::*;

        pub(crate) const MIN_LABELED_SUBMETRIC_ID: u32 = 134217729;
        pub(crate) static NEXT_LABELED_SUBMETRIC_ID: AtomicU32 = AtomicU32::new(MIN_LABELED_SUBMETRIC_ID);
        pub(crate) static LABELED_METRICS_TO_IDS: Lazy<RwLock<HashMap<(u32, String), u32>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );

        pub static COUNTER_MAP: Lazy<RwLock<HashMap<MetricId, CounterMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static STRING_MAP: Lazy<RwLock<HashMap<MetricId, StringMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static BOOLEAN_MAP: Lazy<RwLock<HashMap<MetricId, BooleanMetric>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
    }
}

